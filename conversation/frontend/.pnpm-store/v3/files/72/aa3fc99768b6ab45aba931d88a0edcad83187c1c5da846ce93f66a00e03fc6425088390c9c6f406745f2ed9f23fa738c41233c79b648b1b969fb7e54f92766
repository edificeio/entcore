import { Node, mergeAttributes } from "@tiptap/core";
import { Plugin } from "prosemirror-state";
const ConversationHistory = Node.create({
  name: "converstationHistory",
  group: "block",
  content: "block",
  parseHTML() {
    return [
      {
        tag: "div.conversation-history"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "div",
      mergeAttributes(HTMLAttributes, { class: "conversation-history" }),
      0
    ];
  },
  /**
   * Adds custom ProseMirror plugins to the editor.
   * When a horizontal rule is encountered, this plugin collects all nodes
   * following the horizontal rule until the end of the document.
   * These nodes are then grouped together and replaced with
   * a single node of the same type as the plugin's type.
   *
   * @returns {Plugin[]} An array of ProseMirror plugins.
   */
  addProseMirrorPlugins() {
    return [
      new Plugin({
        appendTransaction: (transactions, oldState, newState) => {
          const tr = newState.tr;
          let modified = !1;
          const nodesAfterHr = [];
          return newState.doc.descendants((node, pos, parent) => {
            if (node.type.name === "horizontalRule" && parent.type.name === "doc") {
              const start = pos, end = newState.doc.content.size;
              if (newState.doc.nodesBetween(start, end, (n, p, parent2) => {
                if (n.type.name !== "horizontalRule" && parent2.type.name === "doc")
                  nodesAfterHr.push({ node: n, pos: p });
                else
                  return !1;
              }), nodesAfterHr.length > 0) {
                const groupNode = this.type.create(
                  {},
                  nodesAfterHr.map((n) => n.node)
                );
                tr.replaceWith(start, end, groupNode), modified = !0;
              }
              return !1;
            }
          }), modified ? tr : null;
        }
      })
    ];
  }
});
export {
  ConversationHistory
};
//# sourceMappingURL=conversation-history.js.map
