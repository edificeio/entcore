var v = Object.defineProperty;
var T = (u, e, t) => e in u ? v(u, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : u[e] = t;
var o = (u, e, t) => T(u, typeof e != "symbol" ? e + "" : e, t);
import axios from "axios";
import { MimeTypeUtils } from "@edifice.io/utilities";
const ERROR_CODE = {
  SUCCESS: "0000",
  UNKNOWN: "0010",
  NOT_INITIALIZED: "0020",
  NOT_SUPPORTED: "0030",
  APP_NOT_FOUND: "0040",
  AGENT_NOT_FOUND: "0050",
  TRANSPORT_ERROR: "0060",
  TIME_OUT: "0070",
  MALFORMED_DATA: "0080",
  NOT_LOGGED_IN: "0090"
}, APP$3 = {
  ADMIN: "admin",
  ARCHIVE: "archive",
  AUTH: "auth",
  CAS: "cas",
  COMMUNICATION: "communication",
  CONVERSATION: "conversation",
  DIRECTORY: "directory",
  // FIXME userbook OR directory : the choice may impact some configurations, @see IXitiTrackingParams.NOM_PAGE for example
  USERBOOK: "userbook",
  INFRA: "infra",
  PORTAL: "portal",
  TIMELINE: "timeline",
  WORKSPACE: "workspace",
  // -- a few others commonly used apps
  EXPLORER: "explorer",
  HOMEWORKS: "homeworks",
  VIDEO: "video",
  MINDMAP: "mindmap",
  SCRAPBOOK: "scrapbook",
  COLLABORATIVEWALL: "collaborativewall",
  WIKI: "wiki",
  TIMELINEGENERATOR: "timelinegenerator"
  // TODO compléter/trier les apps suivantes
  /*
    "competences"
    "cahier-textes"
    "poll"
    "rack"
    "rbs"
    "searchengine"
    "sharebigfiles"
    "schoolbook"
    "archive"
    "admin"
    "cahier-de-texte"
    "wiki"
    "cns"
    "conversation"
    "paths"
    "parcours"
    "notebook"
    "account"
    "support"
    "workspace"
    "admin-portal"
    "stats"
    "userbook"    // FIXME userbook OR directory : the choice may impact some configurations, @see IXitiTrackingParams.NOM_PAGE for example
    "directory"   // FIXME Keep in mind that ode-ts-client MUST not access the locationPath of the window !
    "mindmap"
    "timelinegenerator"
    "actualites"
    "pad"
    "collaborativeeditor"
    "settings-class"
    "library"
    "visioconf"
    "Web-conference"
    "notes"
    "attendance"
    "calendar"
    "canal-numerique"
    "collaborative-wall"
    "statistics"
    "polls"
    "community"
    "forum"
    "pages"
    "website"
    "parametrage"
    "kne"
    "sacoche"
  */
}, USER_PREFS = {
  APPS: "apps",
  WIDGETS: "widgets",
  LANGUAGE: "language",
  AUTH_CONNECTOR_ACCESSED: "authenticatedConnectorsAccessed",
  CURSUS: "cursus",
  INFOTIP: "infotip",
  RGPD_COOKIES: "rgpdCookies"
  // TODO compléter
};
class Subscription {
  constructor(e, t) {
    o(this, "revoke");
    this._channel = e, this.revoke = this.setReceiver(
      (s) => t == null ? void 0 : t(s.data)
    );
  }
  setReceiver(e) {
    var t;
    return (t = this._channel) == null || t.addEventListener("message", e), () => {
      this._channel && (this._channel.removeEventListener("message", e), this._channel.close(), delete this._channel);
    };
  }
}
class Subject {
  constructor() {
    /* A single BroadcastChannel cannot send AND receive messages, afaik.
     * => We maintain here channels for *sending* messages.
     * *Receiving* channels will be instantiated while subscribing.
     */
    o(this, "publishChannels", /* @__PURE__ */ new Map());
  }
  getChannelName(e) {
    return "Subject:" + e;
  }
  getPublishChannel(e) {
    const t = this.getChannelName(e);
    let s = this.publishChannels.get(t);
    return s || (s = this.newChannel(e), this.publishChannels.set(t, s)), s;
  }
  newChannel(e) {
    const t = this.getChannelName(e), s = new BroadcastChannel(t);
    return s.addEventListener("messageerror", (r) => console.log(r.data)), s;
  }
  publish(e, t) {
    typeof e == "string" && this.getPublishChannel(e).postMessage(t);
  }
  subscribe(e, t) {
    if (typeof e == "string") {
      const s = this.newChannel(e);
      return new Subscription(s, t);
    } else
      return new Subscription();
  }
}
const ASYNC_DATA_NAME = {
  SESSION_READY: "sessionReady",
  LANG_READY: "langReady",
  SKIN_READY: "skinReady",
  OVERRIDE_READY: "overrideReady",
  APPCONF_READY: "appConfReady"
};
class Promisified {
  constructor() {
    //-------------------------------------
    o(this, "_resolution");
    o(this, "_rejection");
    o(this, "_promise", new Promise((e, t) => {
      this._resolution = e, this._rejection = t;
    }));
  }
  get promise() {
    return this._promise;
  }
  resolve(e) {
    this._resolution && this._resolution(e);
  }
  reject(e) {
    this._rejection && this._rejection(e);
  }
}
class NotifyFramework {
  constructor() {
    //-------------------------------------
    o(this, "promises", {});
    o(this, "subject", new Subject());
  }
  asyncData(e) {
    return typeof this.promises[e] > "u" && (this.promises[e] = new Promisified()), this.promises[e];
  }
  onSessionReady() {
    return this.asyncData(ASYNC_DATA_NAME.SESSION_READY);
  }
  onLangReady() {
    return this.asyncData(ASYNC_DATA_NAME.LANG_READY);
  }
  onSkinReady() {
    return this.asyncData(ASYNC_DATA_NAME.SKIN_READY);
  }
  onOverridesReady() {
    return this.asyncData(ASYNC_DATA_NAME.OVERRIDE_READY);
  }
  onAppConfReady() {
    return this.asyncData(ASYNC_DATA_NAME.APPCONF_READY);
  }
  promisify() {
    return new Promisified();
  }
  events() {
    return this.subject;
  }
}
const notify = new NotifyFramework(), loadedScripts$1 = {};
class Http {
  constructor(e) {
    // Axios automatically manages the XSRF-TOKEN cookie and the X-XSRF-TOKEN HTTP header.
    o(this, "axios");
    o(this, "_latestResponse");
    this.axios = axios.create(e);
  }
  setCdn(e) {
    e && XMLHttpRequest && !XMLHttpRequest.prototype.cdnUrl && (XMLHttpRequest.prototype.cdnUrl = e, XMLHttpRequest.prototype.baseOpen = XMLHttpRequest.prototype.open, XMLHttpRequest.prototype.open = function() {
      const t = arguments[1];
      return t.startsWith("/infra/public") && (arguments[1] = e + t), /^\/([^\/]*)\/public/.test(t) && (arguments[1] = e + t), t.startsWith("/assets") && (arguments[1] = e + t), t == "/conf/public" && (arguments[1] = t), t.startsWith("http") && (arguments[1] = t), this.baseOpen.apply(this, arguments);
    });
  }
  // private toAxiosConfig(params?: IHttpParams): AxiosRequestConfig {
  toAxiosConfig(e) {
    if (e) {
      const t = Object.assign({}, this.axios.defaults);
      return e.headers && (t.headers && (t.headers = Object.assign({}, this.axios.defaults.headers)), Object.assign(t.headers, e.headers)), e.responseType && (t.responseType = e.responseType), e.queryParams && (t.params = Object.assign({}, e.queryParams)), t;
    } else
      return this.axios.defaults;
  }
  toCdnUrl(e) {
    const t = ConfigurationFrameworkFactory.instance().Platform.cdnDomain;
    if ((t == null ? void 0 : t.length) > 0 && e !== "/conf/public") {
      const s = "" + e;
      (s.startsWith("/infra/public") || s.startsWith("/assets") || /^\/([^\/]*)\/public/.test(s)) && (e = t + s);
    }
    return e;
  }
  mapAxiosError(e, t) {
    return e.response ? this._latestResponse = e.response : e.request ? this._latestResponse = {
      status: 408,
      statusText: ERROR_CODE.TIME_OUT
    } : this._latestResponse = {
      status: 500,
      statusText: ERROR_CODE.UNKNOWN
    }, !t || t.disableNotifications, this._latestResponse;
  }
  mapAxiosResponse(e, t) {
    return this._latestResponse = e, e.data;
  }
  get latestResponse() {
    return this._latestResponse;
  }
  isResponseError() {
    return this.latestResponse.status < 200 || this.latestResponse.status >= 300;
  }
  get(e, t) {
    return this.axios.get(this.toCdnUrl(e), this.toAxiosConfig(t)).then((s) => this.mapAxiosResponse(s, t)).catch((s) => this.mapAxiosError(s, t));
  }
  post(e, t, s) {
    return this.axios.post(e, t, this.toAxiosConfig(s)).then((r) => this.mapAxiosResponse(r, s)).catch((r) => this.mapAxiosError(r, s));
  }
  postFile(e, t, s) {
    const r = this.toAxiosConfig(s);
    return r.headers && r.headers["Content-Type"] && delete r.headers["Content-Type"], this.axios.post(e, t, r).then((i) => this.mapAxiosResponse(i, s)).catch((i) => this.mapAxiosError(i, s));
  }
  postJson(e, t, s) {
    const r = this.toAxiosConfig();
    return r.headers && (r.headers["Content-Type"] = "application/json"), this.axios.post(e, t, this.toAxiosConfig(s)).then((i) => this.mapAxiosResponse(i, s)).catch((i) => this.mapAxiosError(i, s));
  }
  put(e, t, s) {
    return this.axios.put(e, t, this.toAxiosConfig(s)).then((r) => this.mapAxiosResponse(r, s)).catch((r) => this.mapAxiosError(r, s));
  }
  /*
      putFile(url: string, data:FormData, opt?:any) {
          //TODO
          return this.axios.putFile(url, data, opt).then( r => this.mapAxiosResponse(r,params));
      }
  */
  putJson(e, t, s) {
    const r = this.toAxiosConfig(s);
    return r.headers && (r.headers["Content-Type"] = "application/json"), this.axios.put(e, t, r).then((i) => this.mapAxiosResponse(i, s)).catch((i) => this.mapAxiosError(i, s));
  }
  delete(e, t) {
    return this.axios.delete(e, this.toAxiosConfig(t)).then((s) => this.mapAxiosResponse(s, t)).catch((s) => this.mapAxiosError(s, t));
  }
  deleteJson(e, t) {
    return this.axios.delete(e, { data: t }).then((s) => this.mapAxiosResponse(s)).catch((s) => this.mapAxiosError(s));
  }
  getScript(e, t, s) {
    const r = s ?? "exports", i = this.toAxiosConfig(t);
    return i.headers && (i.headers.Accept = "application/javascript"), this.axios.get(this.toCdnUrl(e), i).then((n) => this.mapAxiosResponse(n, t)).then((n) => {
      try {
        const a = `"use strict";var ${r.split(".")[0]}={};${n};return ${r};`;
        return Function(a)();
      } catch {
        return n;
      }
    }).catch((n) => {
      throw this.mapAxiosError(n, t), n;
    });
  }
  loadScript(e, t) {
    return loadedScripts$1[e] ? Promise.resolve() : this.getScript(e, t).then((s) => {
      loadedScripts$1[e] = !0;
    });
  }
}
class TransportFramework {
  constructor() {
    o(this, "_http", new Http());
  }
  get http() {
    return this._http;
  }
  newHttpInstance(e) {
    return new Http(e);
  }
}
const transport = new TransportFramework();
class ConfigurationFrameworkFactory {
  //-------------------------------------
  static instance() {
    return configure;
  }
}
const http$2 = transport.http;
class Session {
  constructor() {
    o(this, "_me", null);
    o(this, "_currentLanguage", "");
    o(this, "_notLoggedIn", !0);
    o(this, "_description");
    o(this, "_profile");
  }
  get currentLanguage() {
    return this._currentLanguage;
  }
  get notLoggedIn() {
    return this._notLoggedIn;
  }
  get description() {
    return this._description;
  }
  get avatarUrl() {
    let e = this.description.photo;
    return (!e || e === "no-avatar.jpg" || e === "no-avatar.svg") && (e = ConfigurationFrameworkFactory.instance().Platform.theme.basePath + "/img/illustrations/no-avatar.svg"), e;
  }
  get user() {
    return this._me;
  }
  get currentApp() {
    return configure.Platform.apps.currentApp;
  }
  async initialize() {
    return http$2.get("/auth/oauth2/userinfo").then((e) => {
      if (http$2.isResponseError() || typeof e == "string")
        throw ERROR_CODE.NOT_LOGGED_IN;
      return this.setCurrentModel(e), this._notLoggedIn ? this.loadDefaultLanguage() : this.loadUserLanguage();
    }).then((e) => (this.setCurrentLanguage(e), this.loadDescription())).then(() => this.getUserProfile()).then(() => {
      notify.onSessionReady().resolve(this._me);
    }).catch((e) => {
      if (e === ERROR_CODE.NOT_LOGGED_IN)
        return Promise.resolve();
      notify.onSessionReady().reject(e);
    });
  }
  setCurrentModel(e) {
    this._me = e, this._notLoggedIn = !(e && e.sessionMetadata && e.sessionMetadata.userId);
  }
  ////////////////////////////////////////////////////////// Rights management
  hasWorkflow(e) {
    var t;
    return e === void 0 || ((t = this._me) == null ? void 0 : t.authorizedActions.findIndex((s) => s.name === e)) !== -1;
  }
  hasRight(e, t) {
    if (t === "owner")
      return e.owner && e.owner.userId === this._me.userId;
    const s = t.right || t, i = e.shared.filter((a) => (this._me.groupsIds || []).indexOf(a.groupId) !== -1 || a.userId === this._me.userId).find((a) => a[s] || a.manager) !== void 0, n = t.workflow ? this.hasWorkflow(t.workflow) : !0;
    return i && n;
  }
  ////////////////////////////////////////////////////////// Storage management
  get latestQuotaAndUsage() {
    return http$2.get(`/workspace/quota/user/${this._me.userId}`).then((e) => (this._description && (this._description.quota = e.quota, this._description.storage = e.storage), e)).catch(() => ({ quota: 0, storage: 0 }));
  }
  ////////////////////////////////////////////////////////// Language management
  setCurrentLanguage(e) {
    this._currentLanguage = e, notify.onLangReady().resolve(e);
  }
  loadDefaultLanguage() {
    return http$2.get("/locale").then((e) => e.locale).catch(() => this._currentLanguage);
  }
  ////////////////////////////////////////////////////////// Description management
  loadDescription() {
    return Promise.all([
      // FIXME The full user's description should be obtainable from a single endpoint in the backend.
      http$2.get("/userbook/api/person", {
        requestName: "refreshAvatar"
      }),
      http$2.get("/directory/userbook/" + this._me.userId)
    ]).then((e) => (e[0].status === "ok" && e[0].result && e[0].result.length > 0 ? this._description = e[0].result[0] : this._description = {}, this._description.type && !this._description.profiles && (this._description.profiles = this._description.type), Object.assign(this._description, e[1]), this._description));
  }
  get profile() {
    return this._profile;
  }
  getUserProfile() {
    return http$2.get("/userbook/api/person").then((e) => e.result).then((e) => this._profile = e[0].type);
  }
  loadUserLanguage() {
    return http$2.get("/userbook/preference/language").then((e) => {
      try {
        return JSON.parse(e.preference)["default-domain"];
      } catch {
        return this.loadDefaultLanguage();
      }
    }).catch(() => this.loadDefaultLanguage());
  }
  ////////////////////////////////////////////////////////// Email management
  getEmailValidationInfos() {
    return http$2.get("/directory/user/mailstate");
  }
  checkEmail(e) {
    return http$2.put("/directory/user/mailstate", { email: e });
  }
  tryEmailValidation(e) {
    return http$2.post("/directory/user/mailstate", {
      key: e
    });
  }
  ////////////////////////////////////////////////////////// Mobile management
  getMobileValidationInfos() {
    return http$2.get("/directory/user/mobilestate");
  }
  checkMobile(e) {
    return http$2.put("/directory/user/mobilestate", { mobile: e });
  }
  tryMobileValidation(e) {
    return http$2.post("/directory/user/mobilestate", {
      key: e
    });
  }
  ////////////////////////////////////////////////////////// MFA management
  getMfaInfos() {
    return http$2.get("/auth/user/mfa/code");
  }
  tryMfaCode(e) {
    return http$2.post("/auth/user/mfa/code", { key: e });
  }
}
class SessionFramework {
  constructor() {
    o(this, "session", new Session());
  }
  initialize() {
    return this.session.initialize();
  }
  login(e, t, s, r) {
    const i = new FormData();
    return i.append("email", e), i.append("password", t), typeof s < "u" && i.append("rememberMe", "" + s), typeof r < "u" && i.append("secureLocation", "" + r), transport.http.post("/auth/login", i, {
      headers: { "content-type": "application/x-www-form-urlencoded" }
    }).finally(() => {
      switch (transport.http.latestResponse.status) {
        case 200:
          throw ERROR_CODE.MALFORMED_DATA;
      }
    });
  }
  logout() {
    return transport.http.get("/auth/logout").finally(() => {
    });
  }
}
const session = new SessionFramework();
class Theme {
  constructor() {
    o(this, "_conf");
    o(this, "_loaded");
    // legacy (readonly)
    o(this, "skinName", "");
    o(this, "themeName", "");
    o(this, "skin", "raw");
    o(this, "themeUrl", "/assets/themes/raw/default/");
    o(this, "templateOverrides", {});
    o(this, "portalTemplate", "/assets/themes/raw/portal.html");
    o(this, "basePath", "");
    o(this, "logoutCallback", "/");
    o(this, "skins", []);
    o(this, "is1D", !1);
    o(this, "is2D", !1);
    o(this, "_onSkinReady", notify.onSkinReady());
    o(this, "_onOverrideReady", notify.onOverridesReady());
  }
  initialize(e) {
    return notify.onSessionReady().promise.then(() => this.load(e));
  }
  get version() {
    return configure.Platform.deploymentTag;
  }
  get cdnDomain() {
    return configure.Platform.cdnDomain;
  }
  async onFullyReady() {
    return await this._loaded, this;
  }
  onSkinReady() {
    return this._onSkinReady.promise;
  }
  onOverrideReady() {
    return this._onOverrideReady.promise;
  }
  async getConf(e) {
    return this._conf = this._conf ?? await transport.http.getScript(
      "/assets/theme-conf.js",
      { queryParams: { v: e ?? this.version } },
      "exports.conf"
    ), this._conf;
  }
  load(e) {
    return e = e ?? this.version, this._loaded || (this._loaded = (session.session.notLoggedIn ? this.loadDisconnected(e) : this.loadConnected(e)).then(async () => {
      var s, r;
      const t = await this.listSkins();
      this.is1D = ((s = t.find((i) => i.child === this.skin)) == null ? void 0 : s.parent) === "panda", this.is2D = ((r = t.find((i) => i.child === this.skin)) == null ? void 0 : r.parent) === "theme-open-ent";
    })), this._loaded;
  }
  loadDisconnected(e) {
    return new Promise((t, s) => {
      transport.http.get("/skin", { queryParams: { v: this.version } }).then((r) => {
        this.skin = r.skin, this.themeUrl = `${this.cdnDomain}/assets/themes/${r.skin}/skins/default/`, this.basePath = this.themeUrl + "../../", this._onSkinReady.resolve(this), transport.http.get(`/assets/themes/${r.skin}/template/override.json`, {
          disableNotifications: !0,
          queryParams: { v: e }
        }).then((i) => {
          this.templateOverrides = i, this._onOverrideReady.resolve(i), t();
        }).catch((i) => {
          if (transport.http.latestResponse.status === 404)
            t();
          else
            throw i;
        });
      }).catch((r) => {
        this._onSkinReady.reject(r), this._onOverrideReady.reject(r), s();
      });
    });
  }
  loadConnected(e) {
    return new Promise((t, s) => {
      this.loadDefaultTheme(e).then(() => {
        this._onSkinReady.resolve(this), transport.http.get(`/assets/themes/${this.skin}/template/override.json`, {
          disableNotifications: !0,
          queryParams: { v: e }
        }).then((r) => {
          this.templateOverrides = r, this._onOverrideReady.resolve(r), t();
        }).catch((r) => {
          if (transport.http.latestResponse.status === 404)
            t(), this._onSkinReady.reject(r), this._onOverrideReady.reject(r);
          else
            throw r;
        });
      });
    });
  }
  /** Load the user's configured theme. */
  async loadDefaultTheme(e) {
    return session.session.notLoggedIn ? Promise.reject() : transport.http.get("/theme", { queryParams: { _: e } }).then((t) => {
      this.skinName = t.skinName, this.themeName = t.themeName, this.themeUrl = t.skin, this.basePath = `${this.cdnDomain}${this.themeUrl}../../`, this.skin = this.themeUrl.split("/assets/themes/")[1].split("/")[0], this.portalTemplate = `${this.cdnDomain}/assets/themes/${this.skin}/portal.html`, this.logoutCallback = t.logoutCallback;
    });
  }
  listThemes() {
    return transport.http.get("/themes");
  }
  async setDefaultTheme(e) {
    await transport.http.get(
      "/userbook/api/edit-userbook-info?prop=theme-" + this.skin + "&value=" + e._id
    ), await this.loadDefaultTheme(this.version);
  }
  listSkins() {
    return this.skins.length > 0 ? Promise.resolve(this.skins) : this.getConf().then((e) => {
      const t = e.overriding.find(
        (s) => s.child === this.skin
      );
      return t != null && t.group ? this.skins = this.skins.concat(
        e.overriding.filter((s) => s.group === t.group)
      ) : this.skins = this.skins.concat(e.overriding), this.skins;
    });
  }
  async getHelpPath() {
    const t = (await this.listSkins()).find((s) => s.child === this.skin);
    return (t == null ? void 0 : t.help) ?? "/help";
  }
}
const bundle$1 = {}, promises$1 = {}, defaultDiacriticsRemovalMap$1 = [
  {
    base: "A",
    letters: /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
  },
  { base: "AA", letters: /[\uA732]/g },
  { base: "AE", letters: /[\u00C6\u01FC\u01E2]/g },
  { base: "AO", letters: /[\uA734]/g },
  { base: "AU", letters: /[\uA736]/g },
  { base: "AV", letters: /[\uA738\uA73A]/g },
  { base: "AY", letters: /[\uA73C]/g },
  {
    base: "B",
    letters: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
  },
  {
    base: "C",
    letters: /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
  },
  {
    base: "D",
    letters: /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
  },
  { base: "DZ", letters: /[\u01F1\u01C4]/g },
  { base: "Dz", letters: /[\u01F2\u01C5]/g },
  {
    base: "E",
    letters: /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
  },
  { base: "F", letters: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g },
  {
    base: "G",
    letters: /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
  },
  {
    base: "H",
    letters: /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
  },
  {
    base: "I",
    letters: /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
  },
  { base: "J", letters: /[\u004A\u24BF\uFF2A\u0134\u0248]/g },
  {
    base: "K",
    letters: /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
  },
  {
    base: "L",
    letters: /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
  },
  { base: "LJ", letters: /[\u01C7]/g },
  { base: "Lj", letters: /[\u01C8]/g },
  { base: "M", letters: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g },
  {
    base: "N",
    letters: /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
  },
  { base: "NJ", letters: /[\u01CA]/g },
  { base: "Nj", letters: /[\u01CB]/g },
  {
    base: "O",
    letters: /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
  },
  { base: "OI", letters: /[\u01A2]/g },
  { base: "OO", letters: /[\uA74E]/g },
  { base: "OU", letters: /[\u0222]/g },
  {
    base: "P",
    letters: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
  },
  { base: "Q", letters: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g },
  {
    base: "R",
    letters: /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
  },
  {
    base: "S",
    letters: /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
  },
  {
    base: "T",
    letters: /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
  },
  { base: "TZ", letters: /[\uA728]/g },
  {
    base: "U",
    letters: /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
  },
  { base: "V", letters: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g },
  { base: "VY", letters: /[\uA760]/g },
  {
    base: "W",
    letters: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
  },
  { base: "X", letters: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g },
  {
    base: "Y",
    letters: /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
  },
  {
    base: "Z",
    letters: /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
  },
  {
    base: "a",
    letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
  },
  { base: "aa", letters: /[\uA733]/g },
  { base: "ae", letters: /[\u00E6\u01FD\u01E3]/g },
  { base: "ao", letters: /[\uA735]/g },
  { base: "au", letters: /[\uA737]/g },
  { base: "av", letters: /[\uA739\uA73B]/g },
  { base: "ay", letters: /[\uA73D]/g },
  {
    base: "b",
    letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
  },
  {
    base: "c",
    letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
  },
  {
    base: "d",
    letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
  },
  { base: "dz", letters: /[\u01F3\u01C6]/g },
  {
    base: "e",
    letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
  },
  { base: "f", letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g },
  {
    base: "g",
    letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
  },
  {
    base: "h",
    letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
  },
  { base: "hv", letters: /[\u0195]/g },
  {
    base: "i",
    letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
  },
  { base: "j", letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g },
  {
    base: "k",
    letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
  },
  {
    base: "l",
    letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
  },
  { base: "lj", letters: /[\u01C9]/g },
  { base: "m", letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g },
  {
    base: "n",
    letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
  },
  { base: "nj", letters: /[\u01CC]/g },
  {
    base: "o",
    letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
  },
  { base: "oi", letters: /[\u01A3]/g },
  { base: "ou", letters: /[\u0223]/g },
  { base: "oo", letters: /[\uA74F]/g },
  {
    base: "p",
    letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
  },
  { base: "q", letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g },
  {
    base: "r",
    letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
  },
  {
    base: "s",
    letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
  },
  {
    base: "t",
    letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
  },
  { base: "tz", letters: /[\uA729]/g },
  {
    base: "u",
    letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
  },
  { base: "v", letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g },
  { base: "vy", letters: /[\uA761]/g },
  {
    base: "w",
    letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
  },
  { base: "x", letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g },
  {
    base: "y",
    letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
  },
  {
    base: "z",
    letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
  }
];
class Idiom {
  translate(e, t) {
    e = e ?? "";
    let s = bundle$1[e] === void 0 ? e : bundle$1[e];
    if (t && typeof t == "object")
      for (const r in t)
        typeof t[r] < "u" && (s = s.replace(
          new RegExp("\\${" + r + "}", "g"),
          "" + t[r]
        ));
    return s;
  }
  addBundlePromise(e) {
    return this.loadBundlePromise(session.session.currentLanguage, e);
  }
  addBundle(e, t) {
    this.loadBundle(session.session.currentLanguage, e, t);
  }
  loadBundlePromise(e, t) {
    return this.loadBundle(e, t), promises$1[t];
  }
  loadBundle(e, t, s) {
    const r = promises$1[t];
    if (r)
      s && r.then(s).catch(s);
    else {
      const i = new Promisified();
      promises$1[t] = i.promise;
      const n = {};
      e && (n["Accept-Language"] = e), transport.http.get(t, { headers: n }).then((a) => {
        Object.assign(bundle$1, a), typeof s == "function" && s(), i.resolve();
      }).catch((a) => {
        typeof s == "function" && s(), i.reject();
      });
    }
  }
  addTranslations(e, t) {
    notify.onLangReady().promise.then((s) => {
      this.loadBundle(s, e + "/" + s + ".json", t);
    });
  }
  addAllTranslations(e) {
    return e && e.length > 0 ? notify.onLangReady().promise.then(
      (t) => Promise.all(
        e.map(
          (s) => this.loadBundlePromise(t, s + "/" + t + ".json")
        )
      )
    ).then(() => {
    }) : Promise.reject();
  }
  addKeys(e) {
    for (const t in e)
      typeof bundle$1[t] != "string" && (bundle$1[t] = e[t]);
  }
  removeAccents(e) {
    for (let t = 0; t < defaultDiacriticsRemovalMap$1.length; t++)
      e = e.replace(
        defaultDiacriticsRemovalMap$1[t].letters,
        defaultDiacriticsRemovalMap$1[t].base
      );
    return e;
  }
}
class UserPreferences {
  constructor() {
    //-------------------------------------
    o(this, "data", {});
  }
  get(e) {
    return this.data[e];
  }
  load(e, t) {
    return transport.http.get("/userbook/preference/" + e).then((s) => {
      try {
        return JSON.parse(s.preference);
      } catch {
        return t ?? {};
      }
    }).then((s) => (this.data[e] = s ?? {}, s));
  }
  update(e, t) {
    return t !== void 0 && (this.data[e] = t), this;
  }
  save(e) {
    return transport.http.putJson(
      "/userbook/preference/" + e,
      this.data[e]
    );
  }
}
class User {
  constructor() {
    //-------------------------------------
    o(this, "_me", null);
    o(this, "_keepOpenOnLogout", !1);
    o(this, "_preferences", new UserPreferences());
    o(this, "_bookmarkedApps", []);
  }
  get keepOpenOnLogout() {
    return this._keepOpenOnLogout;
  }
  get preferences() {
    return this._preferences;
  }
  get bookmarkedApps() {
    return this._bookmarkedApps;
  }
  initialize(e) {
    return this.loadPublicConf(), notify.onSessionReady().promise.then((t) => {
      t && this.setCurrentModel(t);
    });
  }
  setCurrentModel(e) {
    this._me = e, this._preferences = new UserPreferences(), this.loadBookmarks();
  }
  loadPublicConf() {
    return transport.http.get("/conf/public").then((e) => (this._keepOpenOnLogout = (e == null ? void 0 : e.keepOpenOnLogout) || !1, e));
  }
  /** Bookmarks : pinned apps */
  async loadBookmarks() {
    await transport.http.get("/userbook/preference/apps").then((e) => {
      e.preference || (e.preference = null);
      const t = JSON.parse(
        e.preference
      );
      let s;
      if (t && t.length && typeof t.concat == "function") {
        this._bookmarkedApps = t, s = {
          bookmarks: t.map((n) => n.name),
          applications: []
        }, transport.http.putJson("/userbook/preference/apps", s);
        return;
      } else
        s = t;
      s || (s = {
        bookmarks: [],
        applications: []
      });
      let r = !0;
      const i = [];
      s.bookmarks.forEach((n, a) => {
        const c = this._me.apps.find((h) => h.name === n);
        if (c) {
          const h = Object.assign({}, c);
          this._bookmarkedApps.push(h);
        } else
          i.push(n), r = !1;
      }), i.forEach((n) => {
        const a = s.bookmarks.indexOf(n);
        a !== -1 && s.bookmarks.splice(a, 1);
      }), r || transport.http.putJson("/userbook/preference/apps", s);
    });
  }
  loadAppPrefs(e) {
    return this.preferences.load(e, {});
  }
  saveAppPrefs(e) {
    return this.preferences.save(e);
  }
  loadLanguage() {
    return this.preferences.load("language", { "default-domain": session.session.currentLanguage }).then((e) => e["default-domain"]);
  }
  saveLanguage(e) {
    return this.preferences.update("language", { "default-domain": e }).save("language");
  }
}
const http$1 = transport == null ? void 0 : transport.http;
class AppConf {
  constructor() {
    //-------------------------------------
    o(this, "_publicConf", {});
    o(this, "_currentApp");
    o(this, "_appConf", {});
  }
  /**
   * Get the currently initialized App.
   * @see getter SessionFramework.currentApp
   */
  get currentApp() {
    return this._currentApp ?? null;
  }
  setCurrentApp(e) {
    return this._currentApp = e, this;
  }
  async initialize(e, t = !1) {
    t || this.setCurrentApp(e), await Promise.all([this.getPublicConf(e), this.loadI18n(e)]);
  }
  async getPublicConf(e) {
    return this._publicConf[e] || (this._publicConf[e] = await http$1.get(`/${e}/conf/public`, {
      queryParams: { _: configure.Platform.deploymentTag }
    })), this._publicConf[e];
  }
  async getWebAppConf(e) {
    let t;
    return this._appConf[e] || (await http$1.get(
      "/applications-list"
    )).apps.forEach((r) => {
      if (r != null && r.prefix) {
        const i = r.prefix.replace("/", "");
        this._appConf[i] = r;
      } else r != null && r.name && r.name.toLowerCase() == e && (t = r);
    }), this._appConf[e] ?? t;
  }
  async loadI18n(e) {
    return await notify.onLangReady().promise, configure.Platform.idiom.addBundlePromise(`/${e}/i18n`);
  }
}
class Analytics {
  constructor() {
    //-------------------------------------
    o(this, "_status", "void");
    o(this, "_params");
  }
  get status() {
    return this._status;
  }
  xiti() {
    return this.parametersWithCheck("xiti", !1);
  }
  parameters(e) {
    return this.parametersWithCheck(e, !0);
  }
  async parametersWithCheck(e, t) {
    return this.initialize().promise.then((s) => !t || s.type === e || s.type === "multiple" ? s[e] : void 0);
  }
  /**
   * This method loads the conf and waits for the user session to start.
   * It can be called ASAP, but it will be automatically called if needed.
   * @returns A promise of the end of the init process (it may throw errors)
   * @throws ERROR_CODE.MALFORMED_DATA when config cannot be read.
   */
  initialize() {
    return this._params || (this._params = notify.promisify(), this._status = "pending", Promise.all([
      transport.http.get("/analyticsConf"),
      //FIXME change servers config to only keep the "all-in-one" query to /analyticsConf.
      transport.http.get("/xiti/config")
    ]).then(async (e) => {
      var t;
      if (!e || !e[0] || !e[0].type)
        throw ERROR_CODE.MALFORMED_DATA;
      e[1] && e[1].active && (e[0].xiti = await this.initializeXiti(e[1])), (t = this._params) == null || t.resolve(e[0]), this._status = "ready";
    }).catch((e) => {
      var t;
      throw this._status = "failed", (t = this._params) == null || t.reject(), e;
    })), this._params;
  }
  /** 2021 implementation of XiTi. */
  async initializeXiti(e) {
    if (!e.structureMap || !configure.Platform.apps.currentApp) return;
    const t = await notify.onSessionReady().promise, s = session.session.description;
    let r;
    for (const h of t.structures) {
      const l = e.structureMap[h];
      if (l && l.collectiviteId && l.UAI) {
        r = l;
        break;
      }
    }
    if (!r || !r.active) return;
    const i = await configure.Platform.apps.getPublicConf(
      configure.Platform.apps.currentApp
    );
    if (!i) return;
    const n = i.xiti;
    if (!n || !n.LIBELLE_SERVICE || !r.UAI) return;
    function a(h) {
      let l = "";
      for (let E = 0; E < h.length; E++)
        l += h.charCodeAt(E);
      return l;
    }
    const c = {
      Student: "ELEVE",
      Teacher: "ENSEIGNANT",
      Relative: "PARENT",
      Personnel: "ADMIN_VIE_SCOL_TECH",
      Guest: "AUTRE"
    };
    return {
      LIBELLE_SERVICE: n.LIBELLE_SERVICE,
      // Which property of LIBELLE_SERVICE to use depends on the frontend.
      TYPE: n.OUTIL ? "TIERS" : "NATIF",
      OUTIL: n.OUTIL ? n.OUTIL : "",
      STRUCT_ID: r.collectiviteId,
      STRUCT_UAI: r.UAI,
      PROJET: r.projetId ? r.projetId : e.ID_PROJET,
      EXPLOITANT: e.ID_EXPLOITANT,
      PLATFORME: r.plateformeId ? r.plateformeId : e.ID_PLATEFORME,
      ID_PERSO: a(t.userId),
      PROFILE: s.profiles && s.profiles.length > 0 ? c[s.profiles[0]] ?? "" : ""
    };
  }
}
class ConfigurationFramework {
  constructor() {
    //-------------------------------------
    o(this, "Platform", {
      deploymentTag: "",
      cdnDomain: "",
      apps: new AppConf(),
      theme: new Theme(),
      analytics: new Analytics(),
      idiom: new Idiom(),
      listLanguages: () => transport.http.get("/languages")
    });
    o(this, "School", {
      //apps; -> pinnedApps;
    });
    o(this, "User", new User());
  }
  async initialize(e, t) {
    if (!e) {
      const r = (h) => (h < 10 ? "0" : "") + h.toFixed(0), i = /* @__PURE__ */ new Date(), n = i.getFullYear(), a = i.getMonth() + 1, c = i.getDate();
      e = `${n}${r(a)}${r(c)}`;
    }
    const s = e;
    this.Platform.deploymentTag = e, typeof t == "string" && t.length > 0 && (this.Platform.cdnDomain = t), transport.http.setCdn(this.Platform.cdnDomain), await Promise.all([
      this.Platform.theme.initialize(s),
      notify.onSessionReady().promise.then(
        (r) => this.Platform.idiom.addBundlePromise("/i18n")
      ),
      //TODO this.School.initialize( v ),
      this.User.initialize(s)
    ]);
  }
  // async mount(
  //   version?: string | null,
  //   cdnDomain?: string | null,
  // ): Promise<void> {
  //   // If version is undefined, default to a new tag every day.
  //   if (!version) {
  //     const padWith0 = (val: number): string =>
  //       (val < 10 ? "0" : "") + val.toFixed(0);
  //     const now = new Date();
  //     const y = now.getFullYear();
  //     const m = now.getMonth() + 1;
  //     const d = now.getDate();
  //     version = `${y}${padWith0(m)}${padWith0(d)}`; //FIXME add ${h.toFixed(0)} to change the tag every 10 minutes
  //   }
  //   const v = version;
  //   this.Platform.deploymentTag = version;
  //   // Don't overwrite the CDN domain with a null or empty value.
  //   if (typeof cdnDomain === "string" && cdnDomain.length > 0) {
  //     this.Platform.cdnDomain = cdnDomain;
  //   }
  //   transport.http.setCdn(this.Platform.cdnDomain);
  //   //
  //   await this.Platform.idiom.addBundlePromise("/i18n");
  // }
}
const configure = new ConfigurationFramework(), http = transport == null ? void 0 : transport.http;
var _;
const me = (_ = session == null ? void 0 : session.session) == null ? void 0 : _.user;
class Notification {
  constructor(e) {
    o(this, "_id");
    o(this, "model");
    e.reported = e.reporters && e.reporters.length > 0, this._id = e._id, this.model = e;
  }
  isUnread() {
    var e;
    return ((e = this.model.recipients) == null ? void 0 : e.find((t) => t.userId === me.userId)) !== void 0;
  }
  delete() {
    return http.delete("/timeline/" + this._id);
  }
  discard() {
    return http.put("/timeline/" + this._id);
  }
  report() {
    return http.put("/timeline/" + this._id + "/report");
  }
}
class TimelineApp {
  constructor() {
    //-------------------------------------
    o(this, "_notifications", []);
    o(this, "_notificationTypes", []);
    // ex: ["BLOG"]
    o(this, "_flashMessages", []);
    o(this, "_pageNumber", 0);
    o(this, "_lastPage", !1);
    o(this, "_loading", !1);
    o(this, "showMine", !1);
  }
  get notifications() {
    return this._notifications;
  }
  get isLoading() {
    return this._loading;
  }
  get page() {
    return this._pageNumber;
  }
  get hasMorePage() {
    return !this._lastPage;
  }
  get notificationTypes() {
    return this._notificationTypes;
  }
  get selectedNotificationTypes() {
    return this.preferences.type = this.preferences.type || [], this.preferences.type;
  }
  get preferences() {
    return configure.User.preferences.get(APP$3.TIMELINE);
  }
  get flashMessages() {
    return this._flashMessages;
  }
  savePreferences() {
    return configure.User.saveAppPrefs(APP$3.TIMELINE);
  }
  resetPagination() {
    this._pageNumber = 0, this._lastPage = !1, this._loading = !1;
  }
  initialize() {
    return Promise.all([
      configure.User.loadAppPrefs(APP$3.TIMELINE),
      transport.http.get("/timeline/types")
    ]).then((e) => {
      this._notificationTypes = e[1];
    });
  }
  loadNotifications(e) {
    if (this._loading || this._lastPage)
      return Promise.resolve();
    e && (this._pageNumber++, this._lastPage = !1);
    const t = this.selectedNotificationTypes;
    if (t.length === 0)
      return this._lastPage = !0, Promise.resolve();
    const s = {
      page: this.page,
      mine: 1
    };
    return this.showMine || delete s.mine, this._loading = !0, transport.http.get(`/timeline/lastNotifications?type=${t.join("&type=")}`, {
      queryParams: s
    }).then(
      (r) => {
        if (this._loading = !1, r.status === "ok")
          if (r.number && r.results) {
            const i = r.results.filter(
              (n) => this._notifications.findIndex(
                (a) => a._id === n._id
              ) === -1
            ).map((n) => new Notification(n));
            this._notifications = this._notifications.concat(i), this._pageNumber++;
          } else
            this._lastPage = !0;
      }
    ).catch((r) => {
      this._loading = !1;
    });
  }
  loadFlashMessages() {
    return transport.http.get("/timeline/flashmsg/listuser").then((e) => {
      this._flashMessages = e;
    });
  }
  markAsRead(e) {
    return transport.http.put("/timeline/flashmsg/" + e.id + "/markasread");
  }
}
class ITimelineFactory {
  //-------------------------------------
  static createInstance() {
    return new TimelineApp();
  }
}
const ReactionTypes = [
  "REACTION_1",
  "REACTION_2",
  "REACTION_3",
  "REACTION_4"
];
class NotifyFrameworkFactory {
  static instance() {
    return notify;
  }
}
const LAYER_NAME = {
  WIDGETS: "widgets",
  EXPLORER: "explorer",
  TRANSPORT: "transport",
  WEB_DATA: "webDataPipeline"
}, EVENT_NAME = {
  USERPREF_CHANGED: "userprefChanged",
  SEARCH_RESULTED: "searchResulted",
  ERROR_OCCURED: "error",
  DATA_TRACKED: "track"
};
class ServiceRegistry extends Map {
  /** Register a service */
  register({
    application: e,
    resourceType: t
  }, s) {
    this.set(`${e}:main`, s), this.set(`${e}:${t}`, s);
  }
  /** Lookup for a service */
  findService(e, t) {
    return this.lookupService(e, t);
  }
  /** Lookup for a main service */
  findMainService({ application: e }, t) {
    return this.lookupService({ application: e, resourceType: "main" }, t);
  }
  /** Check if a service is registered. */
  isRegistered({
    application: e,
    resourceType: t
  }) {
    return this.get(`${e}:${t}`) !== void 0;
  }
  /** Private lookup for a service */
  lookupService({
    application: e,
    resourceType: t
  }, s) {
    const r = this.get(`${e}:${t}`);
    if (r === void 0)
      throw `Service not found: ${e}:${t}`;
    return r(s);
  }
}
const f = class f {
  //
  // IMPLEMENTATION
  //
  constructor(e) {
    //
    // PROTECTED HELPERS
    //
    o(this, "checkHttpResponse", (e) => {
      if (this.http.latestResponse.status >= 300)
        throw this.http.latestResponse.statusText;
      return e;
    });
    this.context = e;
  }
  get http() {
    return this.context.http();
  }
  async copy(e) {
    const t = await this.http.post("/archive/duplicate", {
      application: e.application,
      resourceId: e.resourceId
    });
    return this.checkHttpResponse(t);
  }
  async publish(e) {
    const t = new FormData();
    return t.append("title", e.title), t.append("cover", e.cover), t.append("coverName", e.cover.name), t.append("coverType", e.cover.type), t.append("teacherAvatar", e.teacherAvatar), t.append(
      "teacherAvatarName",
      e.teacherAvatar.name || `teacherAvatar_${e.userId}`
    ), t.append(
      "teacherAvatarType",
      e.teacherAvatar.type
    ), t.append("language", e.language), e.activityType.forEach((i) => {
      t.append("activityType[]", i);
    }), e.subjectArea.forEach((i) => {
      t.append("subjectArea[]", i);
    }), e.age.forEach((i) => {
      t.append("age[]", i.toString());
    }), t.append("description", e.description), e.keyWords.split(",").forEach((i) => {
      t.append("keyWords[]", i.trim());
    }), t.append("licence", e.licence), t.append(
      "pdfUri",
      `${window.location.origin}${this.getPrintUrl(e.resourceEntId)}`
    ), t.append(
      "application",
      e.application ? e.application : ""
    ), t.append("resourceId", e.resourceId), t.append("teacherSchool", e.userStructureName), await this.http.post(
      "/appregistry/library/resource",
      t,
      {
        headers: { "Content-Type": "multipart/form-data" }
      }
    );
  }
  //
  // FOLDER METHODS
  //
  async createContext(e) {
    const t = await this.http.get("/explorer/context", {
      queryParams: this.toQueryParams(e)
    });
    return this.checkHttpResponse(t);
  }
  async searchContext(e) {
    const t = await this.http.get(
      "/explorer/resources",
      {
        queryParams: this.toQueryParams(e)
      }
    );
    return this.checkHttpResponse(t);
  }
  async searchResource(e) {
    const t = await this.http.get(
      `/explorer/resources/${e.id}`,
      {
        queryParams: this.getResourceParams(e)
      }
    );
    return this.checkHttpResponse(t);
  }
  async createFolder(e) {
    const t = await this.http.post(
      "/explorer/folders",
      this.createFolderToBodyParams(e)
    );
    return this.checkHttpResponse(t);
  }
  async updateFolder(e) {
    const t = await this.http.put(
      `/explorer/folders/${e.folderId}`,
      this.createFolderToBodyParams(e)
    );
    return this.checkHttpResponse(t);
  }
  async moveToFolder(e, t = !1) {
    e.resourceIds = t ? await this.mapAssetIdToIds({
      application: e.application,
      assetIds: e.resourceIds
    }) : e.resourceIds;
    const s = await this.http.post(
      `/explorer/folders/${e.folderId}/move`,
      this.moveToBodyParams(e)
    );
    return this.checkHttpResponse(s);
  }
  async listSubfolders(e) {
    const t = await this.http.get(
      `/explorer/folders/${e}`
    );
    return this.checkHttpResponse(t);
  }
  async deleteAll(e, t = !1) {
    e.resourceIds = t ? await this.mapAssetIdToIds({
      application: e.application,
      assetIds: e.resourceIds
    }) : e.resourceIds;
    const s = await this.http.deleteJson(
      "/explorer",
      e
    );
    return this.checkHttpResponse(s);
  }
  async trashAll({ resourceType: e, ...t }, s = !1) {
    t.resourceIds = s ? await this.mapAssetIdToIds({
      application: t.application,
      assetIds: t.resourceIds
    }) : t.resourceIds;
    const r = await this.http.putJson(
      "/explorer/trash",
      t
    );
    return this.checkHttpResponse(r);
  }
  /** Trash folders and/or resources. */
  async restoreAll({ resourceType: e, ...t }, s = !1) {
    t.resourceIds = s ? await this.mapAssetIdToIds({
      application: t.application,
      assetIds: t.resourceIds
    }) : t.resourceIds;
    const r = await this.http.putJson(
      "/explorer/restore",
      t
    );
    return this.checkHttpResponse(r);
  }
  async mapAssetIdToIds({
    application: e,
    assetIds: t
  }) {
    const s = await this.searchContext({
      application: e,
      pagination: { startIdx: 0, pageSize: t.length + 1 },
      types: [],
      filters: {},
      asset_id: t
    });
    return t.map((r) => {
      const i = s.resources.find(
        (n) => n.assetId === r
      );
      if (i === void 0)
        throw "explorer.assetid.notfound";
      return i.id;
    });
  }
  async getThumbnailPath(e) {
    if (typeof e > "u")
      return e;
    if (typeof e == "string")
      if (e.startsWith("blob:")) {
        const t = await fetch(e).then((r) => r.blob());
        return `/workspace/document/${(await this.context.workspace().saveFile(t, {
          visibility: "protected",
          application: this.getApplication()
        }))._id}`;
      } else
        return e;
    else
      return `/workspace/document/${(await this.context.workspace().saveFile(e, {
        visibility: "protected",
        application: this.getApplication()
      }))._id}`;
  }
  //
  // PRIVATE HELPERS
  //
  toQueryParams(e) {
    const t = {
      application: e.application,
      start_idx: e.pagination.startIdx,
      page_size: e.pagination.pageSize,
      trashed: e.trashed
    };
    if (e.types.length > 0 && (t.resource_type = e.types[0]), e.orders && Object.entries(e.orders).length) {
      const [[s, r]] = Object.entries(e.orders);
      t.order_by = `${s}:${r}`;
    }
    return e.filters && Object.assign(t, e.filters), typeof e.search == "string" && (t.search = e.search), typeof e.asset_id < "u" && (t.asset_id = [...e.asset_id]), typeof e.id < "u" && (t.id = e.id), t;
  }
  getResourceParams(e) {
    return {
      application: e.application
    };
  }
  createFolderToBodyParams(e) {
    return {
      application: e.application,
      resourceType: e.type,
      parentId: e.parentId,
      name: e.name
    };
  }
  moveToBodyParams(e) {
    return {
      application: e.application,
      resourceType: this.getResourceType(),
      resourceIds: e.resourceIds,
      folderIds: e.folderIds
    };
  }
};
//
// STATIC REGISTRY
//
o(f, "registry", new ServiceRegistry()), // Expose some useful functions
o(f, "register", f.registry.register.bind(f.registry)), o(f, "findService", f.registry.findService.bind(f.registry)), o(f, "findMainService", f.registry.findMainService.bind(f.registry)), o(f, "isRegistered", f.registry.isRegistered.bind(f.registry));
let ResourceService = f;
const APP$2 = "scrapbook", RESOURCE$2 = "scrapbook";
class ScrapbookResourceService extends ResourceService {
  create(e) {
    throw new Error("Method not implemented.");
  }
  async update(e) {
    const t = await this.getThumbnailPath(e.thumbnail), s = await this.http.put(
      `/scrapbook/${e.entId}`,
      {
        trashed: e.trashed ? 1 : 0,
        title: e.name,
        icon: t,
        subTitle: e.description
      }
    );
    return this.checkHttpResponse(s), { thumbnail: t, entId: e.entId };
  }
  getResourceType() {
    return RESOURCE$2;
  }
  getApplication() {
    return APP$2;
  }
  getFormUrl(e) {
    return e ? `/scrapbook?folderid=${e}#/create-scrapbook/` : "/scrapbook#/create-scrapbook/";
  }
  getViewUrl(e) {
    return `/scrapbook#/view-scrapbook/${e}`;
  }
  getPrintUrl(e) {
    return `/scrapbook/print#/print-scrapbook/${e}`;
  }
  getEditUrl(e) {
    return `/scrapbook#/edit-scrapbook/${e}`;
  }
  getExportUrl(e) {
    return `/scrapbook/exportHtml/${e}`;
  }
}
ResourceService.register(
  { application: RESOURCE$2, resourceType: RESOURCE$2 },
  (u) => new ScrapbookResourceService(u)
);
const APP$1 = "homeworks", RESOURCE$1 = "homeworks";
class HomeworksResourceService extends ResourceService {
  async create(e) {
    const t = await this.getThumbnailPath(e.thumbnail), s = await this.http.post("/homeworks", {
      title: e.name,
      thumbnail: t,
      description: e.description,
      repeats: e.repeats
    });
    return this.checkHttpResponse(s), { thumbnail: t, entId: s._id };
  }
  async update(e) {
    const t = await this.getThumbnailPath(e.thumbnail), s = await this.http.put(
      `/homeworks/${e.entId}`,
      {
        title: e.name,
        thumbnail: t,
        repeats: e.repeats
      }
    );
    return this.checkHttpResponse(s), { thumbnail: t, entId: e.entId };
  }
  getResourceType() {
    return RESOURCE$1;
  }
  getApplication() {
    return APP$1;
  }
  getFormUrl(e) {
    return e ? `/homeworks?folderid=${e}#/create-homeworks/` : "/homeworks#/create-homeworks/";
  }
  getViewUrl(e) {
    return `/homeworks#/view-homeworks/${e}`;
  }
  getPrintUrl(e) {
    return `/homeworks/print#/print-homeworks/${e}`;
  }
  getEditUrl(e) {
    return `/homeworks#/edit-homeworks/${e}`;
  }
  getExportUrl() {
    throw new Error("Export not implemented.");
  }
}
ResourceService.register(
  { application: RESOURCE$1, resourceType: RESOURCE$1 },
  (u) => new HomeworksResourceService(u)
);
const APP = "timelinegenerator", RESOURCE = "timelinegenerator";
class TimelineGeneratorResourceService extends ResourceService {
  async create(e) {
    const t = e.thumbnail ? await this.getThumbnailPath(e.thumbnail) : "", s = await this.http.post(
      "/timelinegenerator/timelines",
      {
        headline: e.name,
        text: e.description,
        icon: t,
        type: "default",
        folder: e.folder
      }
    );
    return this.checkHttpResponse(s), s;
  }
  async update(e) {
    const t = await this.getThumbnailPath(e.thumbnail), s = await this.http.put(
      `/timelinegenerator/timeline/${e.entId}`,
      {
        headline: e.name,
        text: e.description,
        icon: t,
        trashed: !!e.trashed,
        _id: e.entId,
        type: "default"
      }
    );
    return this.checkHttpResponse(s), { thumbnail: t, entId: e.entId };
  }
  getResourceType() {
    return RESOURCE;
  }
  getApplication() {
    return APP;
  }
  getFormUrl() {
    throw new Error("Method not implemented.");
  }
  getViewUrl(e) {
    return `/timelinegenerator#/view/${e}`;
  }
  getPrintUrl(e) {
    return `/timelinegenerator/print#/print/${e}`;
  }
  getEditUrl() {
    throw new Error("Method not implemented.");
  }
  getExportUrl() {
    throw new Error("Method not implemented.");
  }
}
ResourceService.register(
  { application: RESOURCE, resourceType: RESOURCE },
  (u) => new TimelineGeneratorResourceService(u)
);
const globalCache = {}, mutexPromise = {};
class CacheService {
  constructor(e) {
    this.context = e;
  }
  get http() {
    return this.context.http();
  }
  async fromCacheIfPossible(e, t, s) {
    if (mutexPromise[e] !== void 0 && await mutexPromise[e], globalCache[e])
      return globalCache[e];
    try {
      const r = t();
      mutexPromise[e] = r;
      const i = await r;
      return s(i) && (globalCache[e] = i), i;
    } catch (r) {
      throw console.error(`Failed to retrieve value for: ${e}`, r), r;
    }
  }
  clearCache(e) {
    if (e)
      delete globalCache[e];
    else
      for (const t in globalCache)
        globalCache.hasOwnProperty(t) && delete globalCache[t];
  }
  async httpGet(e, t) {
    return this.fromCacheIfPossible(
      e,
      async () => {
        const s = await this.http.get(e, t), r = { ...this.http.latestResponse };
        return { value: s, response: r };
      },
      ({ response: s }) => !(s.status < 200 || s.status >= 300)
    );
  }
  async httpGetJson(e, t) {
    const { response: s, value: r } = await this.httpGet(e, t);
    if (s.status < 200 || s.status >= 300)
      throw `Bad http status (${s.status}) for url: ${e}`;
    return r;
  }
}
class ConfService {
  constructor(e) {
    this.context = e;
  }
  get http() {
    return this.context.http();
  }
  get cache() {
    return this.context.cache();
  }
  get cdnDomain() {
    return configure.Platform.cdnDomain;
  }
  get notify() {
    return this.context.notify();
  }
  async getConf(e) {
    const [t, s] = await Promise.all([
      this.getThemeConf(),
      this.getApplicationsList()
    ]), [r, i] = await Promise.all([
      this.getTheme({ conf: t, publicTheme: s === void 0 }),
      this.getWebAppConf({ app: e, applications: s ?? [] })
    ]), n = {
      app: e,
      applications: s ?? [],
      conf: t,
      currentApp: i,
      theme: r
    };
    return this.notify.onAppConfReady().resolve(n), n;
  }
  async getPublicConf(e) {
    const { response: t, value: s } = await this.cache.httpGet(
      `/${e}/conf/public`,
      {
        queryParams: { _: configure.Platform.deploymentTag }
      }
    );
    if (t.status < 200 || t.status >= 300)
      throw ERROR_CODE.APP_NOT_FOUND;
    return s;
  }
  getCdnUrl() {
  }
  async savePreference(e, t) {
    this.http.putJson(`/userbook/preference/${e}`, t);
  }
  async getPreference(e) {
    const t = await this.http.get(
      `/userbook/preference/${e}`
    );
    return this.http.isResponseError() || typeof t == "string" ? {} : JSON.parse(t.preference);
  }
  async getThemeConf(e) {
    return await this.http.getScript(
      "/assets/theme-conf.js",
      { queryParams: { v: e } },
      "exports.conf"
    );
  }
  async getApplicationsList() {
    const e = await this.http.get(
      "/applications-list"
    );
    if (!(this.http.isResponseError() || typeof e == "string"))
      return e.apps;
  }
  async getWebAppConf({
    app: e,
    applications: t
  }) {
    return t.find((r) => {
      if (r != null && r.prefix)
        return (r == null ? void 0 : r.prefix.replace("/", "")) === e;
    });
  }
  async getTheme({
    version: e,
    conf: t,
    publicTheme: s
  }) {
    const r = await this.http.get("/theme"), i = s ? null : r, n = t == null ? void 0 : t.overriding.find(
      (p) => (
        // Public access => simply use the 1st override
        i === null || p.child === i.themeName
      )
    ), a = (i == null ? void 0 : i.skinName) || n.skins[0], c = (i == null ? void 0 : i.skin) || `/assets/themes/${n.child}/skins/${a}/`, h = n.skins, l = n.bootstrapVersion.split("-").slice(-1)[0], E = n.parent === "panda";
    return {
      basePath: `${this.cdnDomain}${c}../../`,
      bootstrapVersion: l,
      is1d: E,
      logoutCallback: (i == null ? void 0 : i.logoutCallback) || "/",
      skin: n.child,
      skinName: a,
      skins: h,
      themeName: n.child,
      themeUrl: c,
      npmTheme: n.npmTheme ?? void 0
    };
  }
  async getLogoutCallback(e) {
    const { response: t, value: s } = await this.cache.httpGet("/theme", {
      queryParams: { _: e }
    });
    if (t.status < 200 || t.status >= 300)
      throw ERROR_CODE.NOT_LOGGED_IN;
    return s.logoutCallback;
  }
}
class DirectoryService {
  constructor(e) {
    this.odeServices = e;
  }
  get http() {
    return this.odeServices.http();
  }
  get cache() {
    return this.odeServices.cache();
  }
  getAvatarUrl(e, t, s = "100x100") {
    return t === "user" ? `/userbook/avatar/${e}?thumbnail=${s}` : "/assets/img/illustrations/group-avatar.svg";
  }
  getDirectoryUrl(e, t) {
    return t === "user" ? `/userbook/annuaire#/${e}` : `/userbook/annuaire#/group-view/${e}`;
  }
  async getBookMarks() {
    return (await this.cache.httpGetJson(
      "/directory/sharebookmark/all"
    )).map(({ id: t, name: s }) => ({
      id: t,
      displayName: s,
      members: []
      // this api does not return members
    }));
  }
  async getBookMarkById(e) {
    const { groups: t, id: s, name: r, users: i } = await this.http.get(
      `/directory/sharebookmark/${e}`
    );
    return {
      id: s,
      displayName: r,
      groups: t.map(({ name: n, id: a }) => ({
        displayName: n,
        id: a
      })),
      users: i.map(({ displayName: n, id: a, profile: c }) => ({
        profile: c,
        displayName: n,
        // these info are missing from api
        firstName: "",
        lastName: "",
        login: "",
        id: a
      }))
    };
  }
  async saveBookmarks(e, {
    bookmarks: t,
    groups: s,
    users: r
  }) {
    this.cache.clearCache("/directory/sharebookmark/all");
    const i = r.map((p) => typeof p == "string" ? p : p.id), n = s.map((p) => typeof p == "string" ? p : p.id), a = t.map(async (p) => {
      if (typeof p == "string") {
        const { displayName: d, groups: g, id: A, users: m } = await this.getBookMarkById(p), b = m.map((F) => F.id), C = g.map((F) => F.id);
        return {
          displayName: d,
          id: A,
          members: [...C, ...b]
        };
      } else
        return Promise.resolve(p);
    }), h = (await Promise.all(a)).map((p) => p.members).reduce((p, d) => [...p, ...d], []), l = {
      name: e,
      members: [...i, ...n, ...h]
    }, { id: E } = await this.http.postJson(
      "/directory/sharebookmark",
      l
    );
    return {
      id: E,
      displayName: e,
      members: l.members
    };
  }
}
const loadedScripts = {};
class HttpService {
  constructor(e, t) {
    // Axios automatically manages the XSRF-TOKEN cookie and the X-XSRF-TOKEN HTTP header.
    o(this, "axios");
    o(this, "baseUrl");
    o(this, "headers", {});
    o(this, "_latestResponse");
    this.context = e, this.axios = axios.create(t);
  }
  fixBaseUrl(e) {
    return e.startsWith("http://") || e.startsWith("https://") ? e : this.baseUrl ? this.baseUrl.endsWith("/") || e.startsWith("/") ? `${this.baseUrl}${e}` : `${this.baseUrl}/${e}` : e;
  }
  useBaseUrl(e) {
    return this.baseUrl = e, this;
  }
  useHeaders(e) {
    return this.headers = e, this;
  }
  setCdn(e) {
    e && XMLHttpRequest && !XMLHttpRequest.prototype.cdnUrl && (XMLHttpRequest.prototype.cdnUrl = e, XMLHttpRequest.prototype.baseOpen = XMLHttpRequest.prototype.open, XMLHttpRequest.prototype.open = function() {
      const t = arguments[1];
      return t.startsWith("/infra/public") && (arguments[1] = e + t), /^\/([^\/]*)\/public/.test(t) && (arguments[1] = e + t), t.startsWith("/assets") && (arguments[1] = e + t), t == "/conf/public" && (arguments[1] = t), t.startsWith("http") && (arguments[1] = t), this.baseOpen.apply(this, arguments);
    });
  }
  // private toAxiosConfig(params?: IHttpParams): AxiosRequestConfig {
  toAxiosConfig(e) {
    if (e) {
      const t = Object.assign({}, this.axios.defaults);
      e.headers && (t.headers = Object.assign({}, this.axios.defaults.headers), Object.assign(t.headers, e.headers)), e.responseType && (t.responseType = e.responseType), e.queryParams && (t.params = Object.assign({}, e.queryParams));
      const s = t.headers ?? {};
      return t.headers = { ...s, ...this.headers }, t;
    } else
      return this.axios.defaults;
  }
  toCdnUrl(e) {
    e = this.fixBaseUrl(e);
    const t = this.context.conf().getCdnUrl() || "";
    if (t.length > 0 && e !== "/conf/public") {
      const s = "" + e;
      (s.startsWith("/infra/public") || s.startsWith("/assets") || /^\/([^\/]*)\/public/.test(s)) && (e = t + s);
    }
    return e;
  }
  mapAxiosError(e, t) {
    e.response ? this._latestResponse = e.response : e.request ? this._latestResponse = {
      status: 408,
      statusText: ERROR_CODE.TIME_OUT
    } : this._latestResponse = {
      status: 500,
      statusText: ERROR_CODE.UNKNOWN
    };
    const { status: s, statusText: r, headers: i, data: n } = this._latestResponse;
    return t != null && t.disableNotifications || notify.events().publish(LAYER_NAME.TRANSPORT, {
      name: EVENT_NAME.ERROR_OCCURED,
      data: {
        params: t,
        response: { status: s, statusText: r, headers: i },
        payload: n
      }
    }), n;
  }
  mapAxiosResponse(e, t) {
    return this._latestResponse = e, e.data;
  }
  get latestResponse() {
    return this._latestResponse;
  }
  isResponseError() {
    return this.latestResponse.status < 200 || this.latestResponse.status >= 300;
  }
  async get(e, t) {
    try {
      const s = await this.axios.get(
        this.toCdnUrl(e),
        this.toAxiosConfig(t)
      );
      return this.mapAxiosResponse(s, t);
    } catch (s) {
      throw this.mapAxiosError(s, t);
    }
  }
  async post(e, t, s) {
    try {
      const r = await this.axios.post(
        this.fixBaseUrl(e),
        t,
        this.toAxiosConfig(s)
      );
      return this.mapAxiosResponse(r, s);
    } catch (r) {
      throw this.mapAxiosError(r, s);
    }
  }
  async postFile(e, t, s) {
    const r = this.toAxiosConfig(s);
    r.headers && r.headers["Content-Type"] && delete r.headers["Content-Type"];
    try {
      const i = await this.axios.post(this.fixBaseUrl(e), t, {
        ...r,
        headers: {
          "Content-Type": "multipart/form-data"
        }
      });
      return this.mapAxiosResponse(i, s);
    } catch (i) {
      throw this.mapAxiosError(i, s);
    }
  }
  async postJson(e, t, s) {
    const r = this.toAxiosConfig();
    r.headers && (r.headers["Content-Type"] = "application/json");
    try {
      const i = await this.axios.post(
        this.fixBaseUrl(e),
        t,
        this.toAxiosConfig(s)
      );
      return this.mapAxiosResponse(i, s);
    } catch (i) {
      throw this.mapAxiosError(i, s);
    }
  }
  async put(e, t, s) {
    try {
      const r = await this.axios.put(
        this.fixBaseUrl(e),
        t,
        this.toAxiosConfig(s)
      );
      return this.mapAxiosResponse(r, s);
    } catch (r) {
      throw this.mapAxiosError(r, s);
    }
  }
  async putFile(e, t, s) {
    try {
      const r = this.toAxiosConfig(s);
      r.headers && r.headers["Content-Type"] && delete r.headers["Content-Type"];
      const i = await this.axios.put(this.fixBaseUrl(e), t, {
        ...r,
        headers: {
          "Content-Type": "multipart/form-data"
        }
      });
      return this.mapAxiosResponse(i, s);
    } catch (r) {
      throw this.mapAxiosError(r, s);
    }
  }
  async putJson(e, t, s) {
    const r = this.toAxiosConfig(s);
    r.headers && (r.headers["Content-Type"] = "application/json");
    try {
      const i = await this.axios.put(this.fixBaseUrl(e), t, r);
      return this.mapAxiosResponse(i, s);
    } catch (i) {
      throw this.mapAxiosError(i, s);
    }
  }
  async delete(e, t) {
    try {
      const s = await this.axios.delete(
        this.fixBaseUrl(e),
        this.toAxiosConfig(t)
      );
      return this.mapAxiosResponse(s, t);
    } catch (s) {
      throw this.mapAxiosError(s, t);
    }
  }
  async deleteJson(e, t) {
    try {
      const s = await this.axios.delete(this.fixBaseUrl(e), {
        data: t
      });
      return this.mapAxiosResponse(s);
    } catch (s) {
      throw this.mapAxiosError(s);
    }
  }
  getScript(e, t, s) {
    const r = s ?? "exports", i = this.toAxiosConfig(t);
    return i.headers && (i.headers.Accept = "application/javascript"), this.axios.get(this.toCdnUrl(e), i).then((n) => this.mapAxiosResponse(n, t)).then((n) => {
      try {
        const a = `"use strict";var ${r.split(".")[0]}={};${n};return ${r};`;
        return Function(a)();
      } catch {
        return n;
      }
    }).catch((n) => {
      throw this.mapAxiosError(n, t), n;
    });
  }
  loadScript(e, t) {
    return loadedScripts[e] ? Promise.resolve() : this.getScript(e, t).then((s) => {
      loadedScripts[e] = !0;
    });
  }
}
class RightService {
  constructor(e) {
    this.context = e;
  }
  get session() {
    return this.context.session();
  }
  /**
   * Parse right concat as "$TYPE:$ID:$RIGHT"
   * $TYPE = user | group | creator
   * $ID: id of the resource
   * $RIGHT: read | contrib | manage
   *
   * @param right  a concat right
   * @returns Right parsed
   */
  parseResourceRight(e) {
    const t = e.split(":");
    if (t.length === 2) {
      if (t[0] === "creator")
        return {
          id: t[1],
          right: "creator",
          type: "creator"
        };
    } else return t.length === 3 ? {
      id: t[1],
      right: t[2],
      type: t[0]
    } : void 0;
  }
  /**
   * Parse an array of rights concat as "$TYPE:$ID:$RIGHT"
   * $TYPE = user | group | creator
   * $ID: id of the resource
   * $RIGHT: read | contrib | manage
   *
   * @param rights  a list of concat rights
   * @returns Array of Right parsed
   */
  parseResourceRights(e) {
    return e.map((s) => this.parseResourceRight(s)).filter((s) => s !== void 0);
  }
  /**
   * Check wether a user has the expected right for a ressource
   * @param user the userId and groupId concerned by the check
   * @param expect the expected right to check
   * @param rights array of Right for the resource
   * @returns true if has rights
   */
  hasResourceRight({ id: e, groupIds: t }, s, r) {
    const i = r.map((n) => typeof n == "string" ? this.parseResourceRight(n) : n).filter((n) => n !== void 0);
    for (const n of i) {
      if (n.id === e && n.type === "creator")
        return !0;
      if (n.id === e && n.type === "user" && n.right === s)
        return !0;
      if (t.includes(n.id) && n.type === "group" && n.right === s)
        return !0;
    }
    return !1;
  }
  /**
   * Check wether the current user have resource right
   * @param expect the expected right to check
   * @param rights array of Right for the resource
   * @returns true if has rights
   */
  async sessionHasResourceRight(e, t) {
    try {
      const s = await this.session.getUser();
      return !!s && this.hasResourceRight(
        { groupIds: s.groupsIds, id: s.userId },
        e,
        t
      );
    } catch (s) {
      return console.error(`Unexpected error ${s} in sessionHasResourceRight()`), !1;
    }
  }
  /**
   * Check wether the current user have at least one of resource right expected
   * @param expects array of expected right to check
   * @param rights array of Right for the resource
   * @returns true if has rights
   */
  async sessionHasAtLeastOneResourceRight(e, t) {
    for (const s of e)
      if (await this.sessionHasResourceRight(s, t))
        return !0;
    return !1;
  }
  /**
   * Check wether the current user has resource right for each right list
   * @param expect expected right to check
   * @param rightsArray array of array of Right for multiple resources
   * @returns true if has rights
   */
  async sessionHasResourceRightForEachList(e, t) {
    let s = 0;
    for (const r of t)
      await this.sessionHasResourceRight(e, r) && s++;
    return s === t.length;
  }
  /**
   * Check wether the current user have at least one of resource right for each right list
   * @param expects array of expected right to check
   * @param rightsArray array of array of Right for multiple resources
   * @returns true if has rights
   */
  async sessionHasAtLeastOneResourceRightForEachList(e, t) {
    for (const s of e) {
      let r = 0;
      for (const i of t)
        await this.sessionHasResourceRight(s, i) && r++;
      if (r === t.length)
        return !0;
    }
    return !1;
  }
  hasWorkflowRight(e, t) {
    return t.findIndex((s) => s === e) !== -1;
  }
  /**
   * @param expect a workflow right
   * @returns true if current session has right on it
   */
  async sessionHasWorkflowRight(e) {
    try {
      const t = await this.session.getUser();
      return !!t && this.hasWorkflowRight(
        e,
        t.authorizedActions.map(
          (s) => s.name
        )
      );
    } catch (t) {
      return console.error(`Unexpected error ${t} in sessionHasWorkflowRight()`), !1;
    }
  }
  /**
   * @param expect a workflow right
   * @returns a record with right as key and boolean as value if current session has right on it
   */
  async sessionHasWorkflowRights(e) {
    const t = {};
    try {
      const s = await this.session.getUser();
      for (const r of e)
        t[r] = !!s && this.hasWorkflowRight(
          r,
          s.authorizedActions.map(
            (i) => i.name
          )
        );
    } catch (s) {
      console.error(`Unexpected error ${s} in sessionHasWorkflowRights()`);
      for (const r of e)
        t[r] = !1;
    }
    return t;
  }
}
class SessionService {
  constructor(e) {
    this.context = e;
  }
  get http() {
    return this.context.http();
  }
  get cache() {
    return this.context.cache();
  }
  get conf() {
    return this.context.conf();
  }
  /**
   * Callback to call when user logout
   */
  onLogout() {
    this.cache.clearCache();
  }
  /**
   * Callback to call when session change
   */
  onRefreshSession() {
    this.cache.clearCache();
  }
  async getSession() {
    const e = await this.getUser(), [
      t,
      s,
      r,
      i,
      n
    ] = await Promise.all([
      this.getCurrentLanguage(e),
      this.latestQuotaAndUsage(e),
      this.loadDescription(e),
      this.getUserProfile(),
      this.getBookmarks(e)
    ]);
    return {
      user: e,
      quotaAndUsage: s,
      currentLanguage: t,
      userDescription: r,
      userProfile: i,
      bookmarkedApps: n
    };
  }
  login(e, t, s, r) {
    const i = new FormData();
    return i.append("email", e), i.append("password", t), typeof s < "u" && i.append("rememberMe", "" + s), typeof r < "u" && i.append("secureLocation", "" + r), this.http.post("/auth/login", i, {
      headers: { "content-type": "application/x-www-form-urlencoded" }
    }).finally(() => {
      switch (this.http.latestResponse.status) {
        case 200:
          throw ERROR_CODE.MALFORMED_DATA;
      }
    });
  }
  async logout() {
    const e = await this.conf.getLogoutCallback();
    return this.http.get("/auth/logout?callback=" + e).finally(() => {
    });
  }
  async latestQuotaAndUsage(e) {
    const t = { quota: 0, storage: 0 };
    if (!e) return t;
    try {
      return await this.http.get(
        `/workspace/quota/user/${e == null ? void 0 : e.userId}`
      );
    } catch (s) {
      return console.error(s), t;
    }
  }
  async getCurrentLanguage(e) {
    const t = (e == null ? void 0 : e.sessionMetadata) && (e == null ? void 0 : e.sessionMetadata.userId);
    try {
      let s;
      return t ? s = await this.loadUserLanguage() : s = await this.loadDefaultLanguage(), s;
    } catch (s) {
      console.error(s);
    }
  }
  async loadUserLanguage() {
    try {
      const e = await this.http.get(
        "/userbook/preference/language"
      );
      return JSON.parse(e.preference)["default-domain"];
    } catch {
      return await this.loadDefaultLanguage();
    }
  }
  async loadDefaultLanguage() {
    return (await this.cache.httpGetJson(
      "/locale"
    )).locale;
  }
  async getUser() {
    const { response: e, value: t } = await this.cache.httpGet(
      "/auth/oauth2/userinfo"
    );
    if (!(e.status < 200 || e.status >= 300) && typeof t == "object")
      return t;
    throw ERROR_CODE.NOT_LOGGED_IN;
  }
  hasWorkflow({
    workflowName: e,
    user: t
  }) {
    return e === void 0 || (t == null ? void 0 : t.authorizedActions.findIndex((s) => s.name === e)) !== -1;
  }
  async loadDescription(e) {
    if (!e) return {};
    try {
      const [t, s] = await Promise.all([
        // FIXME The full user's description should be obtainable from a single endpoint in the backend.
        this.getUserProfile({
          options: { requestName: "refreshAvatar" }
        }),
        this.http.get("/directory/userbook/" + (e == null ? void 0 : e.userId))
      ]);
      return { ...s, profiles: t };
    } catch (t) {
      return console.error(t), {};
    }
  }
  async getBookmarks(e) {
    if (!e) return [];
    const t = await this.http.get("/userbook/preference/apps");
    t.preference || (t.preference = null);
    const s = JSON.parse(t.preference);
    let r;
    r = s, r || (r = {
      bookmarks: [],
      applications: []
    });
    const i = [];
    return r.bookmarks.forEach((n, a) => {
      const c = ((e == null ? void 0 : e.apps) || []).find(
        (h) => h.name === n
      );
      if (c) {
        const h = Object.assign({}, c);
        i.push(h);
      }
    }), i;
  }
  async getUserProfile(e = {}) {
    var c, h;
    const { options: t = {}, params: s = {} } = e, r = new URLSearchParams(s).toString(), i = `/userbook/api/person${r ? `?${r}` : ""}`, { response: n, value: a } = await this.cache.httpGet(i, t);
    return n.status < 200 || n.status >= 300 || typeof a == "string" ? ["Guest"] : ((h = (c = a == null ? void 0 : a.result) == null ? void 0 : c[0]) == null ? void 0 : h.type) || ["Guest"];
  }
  async isAdml() {
    const e = await this.getUser();
    return (e == null ? void 0 : e.functions.ADMIN_LOCAL) !== void 0;
  }
  /**
   * Get details of an application if the user can access it.
   * @return undefined if no access, or app not found
   */
  async getWebApp(e) {
    const t = await this.getUser();
    return t == null ? void 0 : t.apps.find((s) => {
      var r;
      return s != null && s.prefix ? (s == null ? void 0 : s.prefix.replace("/", "")) === e || !1 : s != null && s.address && ((r = s.address) == null ? void 0 : r.split("/")[1]) === e || !1;
    });
  }
}
const bundle = {}, promises = {}, defaultDiacriticsRemovalMap = [
  {
    base: "A",
    letters: /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
  },
  { base: "AA", letters: /[\uA732]/g },
  { base: "AE", letters: /[\u00C6\u01FC\u01E2]/g },
  { base: "AO", letters: /[\uA734]/g },
  { base: "AU", letters: /[\uA736]/g },
  { base: "AV", letters: /[\uA738\uA73A]/g },
  { base: "AY", letters: /[\uA73C]/g },
  {
    base: "B",
    letters: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
  },
  {
    base: "C",
    letters: /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
  },
  {
    base: "D",
    letters: /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
  },
  { base: "DZ", letters: /[\u01F1\u01C4]/g },
  { base: "Dz", letters: /[\u01F2\u01C5]/g },
  {
    base: "E",
    letters: /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
  },
  { base: "F", letters: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g },
  {
    base: "G",
    letters: /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
  },
  {
    base: "H",
    letters: /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
  },
  {
    base: "I",
    letters: /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
  },
  { base: "J", letters: /[\u004A\u24BF\uFF2A\u0134\u0248]/g },
  {
    base: "K",
    letters: /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
  },
  {
    base: "L",
    letters: /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
  },
  { base: "LJ", letters: /[\u01C7]/g },
  { base: "Lj", letters: /[\u01C8]/g },
  { base: "M", letters: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g },
  {
    base: "N",
    letters: /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
  },
  { base: "NJ", letters: /[\u01CA]/g },
  { base: "Nj", letters: /[\u01CB]/g },
  {
    base: "O",
    letters: /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
  },
  { base: "OI", letters: /[\u01A2]/g },
  { base: "OO", letters: /[\uA74E]/g },
  { base: "OU", letters: /[\u0222]/g },
  {
    base: "P",
    letters: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
  },
  { base: "Q", letters: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g },
  {
    base: "R",
    letters: /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
  },
  {
    base: "S",
    letters: /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
  },
  {
    base: "T",
    letters: /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
  },
  { base: "TZ", letters: /[\uA728]/g },
  {
    base: "U",
    letters: /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
  },
  { base: "V", letters: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g },
  { base: "VY", letters: /[\uA760]/g },
  {
    base: "W",
    letters: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
  },
  { base: "X", letters: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g },
  {
    base: "Y",
    letters: /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
  },
  {
    base: "Z",
    letters: /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
  },
  {
    base: "a",
    letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
  },
  { base: "aa", letters: /[\uA733]/g },
  { base: "ae", letters: /[\u00E6\u01FD\u01E3]/g },
  { base: "ao", letters: /[\uA735]/g },
  { base: "au", letters: /[\uA737]/g },
  { base: "av", letters: /[\uA739\uA73B]/g },
  { base: "ay", letters: /[\uA73D]/g },
  {
    base: "b",
    letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
  },
  {
    base: "c",
    letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
  },
  {
    base: "d",
    letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
  },
  { base: "dz", letters: /[\u01F3\u01C6]/g },
  {
    base: "e",
    letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
  },
  { base: "f", letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g },
  {
    base: "g",
    letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
  },
  {
    base: "h",
    letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
  },
  { base: "hv", letters: /[\u0195]/g },
  {
    base: "i",
    letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
  },
  { base: "j", letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g },
  {
    base: "k",
    letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
  },
  {
    base: "l",
    letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
  },
  { base: "lj", letters: /[\u01C9]/g },
  { base: "m", letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g },
  {
    base: "n",
    letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
  },
  { base: "nj", letters: /[\u01CC]/g },
  {
    base: "o",
    letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
  },
  { base: "oi", letters: /[\u01A3]/g },
  { base: "ou", letters: /[\u0223]/g },
  { base: "oo", letters: /[\uA74F]/g },
  {
    base: "p",
    letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
  },
  { base: "q", letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g },
  {
    base: "r",
    letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
  },
  {
    base: "s",
    letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
  },
  {
    base: "t",
    letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
  },
  { base: "tz", letters: /[\uA729]/g },
  {
    base: "u",
    letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
  },
  { base: "v", letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g },
  { base: "vy", letters: /[\uA761]/g },
  {
    base: "w",
    letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
  },
  { base: "x", letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g },
  {
    base: "y",
    letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
  },
  {
    base: "z",
    letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
  }
];
class IdiomService {
  constructor(e) {
    this.context = e;
  }
  get http() {
    return this.context.http();
  }
  async getIdiom(e, t) {
    await Promise.all([
      this.addBundlePromise(e, "/i18n"),
      this.addBundlePromise(e, `/${t}/i18n`)
    ]);
  }
  translate(e, t) {
    e = e ?? "";
    let s = bundle[e] === void 0 ? e : bundle[e];
    if (t && typeof t == "object")
      for (const r in t)
        typeof t[r] < "u" && (s = s.replace(
          new RegExp("\\${" + r + "}", "g"),
          "" + t[r]
        ));
    return s;
  }
  addBundlePromise(e, t) {
    return this.loadBundlePromise(e, t);
  }
  addBundle(e, t, s) {
    this.loadBundle(e, t, s);
  }
  loadBundlePromise(e, t) {
    return this.loadBundle(e, t), promises[t];
  }
  loadBundle(e, t, s) {
    const r = promises[t];
    if (r)
      s && r.then(s).catch(s);
    else {
      const i = new Promisified();
      promises[t] = i.promise;
      const n = {};
      e && (n["Accept-Language"] = e), this.http.get(t, { headers: n }).then((a) => {
        Object.assign(bundle, a), typeof s == "function" && s(), i.resolve();
      }).catch((a) => {
        typeof s == "function" && s(), i.reject();
      });
    }
  }
  addTranslations(e, t) {
    notify.onLangReady().promise.then((s) => {
      this.loadBundle(s, e + "/" + s + ".json", t);
    });
  }
  addAllTranslations(e) {
    return e && e.length > 0 ? notify.onLangReady().promise.then(
      (t) => Promise.all(
        e.map(
          (s) => this.loadBundlePromise(t, s + "/" + t + ".json")
        )
      )
    ).then(() => {
    }) : Promise.reject();
  }
  addKeys(e) {
    for (const t in e)
      typeof bundle[t] != "string" && (bundle[t] = e[t]);
  }
  removeAccents(e) {
    for (let t = 0; t < defaultDiacriticsRemovalMap.length; t++)
      e = e.replace(
        defaultDiacriticsRemovalMap[t].letters,
        defaultDiacriticsRemovalMap[t].base
      );
    return e;
  }
}
class StringUtils {
  static removeAccents(e) {
    for (let t = 0; t < defaultDiacriticsRemovalMap.length; t++)
      e = e.replace(
        defaultDiacriticsRemovalMap[t].letters,
        defaultDiacriticsRemovalMap[t].base
      );
    return e;
  }
}
class ShareService {
  //
  // IMPLEMENTATION
  //
  constructor(e) {
    this.context = e;
  }
  get directory() {
    return this.context.directory();
  }
  get http() {
    return this.context.http();
  }
  get cache() {
    return this.context.cache();
  }
  async searchShareSubjects(e, t, s) {
    const r = StringUtils.removeAccents(s).toLowerCase(), i = await this.cache.httpGetJson(
      `/${e}/share/json/${t}?search=${s}`
    ), n = i.users.visibles.filter(({ username: l, firstName: E, lastName: p, login: d }) => {
      const g = StringUtils.removeAccents(
        p || ""
      ).toLowerCase(), A = StringUtils.removeAccents(
        E || ""
      ).toLowerCase(), m = StringUtils.removeAccents(
        l || ""
      ).toLowerCase(), b = StringUtils.removeAccents(d || "").toLowerCase();
      return m.includes(r) || A.includes(r) || g.includes(r) || b.includes(r);
    }).map((l) => ({
      avatarUrl: this.directory.getAvatarUrl(l.id, "user"),
      directoryUrl: this.directory.getDirectoryUrl(l.id, "user"),
      displayName: l.username,
      id: l.id,
      profile: l.profile,
      type: "user"
    })), a = i.groups.visibles.filter(({ name: l }) => StringUtils.removeAccents(l || "").toLowerCase().includes(r)).map((l) => ({
      avatarUrl: this.directory.getAvatarUrl(l.id, "group"),
      directoryUrl: this.directory.getDirectoryUrl(l.id, "group"),
      displayName: l.name,
      id: l.id,
      type: "group",
      structureName: l.structureName
    }));
    return [...(await this.directory.getBookMarks()).filter(({ displayName: l }) => StringUtils.removeAccents(
      l || ""
    ).toLowerCase().includes(r)).map((l) => ({
      avatarUrl: "",
      directoryUrl: "",
      profile: "",
      displayName: l.displayName,
      id: l.id,
      type: "sharebookmark"
    })), ...n, ...a];
  }
  async getShareMapping(e) {
    const t = await this.cache.httpGetJson(
      `/${e}/rights/sharing`
    );
    for (const s of Object.keys(t))
      if (s.includes(".")) {
        const r = s.split(".")[1], i = t[s];
        delete t[s], t[r] = i;
      }
    return t;
  }
  getActionsAvailableFor({ id: e, type: t }, s, r) {
    const n = (t === "user" ? s.users.checked[e] : s.groups.checked[e]) || [], a = Object.keys(r), c = [];
    for (const h of a)
      r[h].filter(
        (p) => n.includes(p)
      ).length > 0 && c.push(h);
    return c;
  }
  async getRightsForResource(e, t) {
    const s = await this.directory.getBookMarks(), r = `/${e}/share/json/${t}?search=`, i = await this.cache.httpGetJson(r), n = await this.getShareMapping(e), a = await this.cache.httpGetJson(
      "/infra/public/json/sharing-rights.json"
    ), c = Object.keys(i.users.checked).map((d) => i.users.visibles.find(
      (A) => A.id === d
    )).filter((d) => d !== void 0).map((d) => {
      const g = this.getActionsAvailableFor(
        { id: d.id, type: "user" },
        i,
        n
      );
      return {
        id: d.id,
        type: "user",
        displayName: d.username,
        profile: d.profile,
        avatarUrl: this.directory.getAvatarUrl(d.id, "user"),
        directoryUrl: this.directory.getDirectoryUrl(d.id, "user"),
        actions: g.map((m) => {
          const b = a[m];
          return {
            displayName: m,
            id: m,
            priority: b.priority
          };
        })
      };
    }).sort((d, g) => (d.displayName || "").localeCompare(g.displayName)), h = Object.keys(i.groups.checked).map((d) => i.groups.visibles.find(
      (A) => A.id === d
    )).filter((d) => d !== void 0).map((d) => {
      const g = this.getActionsAvailableFor(
        { id: d.id, type: "group" },
        i,
        n
      );
      return {
        id: d.id,
        type: "group",
        displayName: d.name,
        profile: void 0,
        avatarUrl: this.directory.getAvatarUrl(d.id, "group"),
        directoryUrl: this.directory.getDirectoryUrl(d.id, "group"),
        actions: g.map((m) => {
          const b = a[m];
          return {
            displayName: m,
            id: m,
            priority: b.priority
          };
        })
      };
    }).sort((d, g) => (d.displayName || "").localeCompare(g.displayName)), l = [...c, ...h], E = i.groups.visibles.map(
      ({ groupDisplayName: d, id: g, name: A }) => ({
        displayName: d || A,
        id: g
      })
    ), p = i.users.visibles.map(
      ({ id: d, profile: g, username: A, firstName: m, lastName: b, login: C }) => ({
        displayName: A,
        firstName: m,
        lastName: b,
        login: C,
        profile: g,
        id: d
      })
    );
    return {
      rights: l,
      visibleBookmarks: s,
      visibleGroups: E,
      visibleUsers: p
    };
  }
  async saveRights(e, t, s) {
    const r = await this.getShareMapping(e), i = {
      bookmarks: {},
      groups: {},
      users: {}
    };
    for (const c of s) {
      const h = c.actions.map((E) => r[E.id]).reduce((E, p) => Array.isArray(p) ? [...E, ...p] : E, []), l = [...new Set(h)];
      l.length > 0 && (c.type === "user" ? i.users[c.id] = l : c.type === "group" ? i.groups[c.id] = l : i.bookmarks[c.id] = l);
    }
    const n = `/${e}/share/resource/${t}`;
    return this.cache.clearCache(`/${e}/share/json/${t}?search=`), await this.http.putJson(n, i);
  }
  async getActionsForApp(e) {
    const t = await this.cache.httpGetJson(
      "/infra/public/json/sharing-rights.json"
    ), s = await this.getShareMapping(e);
    return Object.keys(t).map((i) => {
      const n = t[i];
      return {
        displayName: i,
        id: i,
        priority: n.priority,
        requires: n.requires
      };
    }).filter((i) => {
      var n;
      return ((n = s[i.id]) == null ? void 0 : n.length) > 0;
    }).sort((i, n) => i.priority - n.priority);
  }
}
const defaultMappers = {
  csv: function({ type: u, extension: e }) {
    return MimeTypeUtils.INSTANCE.isCsvLike(u, e);
  },
  doc: function({ type: u, extension: e }) {
    return MimeTypeUtils.INSTANCE.isWordLike(u, e) ? !0 : u.indexOf("document") !== -1 && u.indexOf("wordprocessing") !== -1;
  },
  xls: function({ type: u, extension: e }) {
    return MimeTypeUtils.INSTANCE.isExcelLike(u, e) ? !0 : u.indexOf("document") !== -1 && u.indexOf("spreadsheet") !== -1 || u.indexOf("ms-excel") !== -1;
  },
  img: function({ type: u }) {
    return u.indexOf("image") !== -1;
  },
  pdf: function({ type: u }) {
    return u.indexOf("pdf") !== -1 || u === "application/x-download";
  },
  ppt: function({ type: u, extension: e }) {
    return MimeTypeUtils.INSTANCE.isPowerpointLike(u, e) ? !0 : u.indexOf("document") !== -1 && u.indexOf("presentation") !== -1 || u.indexOf("powerpoint") !== -1;
  },
  txt: function({ type: u, extension: e }) {
    return MimeTypeUtils.INSTANCE.isTxtLike(u, e);
  },
  md: function({ type: u, extension: e }) {
    return MimeTypeUtils.INSTANCE.isMdLike(u, e);
  },
  video: function({ type: u }) {
    return u.indexOf("video") !== -1;
  },
  audio: function({ type: u }) {
    return u.indexOf("audio") !== -1;
  },
  zip: function({ type: u }) {
    return u.indexOf("zip") !== -1 || u.indexOf("rar") !== -1 || u.indexOf("tar") !== -1 || u.indexOf("7z") !== -1;
  }
}, R = class R {
  /* Similar role notion as in infra-front > workspace > Model.ts */
  static getRole(e) {
    var t, s;
    return R.role(
      (t = e.metadata) == null ? void 0 : t["content-type"],
      !1,
      (s = e.metadata) == null ? void 0 : s.extension
    );
  }
  /* Similar role notion as in infra-front > workspace > Model.ts */
  static role(e, t = !1, s) {
    if (s && (s = s.trim()), !e) return "unknown";
    this.roleMappers || console.warn("[DocumentHelper.role] should not have empty roles", this);
    const r = { type: e, previewRole: t, extension: s };
    for (const i of this.roleMappers) {
      const n = i(r);
      if (n)
        return n;
    }
    return "unknown";
  }
};
// FIXME add edumedia support
o(R, "roleMappers", [
  (e) => Object.keys(defaultMappers).find((s) => defaultMappers[s](e))
]);
let DocumentHelper = R;
class WorkspaceService {
  constructor(e) {
    this.context = e;
  }
  get http() {
    return this.context.http();
  }
  extractMetadata(e) {
    const t = e.name || "", s = t.split("."), r = e.type || "application/octet-stream", i = s.length > 1 ? s[s.length - 1] : "", n = {
      "content-type": r,
      filename: t,
      size: e.size,
      extension: i,
      role: DocumentHelper.role(r, !1, i)
    }, a = t.replace("." + n.extension, ""), c = n.extension ? a + "." + n.extension : a;
    return { basename: a, fullname: c, metadata: n };
  }
  async saveFile(e, t) {
    const { fullname: s, metadata: r } = this.extractMetadata(e), i = new FormData();
    i.append("file", e, s);
    const n = [];
    ((t == null ? void 0 : t.visibility) === "public" || (t == null ? void 0 : t.visibility) === "protected") && n.push(`${t.visibility}=true`), t != null && t.application && n.push(`application=${t.application}`), r.role === "img" && n.push("quality=1"), t != null && t.parentId && n.push(`parentId=${t.parentId}`);
    const a = await this.http.postFile(
      `/workspace/document?${n.join("&")}`,
      i
    );
    if (this.http.isResponseError())
      throw this.http.latestResponse.statusText;
    return a;
  }
  async updateFile(e, t, s) {
    const { fullname: r, metadata: i } = this.extractMetadata(t), n = new FormData();
    n.append("file", t, r);
    const a = [];
    i.role === "img" && a.push("quality=1"), s != null && s.alt && a.push(`alt=${s.alt}`), s != null && s.legend && a.push(`legend=${s.legend}`), s != null && s.name && a.push(`name=${s.name}`);
    const c = await this.http.putFile(
      `/workspace/document/${e}?${a.join("&")}`,
      n
    );
    if (this.http.isResponseError())
      throw this.http.latestResponse.statusText;
    return c;
  }
  async deleteFile(e) {
    const t = e.map((s) => s._id);
    if (t.length == 0)
      Promise.resolve(null);
    else if (await this.http.deleteJson("/workspace/documents", {
      ids: t
    }), this.http.isResponseError())
      throw this.http.latestResponse.statusText;
  }
  async acceptDocuments(e) {
    const t = await this.context.session().getUser();
    return (s) => s.deleted && s.trasher ? (t == null ? void 0 : t.userId) == s.trasher : !0;
  }
  async searchDocuments(e) {
    const t = e.filter !== "external" || e.parentId ? await this.http.get("/workspace/documents", {
      queryParams: { ...e, _: (/* @__PURE__ */ new Date()).getTime() }
    }) : [], s = await this.acceptDocuments(e);
    return t.filter(s);
  }
  async listDocuments(e, t) {
    return this.searchDocuments({ filter: e, parentId: t, includeall: !0 });
  }
  /**
   * Duplicate and transfers documents if needed to a different folder with the specified application and visibility.
   * @param documents - The array of documents to transfer.
   * @param application - The application to associate with the transferred documents.
   * @param visibility - The visibility of the transferred documents. Defaults to "protected".
   * @returns A Promise that resolves to an array of transferred WorkspaceElements.
   */
  async transferDocuments(e, t, s = "protected") {
    const r = [];
    if (e.forEach((i) => {
      (s === "public" && !i.public || !i.public && !i.protected) && r.push(i);
    }), r.length > 0) {
      const i = await this.http.post(
        "/workspace/documents/transfer",
        {
          application: t,
          visibility: s,
          ids: r.map((n) => n._id)
        }
      );
      if (this.http.isResponseError())
        throw this.http.latestResponse.statusText;
      return r.forEach((n, a) => {
        const c = e.findIndex(
          (h) => h._id === n._id
        );
        0 <= c && c < e.length && (e[c] = i[a]);
      }), e.filter((n) => !!n);
    }
    return e;
  }
  /**
   * Get the URL of the thumbnail of a workspace element (or its URL),
   * or `null` if none exists or can be created.
   */
  getThumbnailUrl(e, t = 0, s = 0) {
    var i, n;
    const r = t > 0 || s > 0 ? `${t}x${s}` : "120x120";
    if (typeof e == "string")
      return e.includes("data:image") || e.includes("thumbnail") ? e : `${e}${e.includes("?") ? "&" : "?"}thumbnail=${r}`;
    {
      const a = `/workspace/${e.public ? "pub/" : ""}document/${e._id}?thumbnail=`, c = e.thumbnails;
      if ((n = (i = e.metadata) == null ? void 0 : i["content-type"]) != null && n.includes("video")) {
        const h = c && Object.keys(c).length > 0 ? Object.keys(c)[0] : null;
        return h ? a + h : null;
      } else
        return a + r;
    }
  }
}
let ATTag;
class AnalyticsService {
  constructor(u) {
    this.context = u;
  }
  get http() {
    return this.context.http();
  }
  get session() {
    return this.context.session();
  }
  /**
   * Xiti tracker for page loading.
   * @param locationPath
   * @param app
   */
  async trackPageLoad(u, e) {
    const [t] = await Promise.all([
      // get Xiti configuration
      this.getXitiConfig(e.name.toLowerCase()),
      // load Xiti javascript file
      this.loadXitiScript()
    ]);
    if (!t || !ATInternet) return;
    let s = t.LIBELLE_SERVICE.default || null;
    for (const r in t.LIBELLE_SERVICE)
      if (r !== "default" && u.indexOf(r) >= 0) {
        s = t.LIBELLE_SERVICE[r];
        break;
      }
    ATTag = new ATInternet.Tracker.Tag({ site: t.STRUCT_ID }), ATTag.setProps(
      {
        SERVICE: s,
        TYPE: t.TYPE,
        OUTIL: t.OUTIL,
        UAI: t.STRUCT_UAI,
        PROJET: t.PROJET,
        EXPLOITANT: t.EXPLOITANT,
        PLATEFORME: t.PLATFORME,
        PROFIL: t.PROFILE
      },
      !0
    ), ATTag.identifiedVisitor.set({
      id: t.ID_PERSO,
      category: t.PROFILE
    }), ATTag.page.set({
      name: (e == null ? void 0 : e.prefix) === "userbook" ? "directory" : e == null ? void 0 : e.prefix,
      chapter1: "",
      chapter2: "",
      chapter3: "",
      level2: t.STRUCT_UAI
    }), ATTag.dispatch();
  }
  async getXitiConfig(u) {
    const [e, t] = await Promise.all([
      this.http.get("/analyticsConf"),
      //FIXME change servers config to only keep the "all-in-one" query to /analyticsConf.
      this.http.get("/xiti/config")
    ]);
    if (!(e != null && e.type))
      throw ERROR_CODE.MALFORMED_DATA;
    return t != null && t.active && (e.xiti = await this.getXitiTrackingParams(t, u)), e.xiti;
  }
  async loadXitiScript() {
    if (typeof ATInternet > "u") {
      const scriptPath = "/xiti/public/js/lib/smarttag_ENT.js", response = await this.http.get(scriptPath, {
        headers: { Accept: "application/javascript" }
      });
      if (this.http.latestResponse.status != 200)
        throw "Error while loading XiTi script";
      eval(response);
    }
  }
  async getXitiTrackingParams(u, e) {
    if (!u.structureMap || !e) return;
    const t = await this.session.getUser(), s = await this.session.getUserProfile();
    let r;
    if (!(t != null && t.structures)) return;
    for (const h of t.structures) {
      const l = u.structureMap[h];
      if (l && l.collectiviteId && l.UAI) {
        r = l;
        break;
      }
    }
    if (!r || !r.active) return;
    const i = await configure.Platform.apps.getPublicConf(e);
    if (!i) return;
    const n = i.xiti;
    if (!n || !n.LIBELLE_SERVICE || !r.UAI) return;
    function a(h) {
      let l = "";
      for (let E = 0; E < h.length; E++)
        l += h.charCodeAt(E);
      return l;
    }
    const c = {
      Student: "ELEVE",
      Teacher: "ENSEIGNANT",
      Relative: "PARENT",
      Personnel: "ADMIN_VIE_SCOL_TECH",
      Guest: "AUTRE"
    };
    return {
      LIBELLE_SERVICE: n.LIBELLE_SERVICE,
      // Which property of LIBELLE_SERVICE to use depends on the frontend.
      TYPE: n.OUTIL ? "TIERS" : "NATIF",
      OUTIL: n.OUTIL ? n.OUTIL : "",
      STRUCT_ID: r.collectiviteId,
      STRUCT_UAI: r.UAI,
      PROJET: r.projetId ? r.projetId : u.ID_PROJET,
      EXPLOITANT: u.ID_EXPLOITANT,
      PLATFORME: r.plateformeId ? r.plateformeId : u.ID_PLATEFORME,
      ID_PERSO: a(t.userId),
      PROFILE: s && s.length > 0 ? c[s[0]] ?? "" : ""
    };
  }
}
const w = class w {
  // in minutes. Applies to recorded videos.
  constructor(e) {
    this.context = e;
  }
  get http() {
    return this.context.http();
  }
  get conf() {
    return this.context.conf();
  }
  /**
   * Returns the video app public conf (maxWeight, maxDuration and accepted extensions)
   * @returns the Video app public conf
   */
  async getVideoConf() {
    var t;
    const e = await this.conf.getPublicConf(
      APP$3.VIDEO
    );
    return {
      maxWeight: (e == null ? void 0 : e["max-videosize-mbytes"]) ?? w.MAX_WEIGHT,
      maxDuration: (e == null ? void 0 : e["max-videoduration-minutes"]) ?? w.MAX_DURATION,
      acceptVideoUploadExtensions: ((t = e == null ? void 0 : e["accept-videoupload-extensions"]) == null ? void 0 : t.map(
        (s) => s.toUpperCase()
      )) ?? []
    };
  }
  /**
   * Starts the encoding process and check when video is fully processed.
   * @param params cf VideoUploadParams
   * @returns a VideoCheckResponse
   */
  async upload({
    data: e,
    appCode: t,
    captation: s,
    duration: r
  }) {
    if (!e.file)
      throw new Error("Invalid video file.");
    if (!e.filename)
      throw new Error("Invalid video filename");
    const i = `${e.browser.name} ${e.browser.version}`, n = new FormData();
    n.append("device", e.device || ""), n.append("browser", i), n.append("url", e.url), n.append("app", t), n.append("file", e.file, e.filename), n.append("weight", "" + e.file.size), n.append("captation", "" + s);
    let a = `/video/encode?captation=${s}`;
    r && (a += `&duration=${r}`);
    const c = await this.http.post(
      a,
      n,
      { headers: { "Content-Type": "multipart/form-data" } }
    );
    if (c.state == "running") {
      let h = 0, l = 1;
      do {
        const E = l + h;
        await new Promise(
          (d) => setTimeout(d, E * 1e3)
        ), h = l, l = Math.min(8, E);
        const p = await this.http.get(
          `/video/status/${c.processid}`
        );
        if (p.state == "succeed")
          return p.videoworkspaceid && p.videosize && this.context.data().trackVideoSave(
            p.videoworkspaceid,
            Math.round(r),
            p.videosize,
            s,
            e.url,
            i,
            e.device
          ), p;
        if (p.state == "error")
          break;
      } while (!0);
    }
    throw new Error("Video cannot be uploaded.");
  }
};
o(w, "MAX_WEIGHT", 50), // in Mbytes. Applies to uploaded videos.
o(w, "MAX_DURATION", 3);
let VideoService = w;
class EmbedderService {
  constructor(e) {
    this.context = e;
  }
  get http() {
    return this.context.http();
  }
  /**
   * Returns the default list of video embedder
   * @returns the default list of video embedder
   */
  async getDefault() {
    return this.http.get("/infra/embed/default");
  }
  /**
   * Returns the custom list of video embedder
   * @returns the custom list of video embedder
   */
  async getCustom() {
    return this.http.get("/infra/embed/custom");
  }
  /**
   * The provider matching with the URL
   * @param {Embedder[]} embedderList - The list of video providers to test with
   * @param {String} url - The URL for the video
   * @returns The provider matching with the URL or undefined
   */
  getProviderFromUrl(e, t) {
    for (const s of e)
      if (this.isUrlFromProvider(t, s))
        return s;
  }
  urlIsFromPattern(e, t) {
    const s = new RegExp("[^{}]+(?=(?:[^{}]*{[^}]*})*[^}]*$)", "g"), r = new RegExp("{[^}]*}", "g");
    let i = !0;
    const n = t.match(s) || [], a = [];
    return (t.match(r) || []).forEach((h, l) => {
      h.includes("ignore") || a.push(n[l]);
    }), a.forEach((h) => {
      if (!e.includes(h)) {
        i = !1;
        return;
      }
    }), i;
  }
  /**
   * Check if a given URL correspond to one of the URL pattern of the provider
   * @param {String} url - The URL for the video
   * @param {Embedder} embedder - The video provider to test with
   * @returns boolean depending if a given URL correspond to one of the URL pattern of the provider
   */
  isUrlFromProvider(e, t) {
    typeof t.url == "string" && (t.url = [t.url]);
    for (const s of t.url)
      if (this.urlIsFromPattern(e, s))
        return !0;
    return !1;
  }
  /**
   * Get embed code to display the video for an URL and a provider
   * @param {Embedder} embedder - The video provider for the URL
   * @param {String} url - The URL for the video
   * @returns embed code to display the video for an URL and a provider
   */
  getEmbedCodeForProvider(e, t) {
    for (const s of e.url)
      if (this.urlIsFromPattern(t, s)) {
        const r = new RegExp("{[a-zA-Z0-9_.]+}", "g"), i = s.match(r) || [];
        let n = e.embed;
        for (const a of i) {
          let c = s.split(a)[0];
          const h = c.split("}");
          h.length > 1 && (c = h[h.length - 1]);
          let l = t.split(c)[1];
          if (!l)
            continue;
          const E = s.split(a)[1].split("{")[0];
          E && (l = l.split(E)[0]);
          const p = new RegExp("\\" + a.replace(/}/, "\\}"), "g");
          n = n.replace(p, l);
        }
        return n;
      }
    return "";
  }
}
class AbstractBehaviourService {
  //
  // IMPLEMENTATION
  //
  constructor(e) {
    //-----------------
    //--- Utilities ---
    //-----------------
    o(this, "_cache");
    this.context = e, this._cache = new CacheService(this.context);
  }
  getApplication() {
    return this.APP;
  }
  getResourceType() {
    return this.RESOURCE;
  }
  httpGet(e, t) {
    return this._cache.httpGetJson(e, t);
  }
  /* Utility to map data between linker model and search model. */
  dataToResource({
    modified: e,
    ...t
  }) {
    const s = typeof e == "string" ? e : e != null && e.$date ? "" + e.$date : "";
    return {
      application: this.RESOURCE,
      name: t.title,
      creatorId: t.owner,
      creatorName: t.ownerName,
      thumbnail: t.icon,
      assetId: t._id,
      modifiedAt: s,
      shared: t.shared,
      path: t.path
    };
  }
}
class ActualitesBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "actualites");
    o(this, "RESOURCE", "actualites");
  }
  async loadResources() {
    return (await this.httpGet(
      "/actualites/linker/infos"
    )).map((s) => {
      let r;
      return s.thread_icon ? r = s.thread_icon + "?thumbnail=48x48" : r = "/img/icons/glyphicons_036_file.png", this.dataToResource({
        title: s.title + " [" + s.thread_title + "]",
        ownerName: s.username,
        owner: s.owner,
        icon: r,
        path: "/actualites#/view/thread/" + s.thread_id + "/info/" + s._id,
        _id: `${s.thread_id}#${s._id}`,
        shared: !!(s.shared && s.shared.length >= 0),
        modified: s.modified
      });
    });
  }
}
class BlogBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "blog");
    o(this, "RESOURCE", "blog");
  }
  loadResources() {
    return new Promise(async (t, s) => {
      try {
        const r = await this.httpGet("/blog/linker"), i = [];
        r.forEach((n) => {
          n.thumbnail ? n.thumbnail = n.thumbnail + "?thumbnail=48x48" : n.thumbnail = "/img/illustrations/blog.svg";
          const a = n.fetchPosts.map((c) => this.dataToResource({
            owner: n.author.userId,
            ownerName: n.author.username,
            title: c.title + " [" + n.title + "]",
            _id: `${n._id}#${c._id}`,
            icon: n.thumbnail,
            path: `/blog/id/${n._id}/post/${c._id}`,
            shared: !!(n.shared && n.shared.length >= 0),
            modified: n.modified
          }));
          i.push(...a);
        }), t(i);
      } catch (r) {
        s(r);
      }
    });
  }
}
class CollaborativewallBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "collaborativewall");
    o(this, "RESOURCE", "collaborativewall");
  }
  async loadResources() {
    return (await this.httpGet(
      "/collaborativewall/list/all"
    )).map(
      (s) => this.dataToResource({
        title: s.name,
        ownerName: s.owner.displayName,
        owner: s.owner.userId,
        icon: s.icon ? s.icon : "/img/illustrations/collaborative-wall-default.png",
        path: "/collaborativewall#/view/" + s._id,
        _id: s._id,
        shared: !!(s.shared && s.shared.length >= 0),
        modified: s.modified
      })
    );
  }
}
class CommunityBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "community");
    o(this, "RESOURCE", "community");
  }
  async loadResources() {
    return (await this.httpGet(
      "/community/listallpages"
    )).map((s) => {
      let r;
      return typeof s.thumbnail > "u" || s.thumbnail === "" ? r = "/img/icons/glyphicons_036_file.png" : r = s.thumbnail + "?thumbnail=48x48", this.dataToResource({
        title: s.name,
        icon: r,
        path: "/community#/view/" + s.id,
        _id: s.id,
        owner: "",
        ownerName: "",
        shared: !!(s.shared && s.shared.length >= 0),
        modified: s.name
        // FIXME date ?
      });
    });
  }
}
class ExercizerBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "exercizer");
    o(this, "RESOURCE", "exercizer");
  }
  async loadResources() {
    return (await this.httpGet(
      "/exercizer/subjects-scheduled"
    )).map((s) => {
      const r = s.picture ? s.picture + "?thumbnail=48x48" : "/img/illustrations/exercizer.svg";
      let i, n = !1;
      const a = JSON.parse(s.scheduled_at);
      return a.groupList.length > 0 ? (n = !0, i = a.groupList[0].name) : a.userList.length > 0 ? (n = !0, i = a.userList[0].name) : i = "", a.groupList.length + a.userList.length > 1 && (i += "..."), this.dataToResource({
        title: s.title,
        owner: s.owner,
        ownerName: i,
        icon: r,
        path: "/exercizer#/linker/" + s.id,
        _id: "" + s.id,
        shared: n,
        modified: s.modified
      });
    });
  }
}
class FormulaireBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "formulaire");
    o(this, "RESOURCE", "formulaire");
  }
  async loadResources() {
    return (await this.httpGet(
      "/formulaire/forms/linker"
    )).map((s) => (s.picture || (s.picture = "/formulaire/public/img/logo.svg"), this.dataToResource({
      _id: "" + s.id,
      icon: s.picture,
      title: s.title,
      ownerName: s.owner_name,
      owner: s.owner_id,
      path: s.is_public ? `${window.location.origin}/formulaire-public#/form/${s.public_key}` : `${window.location.origin}/formulaire#/form/${s.id}/${s.rgpd ? "rgpd" : "new"}`,
      shared: !!(s.shared && s.shared.length >= 0),
      modified: "" + s.date_modification
    })));
  }
}
class ForumBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "forum");
    o(this, "RESOURCE", "forum");
  }
  async loadResources() {
    return (await this.httpGet("/forum/categories")).map(
      (s) => this.dataToResource({
        _id: s._id,
        title: s.name,
        icon: s.icon || "/img/illustrations/forum.svg",
        path: "/forum#/view/" + s._id,
        ownerName: s.owner.displayName,
        owner: s.owner.userId,
        shared: !!(s.shared && s.shared.length >= 0),
        modified: s.modified
      })
    );
  }
}
class HomeworksBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "homeworks");
    o(this, "RESOURCE", "homeworks");
  }
  async loadResources() {
    return (await this.httpGet("/homeworks/list")).filter((t) => t.owner && t.trashed === 0).map((t) => this.dataToResource({
      title: t.title,
      ownerName: t.owner.displayName,
      owner: t.owner.userId,
      icon: t.thumbnail || "/img/illustrations/homeworks.svg",
      path: "/homeworks#/view-homeworks/" + t._id,
      _id: "" + t._id,
      shared: typeof t.shared < "u",
      modified: t.modified
    }));
  }
}
class MagnetoBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "magneto");
    o(this, "RESOURCE", "magneto");
  }
  async loadResources() {
    const { all: t } = await this.httpGet(
      "/magneto/boards/editable"
    );
    return t.map((s) => this.dataToResource({
      _id: s._id,
      title: s.title,
      icon: s.imageUrl,
      owner: s.ownerId,
      ownerName: s.ownerName,
      path: `/magneto#/board/${s._id}/view`,
      shared: !!(s.shared && s.shared.length >= 0),
      modified: "" + s.modificationDate
    }));
  }
}
class MindmapBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "mindmap");
    o(this, "RESOURCE", "mindmap");
  }
  async loadResources() {
    return (await this.httpGet("/mindmap/list/all")).map(
      (s) => this.dataToResource({
        title: s.name,
        ownerName: s.owner.displayName,
        owner: s.owner.userId,
        icon: s.thumbnail || "/img/illustrations/mindmap-default.png",
        path: "/mindmap#/view/" + s._id,
        _id: s._id,
        shared: !!(s.shared && s.shared.length >= 0),
        modified: s.modified
      })
    );
  }
}
class PagesBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "pages");
    o(this, "RESOURCE", "pages");
  }
  async loadResources() {
    const t = await this.httpGet("/pages/list/all"), s = [];
    return t.forEach((r) => {
      var n;
      const i = r.thumbnail ? r.thumbnail + "?thumbnail=48x48" : "/img/illustrations/pages.svg";
      s.push(
        this.dataToResource({
          title: r.title,
          owner: r.owner.userId,
          ownerName: r.owner.displayName,
          icon: i,
          path: "/pages#/website/" + r._id,
          _id: r._id,
          shared: typeof r.shared < "u",
          modified: r.modified
        })
      ), (n = r.pages) == null || n.forEach((a) => {
        s.push(
          this.dataToResource({
            title: a.title,
            owner: r.owner.userId,
            ownerName: r.owner.displayName,
            icon: i,
            path: "/pages#/website/" + r._id + "/" + a.titleLink,
            _id: r._id + "/" + a.titleLink,
            shared: typeof r.shared < "u",
            modified: r.modified
          })
        );
      });
    }), s;
  }
}
class PollBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "poll");
    o(this, "RESOURCE", "poll");
  }
  async loadResources() {
    return (await this.httpGet("/poll/list/all")).map((s) => {
      const r = s.icon ? s.icon + "?thumbnail=48x48" : "/img/icons/glyphicons_036_file.png";
      return this.dataToResource({
        title: s.question,
        ownerName: s.owner.displayName,
        icon: r,
        path: "/poll#/view/" + s._id,
        _id: s._id,
        owner: s.owner.userId,
        shared: !!(s.shared && s.shared.length >= 0),
        modified: s.modified
      });
    });
  }
}
class ScrapbookBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "scrapbook");
    o(this, "RESOURCE", "scrapbook");
  }
  async loadResources() {
    return (await this.httpGet(
      "/scrapbook/list/all"
    )).map((s) => {
      const r = s.icon || "/img/illustrations/scrapbook.svg";
      return this.dataToResource({
        title: s.name,
        owner: s.owner.userId,
        ownerName: s.owner.displayName,
        icon: r,
        path: "/scrapbook#/view-scrapbook/" + s._id,
        _id: s._id,
        shared: !!(s.shared && s.shared.length >= 0),
        modified: s.modified
      });
    });
  }
}
class TimelinegeneratorBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "timelinegenerator");
    o(this, "RESOURCE", "timelinegenerator");
  }
  loadResources() {
    return new Promise(async (t, s) => {
      try {
        const i = (await this.httpGet(
          "/timelinegenerator/timelines"
        )).map((n) => {
          const a = n.icon || "/img/illustrations/timeline-default.png";
          return this.dataToResource({
            title: n.headline,
            ownerName: n.owner.displayName,
            owner: n.owner.userId,
            icon: a,
            path: "/timelinegenerator#/view/" + n._id,
            _id: n._id,
            shared: typeof n.shared < "u",
            modified: n.modified
          });
        });
        t(i);
      } catch (r) {
        s(r);
      }
    });
  }
}
class WikiBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "wiki");
    o(this, "RESOURCE", "wiki");
  }
  async loadResources() {
    return (await this.httpGet(
      "/wiki/listallpages?visible=true"
    )).map((s) => s.pages.map((r) => {
      let i;
      return typeof s.thumbnail > "u" || s.thumbnail === "" ? i = "/img/icons/glyphicons_036_file.png" : i = s.thumbnail + "?thumbnail=48x48", this.dataToResource({
        title: r.title + " [" + s.title + "]",
        ownerName: s.owner.displayName,
        owner: s.owner.userId,
        icon: i,
        path: "/wiki#/view/" + s._id + "/" + r._id,
        _id: `${s._id}#${r._id}`,
        shared: typeof s.shared < "u",
        modified: r.modified
      });
    })).flat();
  }
}
class WorkspaceBehaviour extends AbstractBehaviourService {
  constructor() {
    super(...arguments);
    o(this, "APP", "workspace");
    o(this, "RESOURCE", "workspace");
  }
  loadResources({ search: t, asset_id: s }) {
    return new Promise(async (r, i) => {
      try {
        let n = "/workspace/documents?filter=all&hierarchical=true";
        s && s.length ? n += `&search=${t}` : t && t.length && (n += `&search=${t}`);
        const c = (await this.httpGet(n)).filter((h) => !h.deleted).map((h) => {
          const l = h.metadata["content-type"] && h.metadata["content-type"].indexOf("image") !== -1 ? `/workspace/document/${h._id}?thumbnail=120x120` : "/img/icons/unknown-large.png";
          return this.dataToResource({
            title: h.name,
            ownerName: h.ownerName,
            owner: h.owner,
            icon: l,
            path: `/workspace/document/${h._id}`,
            _id: h._id,
            shared: !!(h.shared && h.shared.length >= 0),
            modified: h.modified
          });
        });
        r(c);
      } catch (n) {
        i(n);
      }
    });
  }
}
const y = class y {
  static async initialize(e, t) {
    const s = e.http();
    if (!this.resourceProducingApps.length) {
      this.resourceProducingApps = [t, "workspace"];
      try {
        const [r, i] = await Promise.all([
          s.get("/resources-applications"),
          e.session().getUser()
        ]);
        i != null && i.apps && (r != null && r.length) && (this.resourceProducingApps = r.filter(
          (n) => i.apps.some((a) => a.address.includes(n))
        ));
      } catch (r) {
        console.warn("Failed to load resource-producing apps:", r);
      }
    }
    return this.resourceProducingApps;
  }
  static async registerBehaviours(e) {
    this.resourceProducingApps.forEach((t) => {
      const s = { application: e, resourceType: t };
      this.registry.register(
        s,
        (r) => this.serviceFor(r, e, t)
      );
    });
  }
  static serviceFor(e, t, s) {
    let r;
    switch (s) {
      case "timelinegenerator":
        r = new TimelinegeneratorBehaviour(e);
        break;
      case "workspace":
        r = new WorkspaceBehaviour(e);
        break;
      case "blog":
        r = new BlogBehaviour(e);
        break;
      case "actualites":
        r = new ActualitesBehaviour(e);
        break;
      case "wiki":
        r = new WikiBehaviour(e);
        break;
      case "pages":
        r = new PagesBehaviour(e);
        break;
      case "poll":
        r = new PollBehaviour(e);
        break;
      case "community":
        r = new CommunityBehaviour(e);
        break;
      case "mindmap":
        r = new MindmapBehaviour(e);
        break;
      case "forum":
        r = new ForumBehaviour(e);
        break;
      case "homeworks":
        r = new HomeworksBehaviour(e);
        break;
      case "scrapbook":
        r = new ScrapbookBehaviour(e);
        break;
      case "collaborativewall":
        r = new CollaborativewallBehaviour(e);
        break;
      case "exercizer":
        r = new ExercizerBehaviour(e);
        break;
      case "formulaire":
        r = new FormulaireBehaviour(e);
        break;
      case "magneto":
        r = new MagnetoBehaviour(e);
        break;
      default:
        throw ERROR_CODE.NOT_SUPPORTED;
    }
    return r.APP = t, r;
  }
};
//
// STATIC REGISTRY
//
o(y, "registry", new ServiceRegistry()), // Expose some useful functions
o(y, "findBehaviour", y.registry.findService.bind(y.registry)), o(y, "hasBehaviour", y.registry.isRegistered.bind(y.registry)), o(y, "resourceProducingApps", []);
let SnipletsService = y;
const SEND_ALL = "*";
class WebBroker {
  constructor(e) {
    o(this, "subscription");
    this.odeServices = e;
  }
  get http() {
    return this.odeServices.http();
  }
  get events() {
    return this.odeServices.notify().events();
  }
  dispatchEvent(e, t) {
    t.findIndex(
      (r) => SEND_ALL === r || e.data["event-type"] === r
    ) >= 0 && this.http.post("/infra/event/web/store", e.data, {
      disableNotifications: !0
    });
  }
  initialize(e) {
    if (e === void 0 || e.send === void 0 || e.send.length > 0) {
      const t = (e == null ? void 0 : e.send) ?? [SEND_ALL];
      this.subscription = this.events.subscribe(
        LAYER_NAME.WEB_DATA,
        (s) => this.dispatchEvent(s, t)
      );
    }
    return this;
  }
  destroy() {
    this.subscription && (this.subscription.revoke(), delete this.subscription);
  }
}
class DataService {
  constructor(e) {
    o(this, "_webBroker");
    o(this, "app");
    o(this, "user");
    o(this, "profile");
    this.odeServices = e;
  }
  get conf() {
    return this.odeServices.conf();
  }
  get notify() {
    return this.odeServices.notify();
  }
  // This method is called once, by the service container.
  async initialize() {
    try {
      const { app: e } = await this.notify.onAppConfReady().promise;
      this.app = e, this.user = await this.odeServices.session().getUser(), this.profile = await this.odeServices.session().getUserProfile();
      const { ["data-service"]: t } = await this.conf.getPublicConf(e);
      this._webBroker = new WebBroker(this.odeServices).initialize(t == null ? void 0 : t.web);
    } catch {
      console.log("DataService not initialized, usage data unavailable.");
    }
  }
  //FIXME When to call that ??
  predestroy() {
    this._webBroker && (this._webBroker.destroy(), delete this._webBroker);
  }
  /** Send a web-user-level event to the data pipeline. */
  trackWebEvent(e) {
    this.notify.events().publish(LAYER_NAME.WEB_DATA, {
      name: EVENT_NAME.DATA_TRACKED,
      data: e
    });
  }
  addUserInfos(e) {
    return this.user && (e.userId = this.user.userId, e.structure = this.user.structureNames[0]), this.profile && (e.profil = this.profile[0]), e;
  }
  trackVideoSave(e, t, s, r, i, n, a) {
    const c = this.addUserInfos({
      "event-type": "VIDEO_SAVE",
      module: "video",
      video_id: e,
      browser: n,
      duration: Math.round(t),
      weight: s,
      source: r ? "CAPTURED" : "UPLOADED",
      url: i
    });
    this.app && (c["override-module"] = this.app), a && (c.device_type = a), this.trackWebEvent(c);
  }
  trackVideoRead(e, t, s, r, i) {
    const n = this.addUserInfos({
      "event-type": "VIDEO_READ",
      module: "video",
      video_id: e,
      browser: r,
      source: t ? "CAPTURED" : "UPLOADED",
      url: s
    });
    this.app && (n["override-module"] = this.app), i && (n.device_type = i), this.trackWebEvent(n);
  }
  trackSpeechAndText(e) {
    const t = this.addUserInfos({
      "event-type": "SPEECH_AND_TEXT",
      function: e
    });
    this.app && (t.module = this.app), this.trackWebEvent(t);
  }
  trackAccessLibraryFromExplorer() {
    const e = this.addUserInfos({
      "event-type": "ACCESS_LIBRARY_FROM_EXPLORER"
    });
    this.app && (e.module = this.app), this.trackWebEvent(e);
  }
}
class ReactionsService {
  constructor(e, t, s) {
    this.context = e, this.module = t, this.resourceType = s;
  }
  get http() {
    return this.context.http();
  }
  async loadAvailableReactions() {
    try {
      const { "reaction-types": e } = await this.context.conf().getPublicConf("audience");
      return Array.isArray(e) ? e : void 0;
    } catch {
      console.error("Audience configuration not found");
      return;
    }
  }
  async loadReactionSummaries(e) {
    const t = await this.http.get(
      `/audience/reactions/${this.module}/${this.resourceType}?resourceIds=${e.join(",")}`
    );
    return this.http.isResponseError() ? {} : t.reactionsByResource;
  }
  async loadReactionDetails(e, t, s) {
    const r = await this.http.get(
      `/audience/reactions/${this.module}/${this.resourceType}/${e}?page=${t}&size=${s}`
    );
    return this.http.isResponseError() ? void 0 : r;
  }
  async deleteReaction(e) {
    await this.http.delete(
      `/audience/reactions/${this.module}/${this.resourceType}/${e}`
    );
  }
  async updateReaction(e, t) {
    await this.http.putJson(
      `/audience/reactions/${this.module}/${this.resourceType}`,
      {
        resourceId: e,
        reactionType: t
      }
    );
  }
  async createReaction(e, t) {
    await this.http.postJson(
      `/audience/reactions/${this.module}/${this.resourceType}`,
      {
        resourceId: e,
        reactionType: t
      }
    );
  }
}
class ViewsService {
  constructor(e, t, s) {
    this.context = e, this.module = t, this.resourceType = s;
  }
  get http() {
    return this.context.http();
  }
  async getCounters(e) {
    const t = await this.http.get(
      `/audience/views/count/${this.module}/${this.resourceType}?resourceIds=${e.join(",")}`
    );
    return this.http.isResponseError() ? {} : t;
  }
  async getDetails(e) {
    const t = await this.http.get(
      `/audience/views/details/${this.module}/${this.resourceType}/${e}`
    );
    return this.http.isResponseError() ? void 0 : t;
  }
  trigger(e) {
    return this.http.post(
      `/audience/views/${this.module}/${this.resourceType}/${e}`
    );
  }
}
class AudienceService {
  constructor(e, t, s) {
    this.context = e, this.module = t, this.resourceType = s;
  }
  get views() {
    return new ViewsService(this.context, this.module, this.resourceType);
  }
  get reactions() {
    return new ReactionsService(this.context, this.module, this.resourceType);
  }
}
class OdeServices {
  constructor() {
    o(this, "_analytics");
    o(this, "_cache");
    o(this, "_conf");
    o(this, "_data");
    o(this, "_directory");
    o(this, "_http");
    o(this, "_idiom");
    o(this, "_notify");
    o(this, "_rights");
    o(this, "_session");
    o(this, "_share");
    o(this, "_video");
    o(this, "_workspace");
    o(this, "_embedder");
    this._analytics = new AnalyticsService(this), this._cache = new CacheService(this), this._conf = new ConfService(this), this._data = new DataService(this), this._directory = new DirectoryService(this), this._http = new HttpService(this), this._idiom = new IdiomService(this), this._notify = NotifyFrameworkFactory.instance(), this._rights = new RightService(this), this._session = new SessionService(this), this._share = new ShareService(this), this._video = new VideoService(this), this._workspace = new WorkspaceService(this), this._embedder = new EmbedderService(this);
  }
  initialize() {
    return this._data.initialize(), this;
  }
  analytics() {
    return this._analytics;
  }
  audience(e, t) {
    return new AudienceService(this, e, t);
  }
  cache() {
    return this._cache;
  }
  conf() {
    return this._conf;
  }
  data() {
    return this._data;
  }
  directory() {
    return this._directory;
  }
  http() {
    return this._http;
  }
  idiom() {
    return this._idiom;
  }
  notify() {
    return this._notify;
  }
  resource(e, t) {
    return t ? ResourceService.findService({ application: e, resourceType: t }, this) : ResourceService.findMainService({ application: e }, this);
  }
  behaviour(e, t) {
    return SnipletsService.findBehaviour({ application: e, resourceType: t }, this);
  }
  rights() {
    return this._rights;
  }
  session() {
    return this._session;
  }
  share() {
    return this._share;
  }
  video() {
    return this._video;
  }
  workspace() {
    return this._workspace;
  }
  embedder() {
    return this._embedder;
  }
}
const ACTION = {
  SEARCH: "search",
  CREATE: "create",
  CREATE_PUBLIC: "createPublic",
  OPEN: "open",
  EDIT: "edit",
  MANAGE: "manage",
  // Query properties metadata
  UPD_PROPS: "properties",
  // Update properties
  COMMENT: "comment",
  DELETE: "delete",
  TRASH: "trash",
  RESTORE: "restore",
  MOVE: "move",
  COPY: "copy",
  EXPORT: "export",
  SHARE: "share",
  PRINT: "print",
  /* FIXME only core actions here ! */
  PAGES_LIST: "pages_list",
  DISTRIBUTE: "distribute",
  REGISTER: "register",
  PUBLISH: "publish",
  PUBLISH_MOODLE: "publish_moodle"
}, FOLDER = {
  /** Special ID of the bin, or trash folder. */
  BIN: "bin",
  /** Special ID of the root folder. */
  DEFAULT: "default"
}, BOOLEAN_FILTER = {
  OWNER: "owner",
  SHARED: "shared",
  PUBLIC: "public",
  FAVORITE: "favorite"
}, SORT_ORDER = {
  ASC: "asc",
  DESC: "desc"
}, SORT_BY = {
  NAME: "name",
  MODIFY_DATE: "updatedAt",
  CREATED_AT: "createdAt",
  APPLICATION: "application",
  RESOURCE_TYPE: "resourceType"
  /*
  //FIXME On devrait pouvoir trier sur tout champ issu d'un type de ressource (name, createdAt, creatorId...) voir IResource
    createdAt: string;
    creatorId: string;
    authorName: string;
    modifierId: ID;
    modifierName: string;
    modifiedAt: string;
    public?: boolean;
    shared?: boolean;
    favorite?: boolean;
    comments?: number;
  */
}, odeServices = new OdeServices().initialize();
class SessionFrameworkFactory {
  //-------------------------------------
  static instance() {
    return session;
  }
}
const WIDGET_POSITION = {
  LEFT: "left",
  RIGHT: "right"
  // TODO: position pourrait être étendu à d'autres valeurs: |“top” ou “bottom” ou “fixed”...
};
class TransportFrameworkFactory {
  //-------------------------------------
  static instance() {
    return transport;
  }
}
const isActionAvailable = (u, e) => {
  const t = e == null ? void 0 : e.filter(
    (s) => s.id === u && s.available
  );
  return t && t.length > 0;
}, firstLevelWidgets = [
  "birthday",
  "mood",
  "calendar-widget",
  "notes"
], secondLevelWidgets = [
  "agenda-widget",
  "carnet-de-bord",
  "my-apps",
  "rss-widget",
  "bookmark-widget",
  "cursus-widget",
  "maxicours-widget",
  "school-widget"
], defaultWidgetPosition = {
  "last-infos-widget": WIDGET_POSITION.LEFT,
  // Actualités
  birthday: WIDGET_POSITION.LEFT,
  "calendar-widget": WIDGET_POSITION.RIGHT,
  // Calendrier
  "carnet-de-bord": WIDGET_POSITION.LEFT,
  "record-me": WIDGET_POSITION.RIGHT,
  // Dictaphone
  mood: WIDGET_POSITION.LEFT,
  "my-apps": WIDGET_POSITION.RIGHT,
  notes: WIDGET_POSITION.RIGHT,
  "rss-widget": WIDGET_POSITION.LEFT,
  "bookmark-widget": WIDGET_POSITION.RIGHT,
  qwant: WIDGET_POSITION.RIGHT,
  "qwant-junior": WIDGET_POSITION.LEFT,
  "agenda-widget": WIDGET_POSITION.LEFT,
  // Agenda
  "cursus-widget": WIDGET_POSITION.LEFT,
  "maxicours-widget": WIDGET_POSITION.RIGHT,
  "universalis-widget": WIDGET_POSITION.RIGHT,
  "briefme-widget": WIDGET_POSITION.LEFT,
  "school-widget": WIDGET_POSITION.LEFT
}, defaultWidgetOrder = {
  "school-widget": 0,
  "my-apps": 10,
  "record-me": 15,
  "last-infos-widget": 20,
  // Actualités
  qwant: 30,
  "qwant-junior": 30,
  "universalis-widget": 35,
  "agenda-widget": 40,
  // Agenda
  "bookmark-widget": 50,
  "carnet-de-bord": 60,
  "maxicours-widget": 70,
  "cursus-widget": 80,
  // Dictaphone
  "briefme-widget": 90,
  "rss-widget": 100,
  mood: 110,
  birthday: 120,
  "calendar-widget": 130,
  // Calendrier
  notes: 140
};
class WidgetFramework {
  constructor() {
    //-------------------------------------
    o(this, "_initialized");
    o(this, "_widgets", []);
    ////////////////////////////////////// USER PREFERENCES
    o(this, "_userPrefs", {});
  }
  initialize(e, t) {
    return this._initialized || (this._initialized = new Promisified(), notify.onSessionReady().promise.then((s) => {
      var r;
      s && s.widgets ? (s.widgets.forEach((i) => {
        this._widgets.push(new Widget(i));
      }), this.loadUserPrefs().then(() => {
        var i;
        (i = this._initialized) == null || i.resolve();
      }).catch((i) => {
        var n;
        (n = this._initialized) == null || n.reject();
      })) : (r = this._initialized) == null || r.reject();
    })), this._initialized.promise;
  }
  ////////////////////////////////////// ACCESSORS
  get list() {
    return this._widgets;
  }
  lookup(e) {
    return this._widgets.find((t) => t.platformConf.name === e);
  }
  lookupDefaultPosition(e) {
    return defaultWidgetPosition[e];
  }
  get userPrefs() {
    return this._userPrefs;
  }
  async loadUserPrefs() {
    await configure.User.preferences.load("widgets", {}).then((e) => this.applyUserPrefs(e));
  }
  saveUserPrefs() {
    return configure.User.preferences.update("widgets", this._userPrefs).save("widgets").then(() => {
      notify.events().publish(LAYER_NAME.WIDGETS, {
        name: EVENT_NAME.USERPREF_CHANGED
      });
    });
  }
  async applyUserPrefs(e) {
    this._userPrefs = e ?? this._userPrefs;
    const t = configure.Platform.theme, s = [];
    t.listSkins().then((r) => {
      var a;
      const i = ((a = r.find((c) => c.child === t.skin)) == null ? void 0 : a.parent) === "panda" ? secondLevelWidgets : firstLevelWidgets;
      this._widgets = this._widgets.filter((c, h) => {
        const l = c.platformConf.name;
        return i.indexOf(l) !== -1 ? !1 : (this._userPrefs[l] || (this._userPrefs[l] = {
          index: defaultWidgetOrder[l] ?? 999,
          show: !0,
          position: c.platformConf.position
        }), c.platformConf.mandatory && (this._userPrefs[l].show = !0, this._userPrefs[l].index = defaultWidgetOrder[l] ?? 999), c.platformConf.i18n && s.push(c.platformConf.i18n), c.applyUserPref(this._userPrefs[l]), !0);
      });
      const n = new Idiom();
      this._widgets = this._widgets.sort((c, h) => {
        const l = n.translate(`timeline.settings.${c.platformConf.name}`).toLowerCase(), E = n.translate(`timeline.settings.${h.platformConf.name}`).toLowerCase();
        return l < E ? -1 : l > E ? 1 : 0;
      });
    });
  }
}
class Widget {
  //-------------------------------------
  constructor(e) {
    o(this, "_schoolConf", {});
    o(this, "_userPref");
    this._platformConf = e, this._userPref = null;
  }
  get platformConf() {
    return this._platformConf;
  }
  get schoolConf() {
    return this._schoolConf;
  }
  get userPref() {
    return this._userPref;
  }
  applyUserPref(e) {
    this._userPref = e, this._userPref.position = this._userPref.position ?? widgets.lookupDefaultPosition(this._platformConf.name) ?? "left";
  }
}
const widgets = new WidgetFramework();
class LastInfosWidget {
  loadInfos(e) {
    return transport.http.get("/actualites/infos/last/" + e);
  }
  getMaxResults() {
    return transport.http.get("/userbook/preference/maxInfos").then((e) => e.preference ? parseInt(e.preference) : 4);
  }
  setMaxResults(e) {
    return transport.http.putJson(
      "/userbook/preference/maxInfos",
      `"${e}"`
    );
  }
}
const WIDGET_NAME = {
  LAST_INFOS: "last-infos-widget",
  BIRTHDAY: "birthday",
  CALENDAR: "calendar-widget",
  CARNET: "carnet-de-bord",
  RECORD: "record-me",
  MOOD: "mood",
  MY_APPS: "my-apps",
  NOTES: "notes",
  RSS: "rss-widget",
  BOOKMARK: "bookmark-widget",
  QWANT: "qwant",
  QWANT_JUNIOR: "qwant-junior",
  AGENDA: "agenda-widget",
  CURSUS: "cursus-widget",
  MAXICOURS: "maxicours-widget",
  UNIVERSALIS: "universalis-widget",
  BRIEFME: "briefme-widget",
  SCHOOL: "school-widget"
};
class WidgetFrameworkFactory {
  //-------------------------------------
  static instance() {
    return widgets;
  }
}
export {
  ACTION,
  APP$3 as APP,
  BOOLEAN_FILTER,
  ConfigurationFrameworkFactory,
  DocumentHelper,
  ERROR_CODE,
  EVENT_NAME,
  FOLDER,
  ITimelineFactory,
  LAYER_NAME,
  LastInfosWidget,
  NotifyFrameworkFactory,
  ReactionTypes,
  ResourceService,
  SORT_BY,
  SORT_ORDER,
  SessionFrameworkFactory,
  SnipletsService,
  StringUtils,
  TransportFrameworkFactory,
  USER_PREFS,
  WIDGET_NAME,
  WIDGET_POSITION,
  WidgetFrameworkFactory,
  isActionAvailable,
  odeServices
};
