{"version":3,"sources":["../src/htmlparser.ts","../src/vdomparser.ts","../src/manipulate.ts","../src/serialize-markdown.ts","../src/tidy.ts","../src/serialize-plaintext.ts","../src/serialize-safehtml.ts","../src/xml.ts"],"sourcesContent":["// Taken from https://github.com/creeperyang/html-parser-lite\n// and slightly modified. Original also under MIT license. Thanks.\n\n// attribute, like href=\"javascript:void(0)\"\n// 1. start with name (not empty and not =)\n// 2. and then \\s*=\\s*\n// 3. and value can be \"value\" | 'value' | value\n// 4. 2 and 3 are optional\nconst attrRe = /([^=\\s]+)(\\s*=\\s*((\"([^\"]*)\")|('([^']*)')|[^>\\s]+))?/g\nconst endTagRe = /^<\\/([^>\\s]+)[^>]*>/m\n// start tag, like <a href=\"link\"> <img/>\n// 1. must start with <tagName\n// 2. optional attrbutes\n// 3. /> or >\nconst startTagRe = /^<([^>\\s/]+)((\\s+[^=>\\s]+(\\s*=\\s*((\"[^\"]*\")|('[^']*')|[^>\\s]+))?)*)\\s*(?:\\/\\s*)?>/m\nconst selfCloseTagRe = /\\s*\\/\\s*>\\s*$/m\n\n/**\n * This is a simple html parser. Will read and parse html string.\n *\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\nexport class HtmlParser {\n  scanner: any\n  options: any\n  attrRe = attrRe\n  endTagRe = endTagRe\n  startTagRe = startTagRe\n  defaults = { ignoreWhitespaceText: false }\n\n  constructor(options: {\n    scanner?: any\n    ignoreWhitespaceText?: boolean\n  } = {}) {\n    if (options.scanner)\n      this.scanner = options.scanner\n    this.options = Object.assign({}, this.defaults, options)\n  }\n\n  parse(html: string) {\n    let treatAsChars = false\n    let index, match, characters\n    while (html.length) {\n      // comment\n      if (html.substring(0, 4) === '<!--') {\n        index = html.indexOf('-->')\n        if (index !== -1) {\n          this.scanner.comment(html.substring(4, index))\n          html = html.substring(index + 3)\n          treatAsChars = false\n        }\n        else {\n          treatAsChars = true\n        }\n      }\n\n      // end tag\n      else if (html.substring(0, 2) === '</') {\n        match = this.endTagRe.exec(html)\n        if (match) {\n          html = RegExp.rightContext\n          treatAsChars = false\n          this.parseEndTag(RegExp.lastMatch, match[1])\n        }\n        else {\n          treatAsChars = true\n        }\n      }\n\n      // start tag\n      else if (html.charAt(0) === '<') {\n        match = this.startTagRe.exec(html)\n        if (match) {\n          html = RegExp.rightContext\n          treatAsChars = false\n          const tagName = this.parseStartTag(RegExp.lastMatch, match[1], match)\n          if (tagName === 'script' || tagName === 'style') {\n            index = html.search(new RegExp(`<\\/${tagName}`, 'i'))\n            if (index !== -1) {\n              this.scanner.characters(html.substring(0, index))\n              html = html.substring(index)\n              treatAsChars = false\n            }\n            else {\n              treatAsChars = true\n            }\n          }\n        }\n        else {\n          treatAsChars = true\n        }\n      }\n\n      if (treatAsChars) {\n        index = html.indexOf('<')\n        let offset = index\n\n        if (index === 0) {\n          // First char is a < so find the next one\n          index = html.substring(1).indexOf('<')\n          // We're at substring(1) so add 1 to the index\n          offset = offset + 1\n        }\n\n        if (index === -1) {\n          characters = html\n          html = ''\n        }\n        else {\n          characters = html.substring(0, offset)\n          html = html.substring(offset)\n        }\n\n        if (!this.options.ignoreWhitespaceText || !/^\\s*$/.test(characters))\n          this.scanner.characters(characters)\n      }\n\n      treatAsChars = true\n      match = null\n    }\n  }\n\n  parseStartTag(input: string, tagName: string, match: any) {\n    const isSelfColse = selfCloseTagRe.test(input)\n    let attrInput = match[2]\n    if (isSelfColse)\n      attrInput = attrInput.replace(/\\s*\\/\\s*$/, '')\n    const attrs = this.parseAttributes(tagName, attrInput)\n    this.scanner.startElement(tagName, attrs, isSelfColse, match[0])\n    return tagName.toLocaleLowerCase()\n  }\n\n  parseEndTag(input: string, tagName: string) {\n    this.scanner.endElement(tagName)\n  }\n\n  parseAttributes(tagName: string, input: string) {\n    const attrs: Record<string, any> = {}\n    input.replace(this.attrRe, (...m: any[]) => {\n      const [_attr, name, _c2, value, _c4, valueInQuote, _c6, valueInSingleQuote] = m\n      attrs[name] = valueInSingleQuote ?? valueInQuote ?? value ?? true\n      return undefined as any // hack\n    })\n    return attrs\n  }\n}\n","/* eslint-disable node/prefer-global/buffer */\n\nimport { unescapeHTML } from './encoding'\nimport { SELF_CLOSING_TAGS } from './html'\nimport { HtmlParser } from './htmlparser'\nimport { hasOwn } from './utils'\nimport { document, VDocType, VDocumentFragment, VElement, VHTMLDocument, VNode, VTextNode } from './vdom'\n\n// Makes sure we operate on VNodes\nexport function vdom(obj: VNode | Buffer | string | null = null): VNode {\n  if (obj instanceof VNode)\n    return obj\n\n  if (obj instanceof Buffer)\n    obj = obj.toString('utf-8')\n\n  if (typeof obj === 'string')\n    return parseHTML(obj)\n\n  // console.warn('Cannot convert to VDOM:', obj)\n  return new VDocumentFragment()\n}\n\nexport function parseHTML(html: string): VDocumentFragment | VHTMLDocument {\n  if (typeof html !== 'string') {\n    console.error('parseHTML requires string, found', html)\n    throw new Error('parseHTML requires string')\n  }\n\n  const frag\n    = html.indexOf('<!') === 0 ? new VHTMLDocument(true) : new VDocumentFragment() // !hack\n\n  const stack: VNode[] = [frag]\n\n  const parser = new HtmlParser({\n    // the for methods must be implemented yourself\n    scanner: {\n      startElement(\n        tagName: string,\n        attrs: Record<string, string>,\n        isSelfClosing: boolean,\n      ) {\n        const lowerTagName = tagName.toLowerCase()\n\n        if (lowerTagName === '!doctype') {\n          frag.docType = new VDocType()\n          return\n        }\n\n        for (const name in attrs) {\n          if (hasOwn(attrs, name)) {\n            const value = attrs[name]\n            // console.log(name, value)\n            if (typeof value === 'string')\n              attrs[name] = unescapeHTML(value)\n          }\n        }\n        const parentNode = stack[stack.length - 1]\n        if (parentNode) {\n          const element = document.createElement(tagName, attrs)\n          parentNode.appendChild(element)\n          if (\n            !(\n              SELF_CLOSING_TAGS.includes(tagName.toLowerCase()) || isSelfClosing\n            )\n          ) {\n            stack.push(element)\n          }\n        }\n      },\n      endElement(_tagName: string) {\n        stack.pop()\n      },\n      characters(text: string) {\n        text = unescapeHTML(text)\n        const parentNode = stack[stack.length - 1]\n        if (parentNode?.lastChild?.nodeType === VNode.TEXT_NODE) {\n          parentNode.lastChild._text += text\n        }\n        else {\n          if (parentNode)\n            parentNode.appendChild(new VTextNode(text))\n            // } else {\n            //   console.trace(parentNode, stack)\n        }\n      },\n      comment(_text: string) {},\n    },\n  })\n  parser.parse(html)\n  // console.log(\"frag\", frag)\n  return frag\n}\n\n// export function parseHTML2(html) {\n//   let frag = new VDocumentFragment()\n//\n//   let stack = [frag]\n//   let currentElement = frag\n//\n//   let parser = new Parser({\n//     onopentag: (name, attrs) => {\n//       let element = document.createElement(name, attrs)\n//       stack.push(element)\n//       currentElement.appendChild(element)\n//       currentElement = element\n//     },\n//     ontext: function (text) {\n//       if (currentElement?.lastChild?.nodeType === VNode.TEXT_NODE) {\n//         currentElement.lastChild._text += text\n//       } else {\n//         currentElement.appendChild(new VTextNode(text))\n//       }\n//     },\n//     onclosetag: function (name) {\n//       let element = stack.pop()\n//       currentElement = stack[stack.length - 1]\n//       // if (element.nodeName !== currentElement.nodeName) {\n//       //   console.log('error', element, currentElement)\n//       // }\n//     },\n//   }, { decodeEntities: true })\n//   parser.write(html)\n//   parser.end()\n//\n//   // console.log('frag', frag.innerHTML)\n//\n//   return frag\n// }\n\nVElement.prototype.setInnerHTML = function (html) {\n  const frag = parseHTML(html)\n  this._childNodes = frag._childNodes\n  this._fixChildNodesParent()\n}\n","import type { VDocumentFragment, VHTMLDocument } from './vdom'\nimport { parseHTML } from './vdomparser'\n\nexport function handleHTML(html: string, handler: (document: VHTMLDocument | VDocumentFragment) => void) {\n  const document = parseHTML(html)\n  handler(document)\n  return document.render()\n}\n","import type { VElement } from './vdom'\nimport { isVElement, VNode } from './vdom'\n\ninterface SerializeContext {\n  level: number\n  count: 0\n  mode?: 'ol' | 'ul'\n}\n\nfunction serialize(node: VNode | VElement, context: SerializeContext = {\n  level: 0,\n  count: 0,\n}): string {\n  if (node.nodeType === VNode.DOCUMENT_FRAGMENT_NODE) {\n    return node.children.map(c => serialize(c, { ...context })).join('')\n  }\n\n  else if (isVElement(node)) {\n    const tag: string = node.tagName.toLowerCase()\n\n    const handleChildren = (ctx?: Partial<SerializeContext>): string => node.children.map(c => serialize(c, { ...context, ...ctx })).join('')\n\n    const rules: Record<string, () => string> = {\n      b: () => `**${handleChildren()}**`,\n      strong: () => `**${handleChildren()}**`,\n      i: () => `*${handleChildren()}*`,\n      em: () => `*${handleChildren()}*`,\n      u: () => `<u>${handleChildren()}</u>`,\n      mark: () => `==${handleChildren()}==`,\n      tt: () => `==${handleChildren()}==`,\n      code: () => `==${handleChildren()}==`,\n      strike: () => `~~${handleChildren()}~~`,\n      sub: () => `~${handleChildren()}~`,\n      super: () => `^${handleChildren()}^`,\n      sup: () => `^${handleChildren()}^`,\n      li: () => `- ${handleChildren()}\\n`, // todo numbered\n      br: () => `${handleChildren()}\\n`,\n      ol: () => `\\n\\n${handleChildren({ level: context.level + 1 })}\\n\\n`, // todo indent\n      ul: () => `\\n\\n${handleChildren({ level: context.level + 1 })}\\n\\n`, // todo indent\n      blockquote: () => `\\n\\n> ${handleChildren()}\\n\\n`, // todo continue '>'\n      pre: () => `\\n\\n\\`\\`\\`\\n${handleChildren()}\\n\\`\\`\\`\\n\\n`,\n      p: () => `\\n\\n${handleChildren()}\\n\\n`,\n      div: () => `\\n\\n${handleChildren()}\\n\\n`,\n      h1: () => `\\n\\n# ${handleChildren()}\\n\\n`,\n      h2: () => `\\n\\n## ${handleChildren()}\\n\\n`,\n      h3: () => `\\n\\n### ${handleChildren()}\\n\\n`,\n      h4: () => `\\n\\n#### ${handleChildren()}\\n\\n`,\n      h5: () => `\\n\\n##### ${handleChildren()}\\n\\n`,\n      h6: () => `\\n\\n###### ${handleChildren()}\\n\\n`,\n      hr: () => `\\n\\n---\\n\\n`,\n      a: () => `[${handleChildren()}](${node.getAttribute('href') ?? '#'})`,\n      img: () => `![${node.getAttribute('alt') ?? ''}](${node.getAttribute('src') ?? ''})`,\n\n      // todo audio, video and other HTML stuff\n    }\n\n    const fn = rules[tag]\n\n    if (fn)\n      return fn()\n    else\n      return handleChildren()\n  }\n  return node.textContent ?? ''\n}\n\nexport function serializeMarkdown(node: VNode): string {\n  return `${serialize(node).replace(/\\n{2,}/g, '\\n\\n').trim()}\\n`\n}\n","import type { VDocument } from './vdom'\nimport { VNode, VTextNode } from './vdom'\n\nexport const SELECTOR_BLOCK_ELEMENTS = 'meta,link,script,p,h1,h2,h3,h4,h5,h6,blockquote,div,ul,ol,li,article,section,footer,head,body,title,nav,hr,form'\nexport const TAGS_KEEP_CONTENT = ['PRE', 'CODE', 'SCRIPT', 'STYLE', 'TT']\n\nfunction level(element: VNode): string {\n  let indent = ''\n  while (element.parentNode) {\n    indent += '  '\n    element = element.parentNode\n  }\n  return indent.substr(2)\n}\n\nexport function tidyDOM(document: VDocument) {\n  document.handle(SELECTOR_BLOCK_ELEMENTS, (e) => {\n    // Ignore if inside PRE etc.\n    let ee = e\n    while (ee) {\n      if (TAGS_KEEP_CONTENT.includes(ee.tagName))\n        return\n      ee = ee.parentNode\n    }\n\n    const prev = e.previousSibling\n    if (\n      !prev\n      || prev.nodeType !== VNode.TEXT_NODE\n      || !prev.nodeValue?.endsWith('\\n')\n    ) {\n      e.parentNode?.insertBefore(new VTextNode('\\n'), e)\n    }\n\n    e.parentNode?.insertBefore(new VTextNode(level(e)), e)\n\n    const next = e.nextSibling\n    if (\n      !next\n      || next.nodeType !== VNode.TEXT_NODE\n      || !next.nodeValue?.startsWith('\\n')\n    ) {\n      if (next)\n        e.parentNode?.insertBefore(new VTextNode('\\n'), next)\n      else\n        e.parentNode?.appendChild(new VTextNode('\\n'))\n    }\n\n    if (e.childNodes.length) {\n      const first = e.firstChild\n      if (first.nodeType === VNode.TEXT_NODE)\n        e.insertBefore(new VTextNode(`\\n${level(e)}  `))\n\n      e.appendChild(new VTextNode(`\\n${level(e)}`))\n    }\n  })\n}\n","import type { VElement } from './vdom'\nimport { SELECTOR_BLOCK_ELEMENTS } from './tidy'\nimport { isVElement, VNode } from './vdom'\n\ninterface SerializeContext {\n  level: number\n  count: 0\n  mode?: 'ol' | 'ul'\n}\n\nfunction serialize(node: VNode | VElement, context: SerializeContext = {\n  level: 0,\n  count: 0,\n}): string {\n  if (node.nodeType === VNode.DOCUMENT_FRAGMENT_NODE) {\n    return node.children.map(c => serialize(c, { ...context })).join('')\n  }\n\n  else if (isVElement(node)) {\n    const tag: string = node.tagName.toLowerCase()\n\n    const handleChildren = (ctx?: Partial<SerializeContext>): string => node.children.map(c => serialize(c, { ...context, ...ctx })).join('')\n\n    const rules: Record<string, () => string> = {\n      br: () => `${handleChildren()}\\n`,\n      title: () => '',\n      script: () => '',\n      style: () => '',\n    }\n\n    SELECTOR_BLOCK_ELEMENTS.split(',').forEach((tag) => {\n      rules[tag] = () => `\\n\\n${handleChildren().trim()}\\n\\n`\n    })\n\n    const fn = rules[tag]\n\n    if (fn)\n      return fn()\n    else\n      return handleChildren()\n  }\n  return node.textContent ?? ''\n}\n\nexport function serializePlaintext(node: VNode): string {\n  return `${serialize(node).replace(/\\n{2,}/g, '\\n\\n').trim()}\\n`\n}\n","import { escapeHTML } from './encoding'\nimport { isVElement, VNode } from './vdom'\nimport { parseHTML } from './vdomparser'\n\nexport const SELECTOR_BLOCK_ELEMENTS = 'p,h1,h2,h3,h4,h5,h6,blockquote,div,ul,ol,li,article,section,footer,nav,hr,form'\n\ninterface SerializeContext {\n  level: number\n  count: 0\n  mode?: 'ol' | 'ul'\n}\n\nfunction serialize(node: VNode, context: SerializeContext = {\n  level: 0,\n  count: 0,\n}): string {\n  if (node.nodeType === VNode.DOCUMENT_FRAGMENT_NODE) {\n    return node.children.map(c => serialize(c, { ...context })).join('')\n  }\n\n  else if (isVElement(node)) {\n    const tag: string = node.tagName?.toLowerCase()\n    const handleChildren = (ctx?: Partial<SerializeContext>): string => node.children.map(c => serialize(c, { ...context, ...ctx })).join('')\n\n    const rules: Record<string, () => string> = {\n      a: () => `<a href=\"${escapeHTML(node.getAttribute('href') ?? '')}\" rel=\"noopener noreferrer\" target=\"_blank\">${handleChildren()}</a>`,\n      img: () => `<img src=\"${escapeHTML(node.getAttribute('src') ?? '')}\" alt=\"${escapeHTML(node.getAttribute('alt') ?? '')}\">`,\n      br: () => `<br>`,\n      title: () => '',\n      script: () => '',\n      style: () => '',\n      head: () => '',\n    }\n\n    SELECTOR_BLOCK_ELEMENTS.split(',').forEach((tag) => {\n      rules[tag] = () => `<${tag}>${handleChildren().trim()}</${tag}>`\n    })\n\n    const fn = rules[tag]\n\n    if (fn)\n      return fn()\n\n    return handleChildren()\n  }\n  return escapeHTML(node.textContent ?? '')\n}\n\nexport function serializeSafeHTML(node: VNode): string {\n  return serialize(node).trim()\n}\n\nexport function safeHTML(html: string) {\n  return serializeSafeHTML(parseHTML(html))\n}\n","import { hArgumentParser } from './h'\nimport { markup } from './html'\nimport './jsx-runtime'\n\nexport function xml(itag: string, iattrs?: object, ...ichildren: any[]) {\n  const { tag, attrs, children } = hArgumentParser(itag, iattrs, ichildren)\n  return markup(true, tag, attrs, children)\n}\n\n// export const xmlVDOM = markup.bind(null, true)\n\nxml.firstLine = '<?xml version=\"1.0\" encoding=\"utf-8\"?>'\nxml.xml = true\n\nexport const h = xml\n"],"mappings":";;;;;;;;;;;;;;;;;;AAQA,IAAM,SAAS;AACf,IAAM,WAAW;AAKjB,IAAM,aAAa;AACnB,IAAM,iBAAiB;AAQhB,IAAM,aAAN,MAAiB;AAAA,EAQtB,YAAY,UAGR,CAAC,GAAG;AARR,kBAAS;AACT,oBAAW;AACX,sBAAa;AACb,oBAAW,EAAE,sBAAsB,MAAM;AAMvC,QAAI,QAAQ;AACV,WAAK,UAAU,QAAQ;AACzB,SAAK,UAAU,OAAO,OAAO,CAAC,GAAG,KAAK,UAAU,OAAO;AAAA,EACzD;AAAA,EAEA,MAAMA,OAAc;AAClB,QAAI,eAAe;AACnB,QAAI,OAAO,OAAO;AAClB,WAAOA,MAAK,QAAQ;AAElB,UAAIA,MAAK,UAAU,GAAG,CAAC,MAAM,QAAQ;AACnC,gBAAQA,MAAK,QAAQ,KAAK;AAC1B,YAAI,UAAU,IAAI;AAChB,eAAK,QAAQ,QAAQA,MAAK,UAAU,GAAG,KAAK,CAAC;AAC7C,UAAAA,QAAOA,MAAK,UAAU,QAAQ,CAAC;AAC/B,yBAAe;AAAA,QACjB,OACK;AACH,yBAAe;AAAA,QACjB;AAAA,MACF,WAGSA,MAAK,UAAU,GAAG,CAAC,MAAM,MAAM;AACtC,gBAAQ,KAAK,SAAS,KAAKA,KAAI;AAC/B,YAAI,OAAO;AACT,UAAAA,QAAO,OAAO;AACd,yBAAe;AACf,eAAK,YAAY,OAAO,WAAW,MAAM,CAAC,CAAC;AAAA,QAC7C,OACK;AACH,yBAAe;AAAA,QACjB;AAAA,MACF,WAGSA,MAAK,OAAO,CAAC,MAAM,KAAK;AAC/B,gBAAQ,KAAK,WAAW,KAAKA,KAAI;AACjC,YAAI,OAAO;AACT,UAAAA,QAAO,OAAO;AACd,yBAAe;AACf,gBAAM,UAAU,KAAK,cAAc,OAAO,WAAW,MAAM,CAAC,GAAG,KAAK;AACpE,cAAI,YAAY,YAAY,YAAY,SAAS;AAC/C,oBAAQA,MAAK,OAAO,IAAI,OAAO,KAAM,OAAO,IAAI,GAAG,CAAC;AACpD,gBAAI,UAAU,IAAI;AAChB,mBAAK,QAAQ,WAAWA,MAAK,UAAU,GAAG,KAAK,CAAC;AAChD,cAAAA,QAAOA,MAAK,UAAU,KAAK;AAC3B,6BAAe;AAAA,YACjB,OACK;AACH,6BAAe;AAAA,YACjB;AAAA,UACF;AAAA,QACF,OACK;AACH,yBAAe;AAAA,QACjB;AAAA,MACF;AAEA,UAAI,cAAc;AAChB,gBAAQA,MAAK,QAAQ,GAAG;AACxB,YAAI,SAAS;AAEb,YAAI,UAAU,GAAG;AAEf,kBAAQA,MAAK,UAAU,CAAC,EAAE,QAAQ,GAAG;AAErC,mBAAS,SAAS;AAAA,QACpB;AAEA,YAAI,UAAU,IAAI;AAChB,uBAAaA;AACb,UAAAA,QAAO;AAAA,QACT,OACK;AACH,uBAAaA,MAAK,UAAU,GAAG,MAAM;AACrC,UAAAA,QAAOA,MAAK,UAAU,MAAM;AAAA,QAC9B;AAEA,YAAI,CAAC,KAAK,QAAQ,wBAAwB,CAAC,QAAQ,KAAK,UAAU;AAChE,eAAK,QAAQ,WAAW,UAAU;AAAA,MACtC;AAEA,qBAAe;AACf,cAAQ;AAAA,IACV;AAAA,EACF;AAAA,EAEA,cAAc,OAAe,SAAiB,OAAY;AACxD,UAAM,cAAc,eAAe,KAAK,KAAK;AAC7C,QAAI,YAAY,MAAM,CAAC;AACvB,QAAI;AACF,kBAAY,UAAU,QAAQ,aAAa,EAAE;AAC/C,UAAM,QAAQ,KAAK,gBAAgB,SAAS,SAAS;AACrD,SAAK,QAAQ,aAAa,SAAS,OAAO,aAAa,MAAM,CAAC,CAAC;AAC/D,WAAO,QAAQ,kBAAkB;AAAA,EACnC;AAAA,EAEA,YAAY,OAAe,SAAiB;AAC1C,SAAK,QAAQ,WAAW,OAAO;AAAA,EACjC;AAAA,EAEA,gBAAgB,SAAiB,OAAe;AAC9C,UAAM,QAA6B,CAAC;AACpC,UAAM,QAAQ,KAAK,QAAQ,IAAI,MAAa;AAC1C,YAAM,CAAC,OAAO,MAAM,KAAK,OAAO,KAAK,cAAc,KAAK,kBAAkB,IAAI;AAC9E,YAAM,IAAI,IAAI,sBAAsB,gBAAgB,SAAS;AAC7D,aAAO;AAAA,IACT,CAAC;AACD,WAAO;AAAA,EACT;AACF;;;ACzIO,SAAS,KAAK,MAAsC,MAAa;AACtE,MAAI,eAAe;AACjB,WAAO;AAET,MAAI,eAAe;AACjB,UAAM,IAAI,SAAS,OAAO;AAE5B,MAAI,OAAO,QAAQ;AACjB,WAAO,UAAU,GAAG;AAGtB,SAAO,IAAI,kBAAkB;AAC/B;AAEO,SAAS,UAAUC,OAAiD;AACzE,MAAI,OAAOA,UAAS,UAAU;AAC5B,YAAQ,MAAM,oCAAoCA,KAAI;AACtD,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AAEA,QAAM,OACFA,MAAK,QAAQ,IAAI,MAAM,IAAI,IAAI,cAAc,IAAI,IAAI,IAAI,kBAAkB;AAE/E,QAAM,QAAiB,CAAC,IAAI;AAE5B,QAAM,SAAS,IAAI,WAAW;AAAA;AAAA,IAE5B,SAAS;AAAA,MACP,aACE,SACA,OACA,eACA;AACA,cAAM,eAAe,QAAQ,YAAY;AAEzC,YAAI,iBAAiB,YAAY;AAC/B,eAAK,UAAU,IAAI,SAAS;AAC5B;AAAA,QACF;AAEA,mBAAW,QAAQ,OAAO;AACxB,cAAI,OAAO,OAAO,IAAI,GAAG;AACvB,kBAAM,QAAQ,MAAM,IAAI;AAExB,gBAAI,OAAO,UAAU;AACnB,oBAAM,IAAI,IAAI,aAAa,KAAK;AAAA,UACpC;AAAA,QACF;AACA,cAAM,aAAa,MAAM,MAAM,SAAS,CAAC;AACzC,YAAI,YAAY;AACd,gBAAM,UAAU,SAAS,cAAc,SAAS,KAAK;AACrD,qBAAW,YAAY,OAAO;AAC9B,cACE,EACE,kBAAkB,SAAS,QAAQ,YAAY,CAAC,KAAK,gBAEvD;AACA,kBAAM,KAAK,OAAO;AAAA,UACpB;AAAA,QACF;AAAA,MACF;AAAA,MACA,WAAW,UAAkB;AAC3B,cAAM,IAAI;AAAA,MACZ;AAAA,MACA,WAAW,MAAc;AACvB,eAAO,aAAa,IAAI;AACxB,cAAM,aAAa,MAAM,MAAM,SAAS,CAAC;AACzC,YAAI,YAAY,WAAW,aAAa,MAAM,WAAW;AACvD,qBAAW,UAAU,SAAS;AAAA,QAChC,OACK;AACH,cAAI;AACF,uBAAW,YAAY,IAAI,UAAU,IAAI,CAAC;AAAA,QAG9C;AAAA,MACF;AAAA,MACA,QAAQ,OAAe;AAAA,MAAC;AAAA,IAC1B;AAAA,EACF,CAAC;AACD,SAAO,MAAMA,KAAI;AAEjB,SAAO;AACT;AAsCA,SAAS,UAAU,eAAe,SAAUA,OAAM;AAChD,QAAM,OAAO,UAAUA,KAAI;AAC3B,OAAK,cAAc,KAAK;AACxB,OAAK,qBAAqB;AAC5B;;;ACnIO,SAAS,WAAWC,OAAc,SAAgE;AACvG,QAAMC,YAAW,UAAUD,KAAI;AAC/B,UAAQC,SAAQ;AAChB,SAAOA,UAAS,OAAO;AACzB;;;ACEA,SAAS,UAAU,MAAwB,UAA4B;AAAA,EACrE,OAAO;AAAA,EACP,OAAO;AACT,GAAW;AACT,MAAI,KAAK,aAAa,MAAM,wBAAwB;AAClD,WAAO,KAAK,SAAS,IAAI,OAAK,UAAU,GAAG,EAAE,GAAG,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE;AAAA,EACrE,WAES,WAAW,IAAI,GAAG;AACzB,UAAM,MAAc,KAAK,QAAQ,YAAY;AAE7C,UAAM,iBAAiB,CAAC,QAA4C,KAAK,SAAS,IAAI,OAAK,UAAU,GAAG,EAAE,GAAG,SAAS,GAAG,IAAI,CAAC,CAAC,EAAE,KAAK,EAAE;AAExI,UAAM,QAAsC;AAAA,MAC1C,GAAG,MAAM,KAAK,eAAe,CAAC;AAAA,MAC9B,QAAQ,MAAM,KAAK,eAAe,CAAC;AAAA,MACnC,GAAG,MAAM,IAAI,eAAe,CAAC;AAAA,MAC7B,IAAI,MAAM,IAAI,eAAe,CAAC;AAAA,MAC9B,GAAG,MAAM,MAAM,eAAe,CAAC;AAAA,MAC/B,MAAM,MAAM,KAAK,eAAe,CAAC;AAAA,MACjC,IAAI,MAAM,KAAK,eAAe,CAAC;AAAA,MAC/B,MAAM,MAAM,KAAK,eAAe,CAAC;AAAA,MACjC,QAAQ,MAAM,KAAK,eAAe,CAAC;AAAA,MACnC,KAAK,MAAM,IAAI,eAAe,CAAC;AAAA,MAC/B,OAAO,MAAM,IAAI,eAAe,CAAC;AAAA,MACjC,KAAK,MAAM,IAAI,eAAe,CAAC;AAAA,MAC/B,IAAI,MAAM,KAAK,eAAe,CAAC;AAAA;AAAA;AAAA,MAC/B,IAAI,MAAM,GAAG,eAAe,CAAC;AAAA;AAAA,MAC7B,IAAI,MAAM;AAAA;AAAA,EAAO,eAAe,EAAE,OAAO,QAAQ,QAAQ,EAAE,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA,MAC7D,IAAI,MAAM;AAAA;AAAA,EAAO,eAAe,EAAE,OAAO,QAAQ,QAAQ,EAAE,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA,MAC7D,YAAY,MAAM;AAAA;AAAA,IAAS,eAAe,CAAC;AAAA;AAAA;AAAA;AAAA,MAC3C,KAAK,MAAM;AAAA;AAAA;AAAA,EAAe,eAAe,CAAC;AAAA;AAAA;AAAA;AAAA,MAC1C,GAAG,MAAM;AAAA;AAAA,EAAO,eAAe,CAAC;AAAA;AAAA;AAAA,MAChC,KAAK,MAAM;AAAA;AAAA,EAAO,eAAe,CAAC;AAAA;AAAA;AAAA,MAClC,IAAI,MAAM;AAAA;AAAA,IAAS,eAAe,CAAC;AAAA;AAAA;AAAA,MACnC,IAAI,MAAM;AAAA;AAAA,KAAU,eAAe,CAAC;AAAA;AAAA;AAAA,MACpC,IAAI,MAAM;AAAA;AAAA,MAAW,eAAe,CAAC;AAAA;AAAA;AAAA,MACrC,IAAI,MAAM;AAAA;AAAA,OAAY,eAAe,CAAC;AAAA;AAAA;AAAA,MACtC,IAAI,MAAM;AAAA;AAAA,QAAa,eAAe,CAAC;AAAA;AAAA;AAAA,MACvC,IAAI,MAAM;AAAA;AAAA,SAAc,eAAe,CAAC;AAAA;AAAA;AAAA,MACxC,IAAI,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,MACV,GAAG,MAAM,IAAI,eAAe,CAAC,KAAK,KAAK,aAAa,MAAM,KAAK,GAAG;AAAA,MAClE,KAAK,MAAM,KAAK,KAAK,aAAa,KAAK,KAAK,EAAE,KAAK,KAAK,aAAa,KAAK,KAAK,EAAE;AAAA;AAAA,IAGnF;AAEA,UAAM,KAAK,MAAM,GAAG;AAEpB,QAAI;AACF,aAAO,GAAG;AAAA;AAEV,aAAO,eAAe;AAAA,EAC1B;AACA,SAAO,KAAK,eAAe;AAC7B;AAEO,SAAS,kBAAkB,MAAqB;AACrD,SAAO,GAAG,UAAU,IAAI,EAAE,QAAQ,WAAW,MAAM,EAAE,KAAK,CAAC;AAAA;AAC7D;;;ACjEO,IAAM,0BAA0B;AAChC,IAAM,oBAAoB,CAAC,OAAO,QAAQ,UAAU,SAAS,IAAI;AAExE,SAAS,MAAM,SAAwB;AACrC,MAAI,SAAS;AACb,SAAO,QAAQ,YAAY;AACzB,cAAU;AACV,cAAU,QAAQ;AAAA,EACpB;AACA,SAAO,OAAO,OAAO,CAAC;AACxB;AAEO,SAAS,QAAQC,WAAqB;AAC3C,EAAAA,UAAS,OAAO,yBAAyB,CAAC,MAAM;AAE9C,QAAI,KAAK;AACT,WAAO,IAAI;AACT,UAAI,kBAAkB,SAAS,GAAG,OAAO;AACvC;AACF,WAAK,GAAG;AAAA,IACV;AAEA,UAAM,OAAO,EAAE;AACf,QACE,CAAC,QACE,KAAK,aAAa,MAAM,aACxB,CAAC,KAAK,WAAW,SAAS,IAAI,GACjC;AACA,QAAE,YAAY,aAAa,IAAI,UAAU,IAAI,GAAG,CAAC;AAAA,IACnD;AAEA,MAAE,YAAY,aAAa,IAAI,UAAU,MAAM,CAAC,CAAC,GAAG,CAAC;AAErD,UAAM,OAAO,EAAE;AACf,QACE,CAAC,QACE,KAAK,aAAa,MAAM,aACxB,CAAC,KAAK,WAAW,WAAW,IAAI,GACnC;AACA,UAAI;AACF,UAAE,YAAY,aAAa,IAAI,UAAU,IAAI,GAAG,IAAI;AAAA;AAEpD,UAAE,YAAY,YAAY,IAAI,UAAU,IAAI,CAAC;AAAA,IACjD;AAEA,QAAI,EAAE,WAAW,QAAQ;AACvB,YAAM,QAAQ,EAAE;AAChB,UAAI,MAAM,aAAa,MAAM;AAC3B,UAAE,aAAa,IAAI,UAAU;AAAA,EAAK,MAAM,CAAC,CAAC,IAAI,CAAC;AAEjD,QAAE,YAAY,IAAI,UAAU;AAAA,EAAK,MAAM,CAAC,CAAC,EAAE,CAAC;AAAA,IAC9C;AAAA,EACF,CAAC;AACH;;;AC9CA,SAASC,WAAU,MAAwB,UAA4B;AAAA,EACrE,OAAO;AAAA,EACP,OAAO;AACT,GAAW;AACT,MAAI,KAAK,aAAa,MAAM,wBAAwB;AAClD,WAAO,KAAK,SAAS,IAAI,OAAKA,WAAU,GAAG,EAAE,GAAG,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE;AAAA,EACrE,WAES,WAAW,IAAI,GAAG;AACzB,UAAM,MAAc,KAAK,QAAQ,YAAY;AAE7C,UAAM,iBAAiB,CAAC,QAA4C,KAAK,SAAS,IAAI,OAAKA,WAAU,GAAG,EAAE,GAAG,SAAS,GAAG,IAAI,CAAC,CAAC,EAAE,KAAK,EAAE;AAExI,UAAM,QAAsC;AAAA,MAC1C,IAAI,MAAM,GAAG,eAAe,CAAC;AAAA;AAAA,MAC7B,OAAO,MAAM;AAAA,MACb,QAAQ,MAAM;AAAA,MACd,OAAO,MAAM;AAAA,IACf;AAEA,4BAAwB,MAAM,GAAG,EAAE,QAAQ,CAACC,SAAQ;AAClD,YAAMA,IAAG,IAAI,MAAM;AAAA;AAAA,EAAO,eAAe,EAAE,KAAK,CAAC;AAAA;AAAA;AAAA,IACnD,CAAC;AAED,UAAM,KAAK,MAAM,GAAG;AAEpB,QAAI;AACF,aAAO,GAAG;AAAA;AAEV,aAAO,eAAe;AAAA,EAC1B;AACA,SAAO,KAAK,eAAe;AAC7B;AAEO,SAAS,mBAAmB,MAAqB;AACtD,SAAO,GAAGD,WAAU,IAAI,EAAE,QAAQ,WAAW,MAAM,EAAE,KAAK,CAAC;AAAA;AAC7D;;;AC1CO,IAAME,2BAA0B;AAQvC,SAASC,WAAU,MAAa,UAA4B;AAAA,EAC1D,OAAO;AAAA,EACP,OAAO;AACT,GAAW;AACT,MAAI,KAAK,aAAa,MAAM,wBAAwB;AAClD,WAAO,KAAK,SAAS,IAAI,OAAKA,WAAU,GAAG,EAAE,GAAG,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE;AAAA,EACrE,WAES,WAAW,IAAI,GAAG;AACzB,UAAM,MAAc,KAAK,SAAS,YAAY;AAC9C,UAAM,iBAAiB,CAAC,QAA4C,KAAK,SAAS,IAAI,OAAKA,WAAU,GAAG,EAAE,GAAG,SAAS,GAAG,IAAI,CAAC,CAAC,EAAE,KAAK,EAAE;AAExI,UAAM,QAAsC;AAAA,MAC1C,GAAG,MAAM,YAAY,WAAW,KAAK,aAAa,MAAM,KAAK,EAAE,CAAC,+CAA+C,eAAe,CAAC;AAAA,MAC/H,KAAK,MAAM,aAAa,WAAW,KAAK,aAAa,KAAK,KAAK,EAAE,CAAC,UAAU,WAAW,KAAK,aAAa,KAAK,KAAK,EAAE,CAAC;AAAA,MACtH,IAAI,MAAM;AAAA,MACV,OAAO,MAAM;AAAA,MACb,QAAQ,MAAM;AAAA,MACd,OAAO,MAAM;AAAA,MACb,MAAM,MAAM;AAAA,IACd;AAEA,IAAAD,yBAAwB,MAAM,GAAG,EAAE,QAAQ,CAACE,SAAQ;AAClD,YAAMA,IAAG,IAAI,MAAM,IAAIA,IAAG,IAAI,eAAe,EAAE,KAAK,CAAC,KAAKA,IAAG;AAAA,IAC/D,CAAC;AAED,UAAM,KAAK,MAAM,GAAG;AAEpB,QAAI;AACF,aAAO,GAAG;AAEZ,WAAO,eAAe;AAAA,EACxB;AACA,SAAO,WAAW,KAAK,eAAe,EAAE;AAC1C;AAEO,SAAS,kBAAkB,MAAqB;AACrD,SAAOD,WAAU,IAAI,EAAE,KAAK;AAC9B;AAEO,SAAS,SAASE,OAAc;AACrC,SAAO,kBAAkB,UAAUA,KAAI,CAAC;AAC1C;;;AClDO,SAAS,IAAI,MAAc,WAAoB,WAAkB;AACtE,QAAM,EAAE,KAAK,OAAO,SAAS,IAAI,gBAAgB,MAAM,QAAQ,SAAS;AACxE,SAAO,OAAO,MAAM,KAAK,OAAO,QAAQ;AAC1C;AAIA,IAAI,YAAY;AAChB,IAAI,MAAM;","names":["html","html","html","document","document","serialize","tag","SELECTOR_BLOCK_ELEMENTS","serialize","tag","html"]}