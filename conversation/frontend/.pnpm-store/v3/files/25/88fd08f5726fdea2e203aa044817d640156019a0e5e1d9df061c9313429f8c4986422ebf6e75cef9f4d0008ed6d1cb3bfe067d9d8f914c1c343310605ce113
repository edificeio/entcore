{"version":3,"file":"image.js","sources":["../../src/image/image.ts"],"sourcesContent":["import { WorkspaceElement } from '@edifice.io/client';\nimport { ImageResizer } from '@edifice.io/utilities';\nimport { mergeAttributes, nodeInputRule } from '@tiptap/core';\nimport TiptapImage from '@tiptap/extension-image';\nimport { Plugin } from 'prosemirror-state';\n\nexport const IMAGE_INPUT_REGEX =\n  /(?:^|\\s)(!\\[(.+|:?)]\\((\\S+)(?:(?:\\s+)[\"'](\\S+)[\"'])?\\))$/;\n\nexport interface CustomImageOptions {\n  HTMLAttributes: Record<string, string>;\n  sizes: string[];\n  uploadFile?: (file: File) => Promise<WorkspaceElement | null>;\n}\n\ninterface AttributesProps {\n  width: number | string;\n  height: number | string;\n  size: string;\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    customImage: {\n      setAttributes: (options: AttributesProps) => ReturnType;\n      setNewImage: (options: {\n        src: string;\n        alt?: string;\n        title?: string;\n      }) => ReturnType;\n    };\n  }\n}\n\nexport const Image = TiptapImage.extend<CustomImageOptions>({\n  name: 'custom-image',\n  draggable: true,\n  selectable: true,\n\n  addOptions() {\n    return {\n      ...this.parent?.(),\n      inline: true,\n      content: 'inline*',\n      sizes: ['small', 'medium', 'large'],\n      HTMLAttributes: {\n        class: 'custom-image',\n      },\n      uploadFile: () => {\n        return Promise.resolve(null);\n      },\n    };\n  },\n\n  addAttributes() {\n    return {\n      ...this.parent?.(),\n      size: {\n        default: 'medium',\n        rendered: false,\n      },\n      alt: {\n        renderHTML: (attributes) => {\n          return {\n            alt: attributes.alt,\n          };\n        },\n        parseHTML: (element) => element.getAttribute('alt'),\n      },\n      title: {\n        renderHTML: (attributes) => {\n          return {\n            title: attributes.title,\n          };\n        },\n        parseHTML: (element) => element.getAttribute('title'),\n      },\n      width: {\n        default: '350',\n        renderHTML: (attributes) => {\n          if (\n            attributes.width !== null &&\n            attributes.width !== undefined &&\n            !Number.isNaN(attributes.width)\n          ) {\n            return {\n              width: parseInt(attributes.width),\n            };\n          }\n          return {};\n        },\n        parseHTML: (element) => element.getAttribute('width'),\n      },\n      height: {\n        renderHTML: (attributes) => {\n          if (\n            attributes.height !== null &&\n            attributes.height !== undefined &&\n            !Number.isNaN(attributes.height)\n          ) {\n            return {\n              height: parseInt(attributes.height),\n            };\n          }\n          return {};\n        },\n        parseHTML: (element) => element.getAttribute('height'),\n      },\n      style: {\n        renderHTML: (attributes) => {\n          return attributes.style\n            ? {\n                style: attributes.style,\n              }\n            : {};\n        },\n        parseHTML: (element) => {\n          const style = element.getAttribute('style');\n          return style && typeof style === 'string' && style.length > 0\n            ? {}\n            : null;\n        },\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'img[src]:not([src^=\"data:\"])',\n        getAttrs: (el: HTMLImageElement) => {\n          const attr = { src: el.getAttribute('src') };\n          // Check old content format and get the width from the parent element\n          if (el.parentElement?.className.includes('image-container')) {\n            if (el.parentElement.style?.width) {\n              attr['width'] = el.parentElement.style.width;\n            }\n          }\n          if (el.style?.width) {\n            attr['width'] = el.style.width;\n          }\n\n          // Check old content smiley\n          const oldSmileyList = [\n            'happy',\n            'proud',\n            'dreamy',\n            'love',\n            'tired',\n            'angry',\n            'worried',\n            'sick',\n            'joker',\n            'sad',\n          ];\n          if (\n            oldSmileyList.filter((smiley) => attr.src.includes(smiley + '.png'))\n              .length > 0\n          ) {\n            attr['style'] = {\n              width: '1.5em',\n              height: '1.5em',\n              fontSize: el.parentElement?.style?.fontSize,\n            };\n            attr['width'] = 'null';\n            attr['height'] = 'null';\n          }\n          return attr;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      'img',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n    ];\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: IMAGE_INPUT_REGEX,\n        type: this.type,\n        getAttributes: (match) => {\n          const [, , alt, src, title] = match;\n\n          return {\n            src,\n            alt,\n            title,\n          };\n        },\n      }),\n    ];\n  },\n\n  addCommands() {\n    return {\n      setNewImage:\n        (attrs) =>\n        ({ tr, dispatch }) => {\n          const { selection } = tr;\n          const node = this.type.create(attrs);\n\n          if (dispatch) {\n            tr.replaceRangeWith(selection.from, selection.to, node);\n          }\n\n          return true;\n        },\n      setAttributes:\n        (attributes) =>\n        ({ tr, dispatch }) => {\n          const { selection } = tr;\n\n          const nodeAttrs = tr.doc.nodeAt(tr.selection.from);\n          const options = {\n            ...nodeAttrs.attrs,\n            ...attributes,\n          };\n          const node = this.type.create(options);\n\n          if (dispatch) {\n            tr.replaceRangeWith(selection.from, selection.to, node);\n          }\n\n          return true;\n        },\n    };\n  },\n\n  addProseMirrorPlugins() {\n    const uploadNode = async (file: File) => {\n      /**\n       * Resize the image\n       */\n      const resizedImage = await ImageResizer.resizeImageFile(file);\n\n      /**\n       * Upload the image\n       */\n      const image = await this.options.uploadFile(resizedImage);\n\n      /**\n       * Get the image url\n       */\n      const imageUrl = `/workspace/${image.public ? 'pub/' : ''}document/${\n        image._id\n      }?timestamp=${new Date().getTime()}`;\n\n      /**\n       * Create the image node\n       */\n\n      const node = this.type.create({\n        src: imageUrl,\n        alt: image.alt,\n        title: image.title,\n      });\n\n      return node;\n    };\n\n    const getFilteredFiles = (files: FileList) => {\n      return Array.from(files).filter((file) =>\n        /image\\/(png|jpeg|jpg|gif|webp|heic|avif)/.test(file.type),\n      );\n    };\n\n    const handleImageInsert = async (\n      editor: any,\n      file: File,\n      position?: number,\n    ) => {\n      const node = await uploadNode(file);\n      if (!node) return;\n\n      const transaction =\n        position !== undefined\n          ? editor.state.tr.insert(position, node)\n          : editor.state.tr.replaceSelectionWith(node);\n\n      editor.dispatch(transaction);\n    };\n\n    return [\n      new Plugin({\n        props: {\n          handlePaste: (editor, e) => {\n            const files = getFilteredFiles(e.clipboardData?.files);\n            if (files.length === 0) return false;\n\n            for (const file of files) {\n              handleImageInsert(editor, file);\n            }\n\n            return true;\n          },\n          handleDrop: (editor, e, _s, moved) => {\n            if (moved) return false;\n\n            const files = getFilteredFiles(e.dataTransfer.files);\n            if (files.length === 0) return false;\n\n            const { pos: position } = editor.posAtCoords({\n              left: e.clientX,\n              top: e.clientY,\n            });\n\n            for (const file of files) {\n              handleImageInsert(editor, file, position);\n            }\n            return true;\n          },\n        },\n      }),\n    ];\n  },\n});\n"],"names":[],"mappings":"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"}