import { useState, useRef, useEffect } from "react";
import { findNodeById, findPathById } from "../utilities/tree.js";
const useTree = ({
  data,
  externalSelectedNodeId,
  draggedNode,
  shouldExpandAllNodes,
  onTreeItemUnfold,
  onTreeItemFold,
  onTreeItemClick
}) => {
  const [internalSelectedNodeId, setInternalSelectedNodeId] = useState(void 0), [expandedNodes, setExpandedNodes] = useState(/* @__PURE__ */ new Set()), siblingsNodes = useRef(/* @__PURE__ */ new Set()), [draggedNodeId, setDraggedNodeId] = useState(void 0), selectedNodeId = internalSelectedNodeId ?? externalSelectedNodeId;
  function addNodesWithSiblingHavingChildren(data2) {
    var _a;
    Array.isArray(data2) ? data2.forEach((node) => {
      const resultSet = new Set(siblingsNodes.current);
      data2.filter(({
        id
      }) => id !== node.id).some((sibling) => sibling.children && sibling.children.length > 0) && resultSet.add(node.id), node.children && node.children.length > 0 && node.children.forEach((child) => {
        var _a2;
        const childSiblings = (_a2 = node.children) == null ? void 0 : _a2.filter(({
          id
        }) => id !== child.id);
        (childSiblings == null ? void 0 : childSiblings.some((sibling) => sibling.children && sibling.children.length > 0)) && resultSet.add(child.id), addNodesWithSiblingHavingChildren(child);
      });
    }) : (_a = data2.children) == null || _a.forEach((child) => {
      var _a2;
      const resultSet = new Set(siblingsNodes.current), siblings = (_a2 = data2.children) == null ? void 0 : _a2.filter((c) => c.id !== child.id);
      (siblings == null ? void 0 : siblings.some((sibling) => sibling.children && sibling.children.length > 0)) && (resultSet.add(child.id), siblingsNodes.current = resultSet), addNodesWithSiblingHavingChildren(child);
    });
  }
  const expandAllNodes = (shouldExpandAllNodes2) => {
    const initExpandedNodes = new Set("");
    data && Array.isArray(data) && shouldExpandAllNodes2 && (data.forEach((node) => initExpandedNodes.add(node.id)), setExpandedNodes(initExpandedNodes));
  };
  useEffect(() => {
    data && addNodesWithSiblingHavingChildren(data);
  }, [data]), useEffect(() => {
    draggedNode != null && draggedNode.isOver && draggedNode.isTreeview ? (draggedNode.overId && handleItemDrag(draggedNode.overId), setDraggedNodeId(draggedNode.overId)) : setDraggedNodeId(void 0);
  }, [draggedNode]), useEffect(() => {
    shouldExpandAllNodes && expandAllNodes(shouldExpandAllNodes);
  }, [data, shouldExpandAllNodes]), useEffect(() => {
    externalSelectedNodeId && !shouldExpandAllNodes ? (handleExternalSelectedNodeId(externalSelectedNodeId), setInternalSelectedNodeId(externalSelectedNodeId)) : setInternalSelectedNodeId(void 0);
  }, [externalSelectedNodeId]);
  const handleExternalSelectedNodeId = (nodeId) => {
    if (!findNodeById(data, selectedNodeId)) {
      setInternalSelectedNodeId(void 0);
      return;
    }
    if (externalSelectedNodeId === "default") {
      expandedNodes.forEach((node) => onTreeItemUnfold == null ? void 0 : onTreeItemUnfold(node));
      return;
    }
    handleExpandNode(nodeId);
  }, handleExpandNode = (nodeId) => {
    const updatedExpandedNodes = new Set(expandedNodes), parents = findPathById(data, nodeId), arrayOrder = Array.from(updatedExpandedNodes);
    parents.forEach((parent) => {
      const index = arrayOrder.indexOf(parent);
      index > -1 && arrayOrder.splice(index, 1), arrayOrder.push(parent);
    }), updatedExpandedNodes.clear(), arrayOrder.forEach((node) => updatedExpandedNodes.add(node)), updatedExpandedNodes.forEach((node) => onTreeItemUnfold == null ? void 0 : onTreeItemUnfold(node)), setExpandedNodes(updatedExpandedNodes);
  }, handleCollapseNode = (nodeId) => {
    const updatedExpandedNodes = new Set(expandedNodes);
    updatedExpandedNodes.delete(nodeId), updatedExpandedNodes.forEach((node) => onTreeItemFold == null ? void 0 : onTreeItemFold(node)), setExpandedNodes(updatedExpandedNodes);
  }, handleToggleNode = (nodeId) => {
    expandedNodes.has(nodeId) ? handleCollapseNode(nodeId) : handleExpandNode(nodeId);
  }, handleSelectedItem = (nodeId) => {
    selectedNodeId !== nodeId && setInternalSelectedNodeId(nodeId);
  }, handleItemClick = (nodeId) => {
    handleSelectedItem(nodeId), handleExpandNode(nodeId), onTreeItemClick == null || onTreeItemClick(nodeId);
  }, handleFoldUnfold = (nodeId) => handleToggleNode(nodeId), handleItemDrag = (nodeId) => {
    findNodeById(data, externalSelectedNodeId) && handleCollapseNode(nodeId);
  };
  return {
    selectedNodeId,
    expandedNodes,
    siblingsNodes,
    draggedNodeId,
    handleItemClick,
    handleFoldUnfold,
    handleCollapseNode
  };
};
export {
  useTree
};
