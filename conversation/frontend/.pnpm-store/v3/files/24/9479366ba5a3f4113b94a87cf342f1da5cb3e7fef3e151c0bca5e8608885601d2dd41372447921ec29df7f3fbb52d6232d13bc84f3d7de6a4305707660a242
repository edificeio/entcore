var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
var __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value), value);
import { jsxs, jsx, Fragment } from "react/jsx-runtime";
import { createPortal } from "react-dom";
import { useTranslation } from "react-i18next";
import { Controller, useForm } from "react-hook-form";
import React, { useState, useEffect, createContext, useContext, forwardRef, useRef, useImperativeHandle, useId, useCallback, useLayoutEffect, useMemo, Fragment as Fragment$1, createElement, useReducer } from "react";
import clsx from "clsx";
import { RafterUp, Search, SuccessOutline, AlertCircle, InfoCircle, Error as Error$1, Options, Paperclip, Mic, Landscape, Video as Video$1, TextPage, Reset, Close, Wand, See, Users, Reaction, RafterRight, DeleteColor, Plus, Download, Edit, Delete, Folder, RafterDown, Pause, Record, RecordPause, Loader, PlayFilled, Restart, Refresh, Save, Code, Undo, Crop, Blur, Applications, RecordStop, RecordVideo, Globe, ArrowRight, SortTime, SortAscendingLetters, SortDescendingLetters, Smartphone, Copy, Bookmark, BurgerMenu } from "@edifice-ui/icons";
import { useFloating, autoUpdate, offset, size, flip, useHover as useHover$1, safePolygon } from "@floating-ui/react";
import { I as Image$1, B as Button, u as usePaths, a as useOdeClient, b as useConf, A as Avatar, L as Loading, H as Heading, c as Badge, d as useDate, E as EmptyScreen } from "./useDirectory-8dc7424c.js";
import { O, e, f, h, g } from "./useDirectory-8dc7424c.js";
import { odeServices, DocumentHelper, FOLDER, StringUtils as StringUtils$1, ReactionTypes, ERROR_CODE, LAYER_NAME, SnipletsService } from "edifice-ts-client";
import toast, { Toaster } from "react-hot-toast";
import { useTransition, animated } from "@react-spring/web";
import { usePopper } from "react-popper";
import { OneProfile, Search as Search$1, OneMessaging, OneAssistance, Disconnect, NewRelease, Userbook, MyApps, Home, NeoMessaging, NeoAssistance, Community } from "@edifice-ui/icons/nav";
import ImageResizer from "@edifice.io/image-resizer";
import UAParser from "ua-parser-js";
import { Stage } from "@pixi/react";
import "@pixi/mixin-get-child-by-name";
import * as PIXI from "pixi.js";
import { MeasuringStrategy, useSensors, useSensor, PointerSensor, KeyboardSensor, defaultDropAnimation, DndContext, DragOverlay, useDroppable } from "@dnd-kit/core";
import { useInView } from "react-intersection-observer";
import { Guest, Personnel, Teacher, Parent, Student, InterestingCounter, Interesting, CongratsCounter, Congrats, GreatCounter, Great, ThanksCounter, Thanks } from "@edifice-ui/icons/audience";
import { useMediaQuery, usePrevious } from "@uidotdev/usehooks";
import { Pagination } from "swiper/modules";
import { Swiper, SwiperSlide } from "swiper/react";
import { useMutation } from "@tanstack/react-query";
import { hash } from "ohash";
import slugify from "react-slugify";
import { arrayMove, sortableKeyboardCoordinates, SortableContext, verticalListSortingStrategy, useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import parse, { domToReact, attributesToProps } from "html-react-parser";
import "dayjs";
const getOnboardingTrash = async (key) => await odeServices.conf().getPreference(key), saveOnboardingTrash = async (key) => await odeServices.conf().savePreference(key, JSON.stringify({
  key: !1
})), useOnboardingModal = (id) => {
  const [isOpen, setIsOpen] = useState(!0), [isOnboarding, setIsOnboarding] = useState(!1);
  return useEffect(() => {
    (async () => {
      const response = await getOnboardingTrash(id);
      if (response) {
        const {
          key
        } = response;
        setIsOnboarding(key);
        return;
      }
      setIsOnboarding(!0);
    })();
  }, [id]), {
    isOpen,
    setIsOpen,
    isOnboarding,
    handleSavePreference: async () => {
      await saveOnboardingTrash(id), setIsOpen(!1);
    }
  };
}, OnboardingModal = ({
  id,
  items,
  modalOptions
}) => {
  const [imagePath] = usePaths(), [swiperInstance, setSwiperInstance] = useState(), [swiperProgress, setSwiperprogress] = useState(0), {
    isOpen,
    isOnboarding,
    setIsOpen,
    handleSavePreference
  } = useOnboardingModal(id);
  useEffect(() => {
    const link = document.createElement("link");
    return link.href = "https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css", link.rel = "stylesheet", link.type = "text/css", document.head.appendChild(link), () => {
      document.head.removeChild(link);
    };
  }, []);
  const {
    t
  } = useTranslation(), {
    title,
    prevText,
    closeText,
    nextText
  } = modalOptions;
  return isOnboarding ? /* @__PURE__ */ createPortal(/* @__PURE__ */ jsxs(Modal$1, { id: "onboarding-modal", size: "md", isOpen, focusId: "nextButtonId", onModalClose: () => setIsOpen(!1), children: [
    /* @__PURE__ */ jsx(Modal$1.Header, { onModalClose: () => setIsOpen(!1), children: t(title || "explorer.modal.onboarding.trash.title") }),
    /* @__PURE__ */ jsx(Modal$1.Body, { children: /* @__PURE__ */ jsx(Swiper, { modules: [Pagination], onSwiper: (swiper) => {
      setSwiperInstance(swiper);
    }, onSlideChange: (swiper) => {
      setSwiperprogress(swiper.progress);
    }, pagination: {
      clickable: !0
    }, children: items.map((item, index) => /* @__PURE__ */ jsxs(SwiperSlide, { children: [
      /* @__PURE__ */ jsx(Image$1, { width: "270", height: "140", className: "mx-auto my-12", loading: "lazy", src: `${imagePath}/${item.src}`, alt: t(item.alt) }),
      /* @__PURE__ */ jsx("p", { children: t(item.text) })
    ] }, index)) }) }),
    /* @__PURE__ */ jsxs(Modal$1.Footer, { children: [
      /* @__PURE__ */ jsx(Button, { type: "button", color: "tertiary", variant: "ghost", onClick: () => setIsOpen(!1), children: t("explorer.modal.onboarding.trash.later") }),
      swiperProgress > 0 && /* @__PURE__ */ jsx(Button, { type: "button", color: "primary", variant: "outline", onClick: () => swiperInstance.slidePrev(), children: t(prevText || "explorer.modal.onboarding.trash.prev") }),
      swiperProgress < 1 && /* @__PURE__ */ jsx(Button, { id: "nextButtonId", type: "button", color: "primary", variant: "filled", onClick: () => swiperInstance.slideNext(), children: t(nextText || "explorer.modal.onboarding.trash.next") }),
      swiperProgress === 1 && /* @__PURE__ */ jsx(Button, { type: "button", color: "primary", variant: "filled", onClick: handleSavePreference, children: t(closeText || "explorer.modal.onboarding.trash.close") })
    ] })
  ] }), document.getElementById("portal")) : null;
}, OnboardingModal$1 = OnboardingModal, DropdownContext = /* @__PURE__ */ createContext(null), useDropdownContext = () => {
  const context = useContext(DropdownContext);
  if (!context)
    throw new Error("Cannot be rendered outside the Dropdown Component");
  return context;
}, Checkbox = /* @__PURE__ */ forwardRef(({
  label,
  disabled = !1,
  checked = !1,
  indeterminate = !1,
  ...restProps
}, ref) => {
  const refCheckbox = useRef(null);
  useImperativeHandle(ref, () => ({
    ...refCheckbox.current
  })), useEffect(() => {
    refCheckbox.current.indeterminate = indeterminate;
  }, [refCheckbox, indeterminate]);
  const id = useId(), checkboxProps = {
    type: "checkbox",
    checked,
    disabled,
    ref: refCheckbox,
    className: clsx(restProps.className, "form-check-input c-pointer"),
    id
  }, inputProps = {
    ...restProps,
    ...checkboxProps
  };
  return /* @__PURE__ */ jsxs("div", { className: "form-check d-flex align-items-center gap-8", children: [
    /* @__PURE__ */ jsx("input", { ...inputProps }),
    label && /* @__PURE__ */ jsx("label", { className: "form-check-label", htmlFor: inputProps.id, children: label })
  ] });
}), Checkbox$1 = Checkbox, DropdownCheckboxItem = ({
  children,
  value,
  model,
  onChange
}) => {
  const {
    itemProps,
    itemRefs,
    isFocused
  } = useDropdownContext(), {
    onMenuItemKeyDown,
    onMenuItemMouseEnter
  } = itemProps, id = useId(), checked = model.includes(value), checkboxProps = {
    value,
    model,
    checked,
    readOnly: !0
  }, dropdownCheckboxItem = clsx("dropdown-item c-pointer", {
    focus: isFocused === id
  });
  return /* @__PURE__ */ jsx("div", { id, ref: (el) => itemRefs.current[id] = el, role: "menuitemcheckbox", "aria-checked": checked, onMouseUp: () => onChange(value), onKeyDown: (event) => onMenuItemKeyDown(event, () => onChange(value)), onMouseEnter: onMenuItemMouseEnter, tabIndex: checked ? 0 : -1, className: dropdownCheckboxItem, children: /* @__PURE__ */ jsxs("div", { className: "d-flex gap-8 align-items-center justify-content-between position-relative", children: [
    children,
    /* @__PURE__ */ jsx(Checkbox$1, { ...checkboxProps })
  ] }) });
}, DropdownCheckboxItem$1 = DropdownCheckboxItem, DropdownItem = ({
  type = "action",
  icon,
  onClick,
  children,
  className,
  ...restProps
}) => {
  const {
    itemProps,
    itemRefs,
    isFocused
  } = useDropdownContext(), {
    onMenuItemKeyDown,
    onMenuItemMouseEnter,
    onMenuItemClick
  } = itemProps, handleOnClick = (event) => {
    onClick == null || onClick(event), type === "action" && (onMenuItemClick(), event.stopPropagation());
  }, id = useId(), dropdownItem = clsx("dropdown-item", {
    focus: isFocused === id
  }, className);
  return /* @__PURE__ */ jsx("div", { id, role: "menuitem", ref: (el) => itemRefs.current[id] = el, tabIndex: isFocused === id ? 0 : -1, className: dropdownItem, "aria-current": isFocused === id, onClick: handleOnClick, onMouseEnter: onMenuItemMouseEnter, onKeyDown: (event) => onMenuItemKeyDown(event, onClick), ...restProps, children: /* @__PURE__ */ jsxs("div", { className: "d-flex gap-8 align-items-center", children: [
    icon,
    children
  ] }) });
}, DropdownItem$1 = DropdownItem, DropdownMenu = /* @__PURE__ */ forwardRef(({
  children,
  block,
  unstyled,
  ...restProps
}, forwardRef2) => {
  const {
    menuProps,
    visible
  } = useDropdownContext(), className = clsx({
    "w-100": block,
    "bg-white shadow rounded-4 p-8": !unstyled
  }, menuProps.className, restProps.className), mergedProps = {
    ...menuProps,
    ...restProps,
    className
  };
  return visible ? /* @__PURE__ */ jsx("div", { ref: forwardRef2, ...mergedProps, children }) : null;
}), DropdownMenu$1 = DropdownMenu, DropdownMenuGroup = /* @__PURE__ */ forwardRef(({
  label,
  children
}, forwardRef2) => /* @__PURE__ */ jsxs("div", { ref: forwardRef2, role: "group", children: [
  /* @__PURE__ */ jsx("span", { className: "small px-4", children: /* @__PURE__ */ jsx("strong", { children: label }) }),
  children
] })), DropdownMenuGroup$1 = DropdownMenuGroup, Radio = /* @__PURE__ */ forwardRef(({
  model,
  icon,
  label = !1,
  disabled = !1,
  checked,
  ...restProps
}, ref) => {
  const id = useId(), radioProps = {
    type: "radio",
    checked,
    disabled,
    ref,
    className: clsx(restProps.className, "form-check-input c-pointer", icon && "d-none"),
    id
  }, inputProps = {
    ...restProps,
    ...radioProps
  };
  return /* @__PURE__ */ jsxs("div", { className: clsx("form-check d-flex align-items-center gap-8", icon && "ps-0"), children: [
    /* @__PURE__ */ jsx("input", { ...inputProps }),
    icon && /* @__PURE__ */ jsx("label", { htmlFor: inputProps.id, className: clsx("c-pointer", model !== restProps.value && "text-muted"), children: icon }),
    !icon && label && /* @__PURE__ */ jsx("label", { className: "form-check-label", htmlFor: inputProps.id, children: label })
  ] });
}), Radio$1 = Radio, DropdownRadioItem = ({
  children,
  value,
  model,
  onChange
}) => {
  const {
    itemProps,
    itemRefs,
    isFocused
  } = useDropdownContext(), {
    onMenuItemKeyDown,
    onMenuItemMouseEnter
  } = itemProps, id = useId(), radioProps = {
    value,
    model,
    checked: value === model,
    readOnly: !0
  }, dropdownRadioItem = clsx("dropdown-item c-pointer", {
    focus: isFocused === id
  });
  return /* @__PURE__ */ jsx("div", { id, ref: (el) => itemRefs.current[id] = el, role: "menuitemradio", "aria-checked": value === model, onMouseUp: () => onChange(value), onKeyDown: (event) => onMenuItemKeyDown(event, () => onChange(value)), onMouseEnter: onMenuItemMouseEnter, tabIndex: value === model ? 0 : -1, className: dropdownRadioItem, children: /* @__PURE__ */ jsxs("div", { className: "d-flex gap-8 align-items-center justify-content-between position-relative", children: [
    children,
    /* @__PURE__ */ jsx(Radio$1, { ...radioProps, className: "position-absolute start-0 end-0 top-0 bottom-0 opacity-0" })
  ] }) });
}, DropdownRadioItem$1 = DropdownRadioItem, DropdownSeparator = () => /* @__PURE__ */ jsx("div", { role: "separator", className: "px-4", children: /* @__PURE__ */ jsx("hr", { className: "m-0" }) }), DropdownSeparator$1 = DropdownSeparator, DropdownTrigger = /* @__PURE__ */ forwardRef(({
  label,
  icon,
  variant,
  disabled = !1,
  size: size2,
  badgeContent,
  hideCarret = !1,
  ...restProps
}, forwardRef2) => {
  const {
    triggerProps,
    block
  } = useDropdownContext(), className = clsx("dropdown-toggle ", size2, variant, {
    "w-100": block
  }, triggerProps.className, restProps.className), mergedProps = {
    ...triggerProps,
    ...restProps,
    className
  };
  return /* @__PURE__ */ jsxs("button", { ref: forwardRef2, type: "button", disabled, ...mergedProps, children: [
    icon,
    label,
    badgeContent ? /* @__PURE__ */ jsx("span", { className: "badge text-bg-secondary rounded-pill", children: badgeContent }) : !hideCarret && /* @__PURE__ */ jsx(RafterUp, { width: 16, height: 16, className: "dropdown-toggle-caret" })
  ] });
}), DropdownTrigger$1 = DropdownTrigger;
function useBreakpoint() {
  return {
    xs: useMediaQuery("only screen and (min-width: 0)"),
    sm: useMediaQuery("only screen and (min-width: 375px)"),
    md: useMediaQuery("only screen and (min-width: 768px)"),
    lg: useMediaQuery("only screen and (min-width: 1024px)"),
    xl: useMediaQuery("only screen and (min-width: 1280px)"),
    xxl: useMediaQuery("only screen and (min-width: 1400px)")
  };
}
function useBrowserInfo(userAgent) {
  var _a, _b, _c;
  const uaParser = new UAParser(userAgent), os = uaParser.getOS(), device = uaParser.getDevice(), browser = uaParser.getBrowser(), isIphone = ((_a = device.model) == null ? void 0 : _a.indexOf("iPhone")) != -1, isIpod = ((_b = device.model) == null ? void 0 : _b.indexOf("iPod")) != -1, isIpad = ((_c = device.model) == null ? void 0 : _c.indexOf("iPad")) != -1;
  return {
    os,
    device,
    browser,
    isIphone,
    isIpod,
    isIpad
  };
}
const useCheckable = (data) => {
  const [selectedItems, setSelectedItems] = useState([]), handleOnSelectItem = (itemId) => {
    setSelectedItems((currentSelection) => {
      const newSelection = [...currentSelection];
      return newSelection.includes(itemId) ? newSelection.splice(newSelection.indexOf(itemId), 1) : newSelection.push(itemId), newSelection;
    });
  }, handleOnSelectAllItems = (deselect) => {
    setSelectedItems(() => deselect ? [] : (data == null ? void 0 : data.map((item) => item._id)) ?? []);
  }, allItemsSelected = (selectedItems == null ? void 0 : selectedItems.length) === (data == null ? void 0 : data.length), isIndeterminate = data ? (selectedItems == null ? void 0 : selectedItems.length) > 0 && (selectedItems == null ? void 0 : selectedItems.length) < (data == null ? void 0 : data.length) : !1;
  return {
    selectedItems,
    allItemsSelected,
    isIndeterminate,
    handleOnSelectAllItems,
    handleOnSelectItem
  };
}, DEFAULT_EVENTS = ["mousedown", "touchstart"];
function useClickOutside(handler, events, nodes) {
  const ref = useRef();
  return useEffect(() => {
    const listener = (event) => {
      const {
        target
      } = event ?? {};
      if (Array.isArray(nodes)) {
        const shouldIgnore = (target == null ? void 0 : target.hasAttribute("data-ignore-outside-clicks")) || !document.body.contains(target) && target.tagName !== "HTML";
        nodes.every((node) => !!node && !event.composedPath().includes(node)) && !shouldIgnore && handler();
      } else
        ref.current && !ref.current.contains(target) && handler();
    };
    return (events || DEFAULT_EVENTS).forEach((fn) => {
      document.addEventListener(fn, listener);
    }), () => {
      (events || DEFAULT_EVENTS).forEach((fn) => {
        document.removeEventListener(fn, listener);
      });
    };
  }, [ref, handler, nodes, events]), ref;
}
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  return useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay || 500);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]), debouncedValue;
}
function mergeRefs(...refs) {
  return (val) => {
    setRef(val, ...refs);
  };
}
function setRef(val, ...refs) {
  refs.forEach((ref) => {
    typeof ref == "function" ? ref(val) : ref != null && (ref.current = val);
  });
}
const useDropdown = (placement, extraTriggerKeyDownHandler, isTriggerHovered = !1) => {
  const id = useId(), [visible, setVisible] = useState(!1), [activeIndex, setActiveIndex] = useState(-1), [isFocused, setIsFocused] = useState(null), {
    refs,
    floatingStyles,
    context
  } = useFloating({
    placement,
    open: visible,
    onOpenChange: setVisible,
    whileElementsMounted: autoUpdate,
    middleware: [offset(4), size({
      apply({
        rects,
        elements
      }) {
        elements.floating.style.minWidth = `${rects.reference.width}px`;
      }
    }), flip({
      padding: 0
    })]
  });
  useHover$1(context, {
    enabled: isTriggerHovered,
    // Configure the delay for opening and closing separately.
    delay: {
      open: 200
    },
    handleClose: safePolygon()
  });
  const menuRef = useRef(null), triggerRef = useRef(null), itemRefs = useRef({});
  useEffect(() => {
    visible ? menuRef.current && (menuRef.current.focus(), setActiveIndex(0)) : (setActiveIndex(-1), itemRefs.current = {});
  }, [visible]), useEffect(() => {
    if (activeIndex !== -1) {
      const currentItem = Object.values(itemRefs.current)[activeIndex];
      if (currentItem) {
        const id2 = currentItem.getAttribute("id");
        setIsFocused(id2), currentItem.focus();
      }
    }
  }, [activeIndex]);
  const nextItem = () => {
    const itemCount = Object.values(itemRefs.current).length;
    setActiveIndex((prevIndex) => (prevIndex + 1) % itemCount);
  }, previousItem = () => {
    const itemCount = Object.values(itemRefs.current).length;
    setActiveIndex((prevIndex) => (prevIndex - 1 + itemCount) % itemCount);
  }, firstItem = () => {
    setActiveIndex(0);
  }, lastItem = () => {
    const itemCount = Object.values(itemRefs.current).length;
    setActiveIndex(itemCount - 1);
  }, openDropdown = useCallback(() => {
    setVisible(!0);
  }, []), closeDropdown = useCallback(() => {
    triggerRef.current && (triggerRef.current.focus({
      preventScroll: !0
    }), setVisible(!1));
  }, []), stopEvents = (flag, event) => {
    flag && (event.stopPropagation(), event.preventDefault());
  }, onTriggerKeyDown = useCallback((event) => {
    let flag = !1;
    switch (event.code) {
      case " ":
      case "Space":
      case "Enter":
      case "ArrowDown":
      case "Down":
        openDropdown(), flag = !0;
        break;
      case "Esc":
      case "Escape":
        closeDropdown(), flag = !0;
        break;
      case "Up":
      case "ArrowUp":
        openDropdown(), flag = !0;
        break;
    }
    extraTriggerKeyDownHandler == null || extraTriggerKeyDownHandler(event), stopEvents(flag, event);
  }, [closeDropdown, openDropdown]), onMenuItemMouseEnter = (event) => {
    const index = Object.values(itemRefs.current).findIndex((item) => item.id === event.currentTarget.getAttribute("id"));
    setActiveIndex(index);
  }, onMenuItemKeyDown = useCallback((event, onSuccess) => {
    let flag = !1;
    if (event.shiftKey)
      event.key === "Tab" && (closeDropdown(), flag = !0);
    else {
      switch (event.code) {
        case "Escape":
          closeDropdown();
          break;
        case " ":
        case "Enter":
          activeIndex !== -1 && (Object.values(itemRefs.current)[activeIndex].getAttribute("role") === "menuitem" && triggerRef.current && (triggerRef.current.focus(), setVisible(!1)), onSuccess == null || onSuccess()), flag = !0;
          break;
        case "ArrowDown":
        case "Down":
          nextItem(), flag = !0;
          break;
        case "ArrowUp":
        case "Up":
          previousItem(), flag = !0;
          break;
        case "Home":
          firstItem(), flag = !0;
          break;
        case "End":
          lastItem(), flag = !0;
          break;
      }
      stopEvents(flag, event);
    }
  }, [activeIndex, closeDropdown]), onTriggerClick = useCallback((event) => {
    setVisible(visible !== !0), event.stopPropagation(), event.preventDefault();
  }, [visible]);
  return {
    isFocused,
    visible,
    itemRefs,
    triggerRef,
    menuRef,
    /* TriggerProps to spread to any Trigger component */
    triggerProps: {
      ref: mergeRefs(triggerRef, refs.setReference),
      id: `dropdown-toggle-${id}`,
      "aria-haspopup": "menu",
      "aria-controls": `dropdown-${id}`,
      "aria-expanded": !!visible,
      className: `${visible ? "selected" : ""}`,
      onClick: onTriggerClick,
      onKeyDown: onTriggerKeyDown,
      "aria-activedescendant": isFocused
    },
    /* MenuProps to spread to any Menu Component */
    menuProps: {
      ref: mergeRefs(menuRef, refs.setFloating),
      className: "dropdown-menu",
      "aria-labelledby": `dropdown-toggle-${id}`,
      style: {
        ...floatingStyles
      }
    },
    /* ItemProps to spread to any item Component */
    itemProps: {
      onMenuItemMouseEnter,
      onMenuItemClick: closeDropdown,
      onMenuItemKeyDown
    },
    setVisible
  };
}, useDropdown$1 = useDropdown, useDropzone = (props) => {
  const [dragging, setDragging] = useState(!1), [files, setFiles] = useState([]), inputRef = useRef(null), addFile = (file) => {
    addFiles([file]);
  }, deleteFile = (file) => {
    setFiles((prevFiles) => prevFiles.filter((prevFile) => prevFile.name !== file.name));
  }, replaceFileAt = (index, file) => {
    setFiles((prevFiles) => {
      if (0 <= index && index < prevFiles.length) {
        const firstPart = prevFiles.slice(0, index), lastPart = index === prevFiles.length - 1 ? [] : prevFiles.slice(index + 1);
        return [...firstPart, file, ...lastPart];
      }
      return prevFiles;
    });
  }, applyInputFiltersOn = (files2) => {
    var _a;
    let filteredFiles = files2;
    if ((_a = inputRef.current) != null && _a.accept) {
      const filters = inputRef.current.accept.split(",").map((filter) => filter.trim().toLowerCase()), extensions = filters.filter((filter) => filter.startsWith(".")), mimes = filters.filter((filter) => !filter.startsWith(".")).map((mime) => mime.replace("*", ""));
      filteredFiles = [], files2.forEach((file) => {
        const fileName = file.name.toLowerCase();
        (extensions.some((extension) => fileName.endsWith(extension)) || mimes.some((mime) => file.type.includes(mime))) && filteredFiles.push(file);
      });
    }
    return filteredFiles;
  }, addFiles = (files2) => {
    let filesToAdd = files2.map((file) => (
      // #WB-3377: Remove special characters from the file name. (it can cause issues with vertx which replace it or remove it)
      new File([file], file.name.replace(/[!:,;="']/g, ""), {
        type: file.type
      })
    ));
    props != null && props.forceFilters ? (filesToAdd = applyInputFiltersOn(filesToAdd), filesToAdd && filesToAdd.length && setFiles((prevFiles) => [...prevFiles, ...filesToAdd])) : setFiles((prevFiles) => [...prevFiles, ...files2]);
  }, cleanFiles = () => {
    setFiles([]);
  }, handleOnChange = (event) => {
    const files2 = event.target.files;
    files2 && addFiles([...files2]);
  }, handleDragging = (event) => {
    event.preventDefault(), event.stopPropagation(), setDragging(!0);
  }, handleDragLeave = (event) => {
    event.preventDefault(), event.stopPropagation(), setDragging(!1);
  };
  return {
    /** Reference to an `input[type=file]` HTMLElement, null at first. */
    inputRef,
    /** Read-only list of File·s  managed by this hook. */
    files,
    /** Truthy when a drag event is triggered. */
    dragging,
    /** Callback to attach to your drop zone (any HTMLElement). */
    handleDragging,
    /** Callback to attach to your drop zone (any HTMLElement). */
    handleDragLeave,
    /** Callback to attach to your drop zone (any HTMLElement). */
    handleDrop: (event) => {
      var _a;
      handleDragLeave(event);
      const files2 = (_a = event.dataTransfer) == null ? void 0 : _a.files;
      files2 && (addFiles([...files2]), inputRef != null && inputRef.current && (inputRef.current.files = files2));
    },
    /** Replace a file in the `files` list. */
    replaceFileAt,
    /** Remove a file from the `files` list. */
    deleteFile,
    /** Add a file to the `files` list. */
    addFile,
    /** Add many files to the `files` list. */
    addFiles,
    /** Empty the `files` list. */
    cleanFiles,
    /** Callback to attach to your `input[type=file]` HTMLElement. */
    handleOnChange
  };
}, useDropzone$1 = useDropzone;
function useHover() {
  const [value, setValue] = useState(!1), ref = useRef(null), handleMouseOver = () => {
    setValue(!0);
  }, handleMouseOut = () => {
    setValue(!1);
  };
  return useEffect(
    () => {
      const node = ref.current;
      if (node)
        return node.addEventListener("mouseover", handleMouseOver), node.addEventListener("mouseout", handleMouseOut), () => {
          node.removeEventListener("mouseover", handleMouseOver), node.removeEventListener("mouseout", handleMouseOut);
        };
    },
    [ref]
    // Recall only if ref changes
  ), [ref, value];
}
function useKeyPress(callback, keyCodes) {
  const handler = useCallback(({
    code
  }) => {
    keyCodes.includes(code) && callback();
  }, [callback, keyCodes]);
  useEffect(() => (window.addEventListener("keydown", handler), () => {
    window.removeEventListener("keydown", handler);
  }), [handler]);
}
function useScrollToTop() {
  const refToTop = document.querySelector("html");
  return () => {
    refToTop && refToTop.scrollIntoView();
  };
}
function useTitle() {
  const documentDefined = typeof document < "u", [title, setTitle] = useState(() => document.title);
  return useEffect(() => {
    documentDefined && setTitle(document.title);
  }, [documentDefined]), title;
}
const IconButton = /* @__PURE__ */ forwardRef(({
  icon,
  className,
  ...restProps
}, ref) => {
  const buttonProps = {
    ...restProps,
    className: clsx("btn-icon btn-sm", className)
  };
  return /* @__PURE__ */ jsx(Button, { ref, ...buttonProps, children: icon });
}), IconButton$1 = IconButton, SearchButton = /* @__PURE__ */ forwardRef(({
  icon = /* @__PURE__ */ jsx(Search, {}),
  onClick,
  className,
  ...restProps
}, ref) => {
  const classes = clsx("btn-search", className);
  return /* @__PURE__ */ jsx(IconButton$1, { ref, className: classes, icon, onClick, ...restProps });
}), SearchButton$1 = SearchButton, Alert = /* @__PURE__ */ forwardRef(({
  type = "success",
  className = "",
  children,
  button,
  isDismissible = !1,
  isToast = !1,
  isConfirm = !1,
  position = "none",
  autoClose = !1,
  autoCloseDelay = 3e3,
  onClose,
  onVisibilityChange
}, ref) => {
  const [isVisible, setVisibleStatus] = useState(!0), refAlert = useRef(null), {
    t
  } = useTranslation(), hide = useCallback(() => {
    setVisibleStatus(!1), onClose == null || onClose();
  }, [onClose]);
  useImperativeHandle(ref, () => ({
    show,
    hide,
    ...refAlert.current
  })), useLayoutEffect(() => {
    onVisibilityChange == null || onVisibilityChange(isVisible);
  }, [isVisible, onVisibilityChange]), useEffect(() => {
    autoClose && isVisible && setTimeout(() => {
      hide();
    }, autoCloseDelay);
  }, [autoClose, autoCloseDelay, hide, isVisible]);
  const show = () => {
    setVisibleStatus(!0);
  }, mapping = {
    success: {
      icon: /* @__PURE__ */ jsx(SuccessOutline, {}),
      classModifier: "alert-success"
    },
    warning: {
      icon: /* @__PURE__ */ jsx(AlertCircle, {}),
      classModifier: "alert-warning"
    },
    info: {
      icon: /* @__PURE__ */ jsx(InfoCircle, {}),
      classModifier: "alert-info"
    },
    danger: {
      icon: /* @__PURE__ */ jsx(Error$1, {}),
      classModifier: "alert-danger"
    }
  }, toastClasses = {
    "is-dismissible": isDismissible,
    "is-toast ": isToast
  }, confirmClasses = {
    "is-confirm": isConfirm
  }, divContainerClasses = clsx("alert gap-12", mapping[type].classModifier, toastClasses, confirmClasses, position, className);
  return /* @__PURE__ */ jsx(Fragment, { children: isVisible ? /* @__PURE__ */ jsxs("div", { ref: refAlert, className: divContainerClasses, role: "alert", children: [
    !isConfirm && mapping[type].icon,
    /* @__PURE__ */ jsx("div", { className: "alert-content small", children }),
    button && /* @__PURE__ */ jsxs("div", { className: "ms-12", children: [
      button,
      " ",
      isConfirm && /* @__PURE__ */ jsx(Button, { onClick: hide, children: t("close") })
    ] }),
    (isDismissible || isConfirm) && /* @__PURE__ */ jsx("div", { className: "btn-close-container", children: /* @__PURE__ */ jsx("button", { type: "button", className: "btn-close", "data-bs-dismiss": "alert", "aria-label": t("close"), onClick: hide }) }),
    autoClose && /* @__PURE__ */ jsx("div", { className: "alert-progress", style: {
      transform: "scaleX(0)"
    } })
  ] }) : null });
}), Alert$1 = Alert, DEFAULT_POSITION = "top-right";
function useToast() {
  return {
    success: (message, options) => toast.custom(/* @__PURE__ */ jsx(Alert$1, { type: "success", isToast: !0, isDismissible: options == null ? void 0 : options.isDismissible, className: "mb-12", children: message }), {
      id: options == null ? void 0 : options.id,
      duration: options == null ? void 0 : options.duration,
      position: (options == null ? void 0 : options.position) ?? DEFAULT_POSITION
    }),
    error: (message, options) => toast.custom(/* @__PURE__ */ jsx(Alert$1, { type: "danger", isToast: !0, isDismissible: options == null ? void 0 : options.isDismissible, className: "mb-12", children: message }), {
      id: options == null ? void 0 : options.id,
      duration: options == null ? void 0 : options.duration,
      position: (options == null ? void 0 : options.position) ?? DEFAULT_POSITION
    }),
    info: (message, options) => toast.custom(/* @__PURE__ */ jsx(Alert$1, { type: "info", isToast: !0, isDismissible: options == null ? void 0 : options.isDismissible, className: "mb-12", children: message }), {
      id: options == null ? void 0 : options.id,
      duration: options == null ? void 0 : options.duration,
      position: (options == null ? void 0 : options.position) ?? DEFAULT_POSITION
    }),
    warning: (message, options) => toast.custom(/* @__PURE__ */ jsx(Alert$1, { type: "warning", isToast: !0, isDismissible: options == null ? void 0 : options.isDismissible, className: "mb-12", children: message }), {
      id: options == null ? void 0 : options.id,
      duration: options == null ? void 0 : options.duration,
      position: (options == null ? void 0 : options.position) ?? DEFAULT_POSITION
    }),
    loading: toast.loading,
    dismiss: (id) => toast.dismiss(id),
    remove: (id) => toast.remove(id)
  };
}
function useToggle(initialState2 = !1) {
  const [state, setState] = useState(initialState2), toggle = useCallback(() => {
    setState((prevState) => !prevState);
  }, []);
  return [state, toggle];
}
function useTrapFocus() {
  const ref = useRef(null), focusableElements = 'button:not([disabled]), [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
  return useEffect(() => {
    const node = ref.current, firstFocusableElement = node.querySelectorAll(focusableElements)[0], focusableContent = node.querySelectorAll(focusableElements), lastFocusableElement = ref && (focusableContent == null ? void 0 : focusableContent[focusableContent.length - 1]), handleKeydown = (event) => {
      event.key === "Tab" && (event.shiftKey ? document.activeElement === firstFocusableElement && (lastFocusableElement.focus(), event.preventDefault()) : document.activeElement === lastFocusableElement && (firstFocusableElement.focus(), event.preventDefault()));
    };
    if (node)
      return node.addEventListener("keydown", handleKeydown), () => {
        node.removeEventListener("keydown", handleKeydown);
      };
  }, []), ref;
}
const Root$4 = ({
  children,
  block,
  overflow = !0,
  placement = "bottom-start",
  extraTriggerKeyDownHandler,
  onToggle,
  isTriggerHovered = !1
}) => {
  const {
    visible,
    isFocused,
    triggerProps,
    menuProps,
    itemProps,
    itemRefs,
    setVisible
  } = useDropdown$1(placement, extraTriggerKeyDownHandler, isTriggerHovered), ref = useClickOutside(() => {
    setVisible(!1);
  }), value = useMemo(() => ({
    visible,
    isFocused,
    triggerProps,
    menuProps,
    itemProps,
    itemRefs,
    block,
    setVisible
  }), [visible, isFocused, triggerProps, menuProps, itemProps, itemRefs, block, setVisible]), dropdown = clsx("dropdown", {
    "w-100": block,
    overflow
  });
  return useEffect(() => {
    onToggle == null || onToggle(visible);
  }, [visible]), /* @__PURE__ */ jsx(DropdownContext.Provider, { value, children: /* @__PURE__ */ jsx("div", { ref, className: dropdown, children: typeof children == "function" ? children(triggerProps, itemRefs, setVisible) : children }) });
}, Dropdown = /* @__PURE__ */ Object.assign(Root$4, {
  Trigger: DropdownTrigger$1,
  Menu: DropdownMenu$1,
  Item: DropdownItem$1,
  Separator: DropdownSeparator$1,
  CheckboxItem: DropdownCheckboxItem$1,
  RadioItem: DropdownRadioItem$1,
  MenuGroup: DropdownMenuGroup$1
}), Dropdown$1 = Dropdown, useActivitiesOptions = () => {
  const {
    t
  } = useTranslation();
  return [{
    value: "bpr.activityType.classroomActivity",
    label: t("bpr.activityType.classroomActivity")
  }, {
    value: "bpr.activityType.groupActivity",
    label: t("bpr.activityType.groupActivity")
  }, {
    value: "bpr.activityType.personalActivity",
    label: t("bpr.activityType.personalActivity")
  }, {
    value: "bpr.activityType.homework",
    label: t("bpr.activityType.homework")
  }, {
    value: "bpr.activityType.exercize",
    label: t("bpr.activityType.exercize")
  }, {
    value: "bpr.activityType.learningPath",
    label: t("bpr.activityType.learningPath")
  }, {
    value: "bpr.activityType.courseElement",
    label: t("bpr.activityType.courseElement")
  }, {
    value: "bpr.other",
    label: t("bpr.other")
  }];
}, ActivitiesDropdown = ({
  control,
  selectedActivities,
  selectActivities
}) => {
  const activitiesOptions = useActivitiesOptions(), {
    t
  } = useTranslation();
  return /* @__PURE__ */ jsx("div", { className: "col d-flex", children: /* @__PURE__ */ jsx(Controller, { name: "activityType", control, rules: {
    required: !0
  }, render: ({
    field: {
      onChange
    }
  }) => /* @__PURE__ */ jsxs(Dropdown$1, { block: !0, overflow: !0, children: [
    /* @__PURE__ */ jsx(Dropdown$1.Trigger, { size: "md", label: t("bpr.form.publication.type"), badgeContent: selectedActivities == null ? void 0 : selectedActivities.length }),
    /* @__PURE__ */ jsx(Dropdown$1.Menu, { children: activitiesOptions.map((option, index) => /* @__PURE__ */ jsx(Dropdown$1.CheckboxItem, { value: option.value, model: selectedActivities, onChange: () => {
      selectActivities(option.value), onChange(option.value);
    }, children: option.label }, index)) })
  ] }) }) });
}, SelectTrigger = (props) => /* @__PURE__ */ jsx(Dropdown$1.Trigger, { ...props, "aria-haspopup": "listbox", role: "combobox" }), SelectTrigger$1 = SelectTrigger, Select = ({
  icon,
  options,
  overflow,
  block,
  variant,
  size: size2,
  disabled,
  placeholderOption,
  onValueChange
}) => {
  const [localValue, setLocalValue] = useState(), {
    t
  } = useTranslation();
  useEffect(() => {
    if (localValue) {
      const value = typeof localValue == "object" ? localValue.value : localValue;
      onValueChange == null || onValueChange(value);
    }
  }, [localValue]);
  const label = typeof localValue == "object" ? localValue.label : localValue, iconChange = typeof localValue == "object" ? localValue.icon : void 0;
  return /* @__PURE__ */ jsxs(Dropdown$1, { overflow, block, children: [
    /* @__PURE__ */ jsx(SelectTrigger$1, { icon: iconChange || icon, label: t(label || placeholderOption), variant, size: size2, disabled }),
    /* @__PURE__ */ jsx(Dropdown$1.Menu, { role: "listbox", children: options == null ? void 0 : options.map((option) => {
      const value = typeof option == "object" ? option.value : option, label2 = typeof option == "object" ? option.label : option, icon2 = typeof option == "object" ? option.icon : void 0;
      return /* @__PURE__ */ jsx(Dropdown$1.Item, { type: "action", onClick: () => setLocalValue(option), icon: icon2, children: label2 }, value);
    }) })
  ] });
}, Select$1 = Select, ageOptions = ["3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18"], AgeSelect = ({
  name,
  control,
  placeholderOption,
  validate
}) => /* @__PURE__ */ jsx(Controller, { name, control, rules: {
  required: !0,
  validate
}, render: ({
  field: {
    onChange
  }
}) => /* @__PURE__ */ jsx(Select$1, { block: !0, size: "md", onValueChange: onChange, options: ageOptions, "aria-required": !0, placeholderOption }) }), useLanguageOptions = () => {
  const {
    t
  } = useTranslation();
  return [{
    value: "de_DE",
    label: t("de_DE")
  }, {
    value: "en_EN",
    label: t("en_EN")
  }, {
    value: "ar_DZ",
    label: t("ar_DZ")
  }, {
    value: "es_ES",
    label: t("es_ES")
  }, {
    value: "fr_FR",
    label: t("fr_FR")
  }, {
    value: "it_IT",
    label: t("it_IT")
  }, {
    value: "ja_JP",
    label: t("ja_JP")
  }, {
    value: "zh_CN",
    label: t("zh_CN")
  }, {
    value: "pt_PT",
    label: t("pt_PT")
  }, {
    value: "ru_RU",
    label: t("ru_RU")
  }, {
    value: "bpr.other",
    label: t("bpr.other")
  }];
}, defaultSelectLanguageOption = "bpr.form.publication.language", LangSelect = ({
  control
}) => {
  const languageOptions = useLanguageOptions();
  return /* @__PURE__ */ jsx("div", { className: "col", children: /* @__PURE__ */ jsx(Controller, { name: "language", control, rules: {
    required: !0
  }, render: ({
    field: {
      onChange
    }
  }) => /* @__PURE__ */ jsx(Select$1, { block: !0, size: "md", onValueChange: onChange, options: languageOptions, "aria-required": !0, placeholderOption: defaultSelectLanguageOption }) }) });
}, PublishModalFooter = () => {
  const {
    t
  } = useTranslation(), [imagePath] = usePaths();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("ul", { className: "mb-12", children: [
      /* @__PURE__ */ jsxs("li", { children: [
        t("bpr.form.publication.licence.text.1"),
        /* @__PURE__ */ jsx("img", { className: "ms-8 d-inline-block", src: `${imagePath}/common/image-creative-commons.png`, alt: "licence creative commons" })
      ] }),
      /* @__PURE__ */ jsx("li", { children: t("bpr.form.publication.licence.text.2") })
    ] }),
    /* @__PURE__ */ jsx(Alert$1, { type: "info", className: "mb-12", children: t("bpr.form.publication.licence.text.3") }),
    /* @__PURE__ */ jsx(Alert$1, { type: "warning", children: t("bpr.form.publication.licence.text.4") })
  ] });
}, useSubjectsOptions = () => {
  const {
    t
  } = useTranslation();
  return [{
    value: "bpr.subjectArea.artActivity",
    label: t("bpr.subjectArea.artActivity")
  }, {
    value: "bpr.subjectArea.readLearning",
    label: t("bpr.subjectArea.readLearning")
  }, {
    value: "bpr.subjectArea.chemistry",
    label: t("bpr.subjectArea.chemistry")
  }, {
    value: "bpr.subjectArea.law",
    label: t("bpr.subjectArea.law")
  }, {
    value: "bpr.subjectArea.worldDiscovery",
    label: t("bpr.subjectArea.worldDiscovery")
  }, {
    value: "bpr.subjectArea.economy",
    label: t("bpr.subjectArea.economy")
  }, {
    value: "bpr.subjectArea.mediaEducation",
    label: t("bpr.subjectArea.mediaEducation")
  }, {
    value: "bpr.subjectArea.musicEducation",
    label: t("bpr.subjectArea.musicEducation")
  }, {
    value: "bpr.subjectArea.sportEducation",
    label: t("bpr.subjectArea.sportEducation")
  }, {
    value: "bpr.subjectArea.citizenshipEducation",
    label: t("bpr.subjectArea.citizenshipEducation")
  }, {
    value: "bpr.subjectArea.geography",
    label: t("bpr.subjectArea.geography")
  }, {
    value: "bpr.subjectArea.history",
    label: t("bpr.subjectArea.history")
  }, {
    value: "bpr.subjectArea.artHistory",
    label: t("bpr.subjectArea.artHistory")
  }, {
    value: "bpr.subjectArea.ComputerScience",
    label: t("bpr.subjectArea.ComputerScience")
  }, {
    value: "bpr.subjectArea.languages",
    label: t("bpr.subjectArea.languages")
  }, {
    value: "bpr.subjectArea.italian",
    label: t("bpr.subjectArea.italian")
  }, {
    value: "bpr.subjectArea.spanish",
    label: t("bpr.subjectArea.spanish")
  }, {
    value: "bpr.subjectArea.french",
    label: t("bpr.subjectArea.french")
  }, {
    value: "bpr.subjectArea.german",
    label: t("bpr.subjectArea.german")
  }, {
    value: "bpr.subjectArea.english",
    label: t("bpr.subjectArea.english")
  }, {
    value: "bpr.subjectArea.ancientLanguages",
    label: t("bpr.subjectArea.ancientLanguages")
  }, {
    value: "bpr.subjectArea.literature",
    label: t("bpr.subjectArea.literature")
  }, {
    value: "bpr.subjectArea.mathematics",
    label: t("bpr.subjectArea.mathematics")
  }, {
    value: "bpr.subjectArea.vocationalGuidance",
    label: t("bpr.subjectArea.vocationalGuidance")
  }, {
    value: "bpr.subjectArea.philosohppy",
    label: t("bpr.subjectArea.philosohppy")
  }, {
    value: "bpr.subjectArea.physics",
    label: t("bpr.subjectArea.physics")
  }, {
    value: "bpr.subjectArea.politicalSscience",
    label: t("bpr.subjectArea.politicalSscience")
  }, {
    value: "bpr.subjectArea.sociology",
    label: t("bpr.subjectArea.sociology")
  }, {
    value: "bpr.subjectArea.biology",
    label: t("bpr.subjectArea.biology")
  }, {
    value: "bpr.subjectArea.geology",
    label: t("bpr.subjectArea.geology")
  }, {
    value: "bpr.subjectArea.technology",
    label: t("bpr.subjectArea.technology")
  }, {
    value: "bpr.subjectArea.Arabic",
    label: t("bpr.subjectArea.Arabic")
  }, {
    value: "bpr.subjectArea.Chinese",
    label: t("bpr.subjectArea.Chinese")
  }, {
    value: "bpr.subjectArea.NaturalSciences",
    label: t("bpr.subjectArea.NaturalSciences")
  }, {
    value: "bpr.subjectArea.SocioEmotionalEducation",
    label: t("bpr.subjectArea.SocioEmotionalEducation")
  }, {
    value: "bpr.other",
    label: t("bpr.other")
  }];
}, SubjectsDropdown = ({
  control,
  selectedSubjectAreas,
  selectSubjects
}) => {
  const subjectsOptions = useSubjectsOptions(), {
    t
  } = useTranslation();
  return /* @__PURE__ */ jsx("div", { className: "col d-flex", children: /* @__PURE__ */ jsx(Controller, { name: "subjectArea", control, rules: {
    required: !0
  }, render: ({
    field: {
      onChange
    }
  }) => /* @__PURE__ */ jsxs(Dropdown$1, { block: !0, overflow: !0, children: [
    /* @__PURE__ */ jsx(Dropdown$1.Trigger, { size: "md", label: t("bpr.form.publication.discipline"), badgeContent: selectedSubjectAreas == null ? void 0 : selectedSubjectAreas.length }),
    /* @__PURE__ */ jsx(Dropdown$1.Menu, { children: subjectsOptions.map((option, index) => /* @__PURE__ */ jsx(Dropdown$1.CheckboxItem, { value: option.value, model: selectedSubjectAreas, onChange: () => {
      selectSubjects(option.value), onChange(option.value);
    }, children: option.label }, index)) })
  ] }) }) });
}, ThemeContext = /* @__PURE__ */ createContext(null);
function ThemeProvider({
  defaultTheme,
  children
}) {
  var _a;
  const {
    appCode
  } = useOdeClient(), confQuery = useConf({
    appCode
  });
  useEffect(() => {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const favicon = document.getElementById("favicon");
    favicon.href = `${(_b = (_a2 = confQuery == null ? void 0 : confQuery.data) == null ? void 0 : _a2.theme) == null ? void 0 : _b.basePath}/img/illustrations/favicon.ico`;
    const bootstrapVersion = (_e = (_d = (_c = confQuery == null ? void 0 : confQuery.data) == null ? void 0 : _c.theme) == null ? void 0 : _d.bootstrapVersion) == null ? void 0 : _e.split("-"), dataProduct = bootstrapVersion ? bootstrapVersion[bootstrapVersion.length - 1] : void 0;
    [{
      data: "data-skin",
      value: (_g = (_f = confQuery == null ? void 0 : confQuery.data) == null ? void 0 : _f.theme) == null ? void 0 : _g.skinName
    }, {
      data: "data-theme",
      // WB2-1885, add npmTheme for dynamic theme on springboard
      value: ((_i = (_h = confQuery == null ? void 0 : confQuery.data) == null ? void 0 : _h.theme) == null ? void 0 : _i.npmTheme) ?? ((_k = (_j = confQuery == null ? void 0 : confQuery.data) == null ? void 0 : _j.theme) == null ? void 0 : _k.themeName)
    }, {
      data: "data-product",
      value: defaultTheme === "none" ? "" : defaultTheme ?? dataProduct
    }].forEach((attribute) => {
      var _a3;
      return (_a3 = document.querySelector("html")) == null ? void 0 : _a3.setAttribute(attribute.data, attribute.value);
    });
  }, [confQuery == null ? void 0 : confQuery.data, defaultTheme]);
  const values = useMemo(() => {
    var _a2;
    return {
      theme: (_a2 = confQuery == null ? void 0 : confQuery.data) == null ? void 0 : _a2.theme
    };
  }, [(_a = confQuery == null ? void 0 : confQuery.data) == null ? void 0 : _a.theme]);
  return /* @__PURE__ */ jsx(ThemeContext.Provider, { value: values, children });
}
function useOdeTheme() {
  const context = useContext(ThemeContext);
  if (!context)
    throw new Error("Cannot be used outside of OdeClientProvider");
  return context;
}
const CardBody = ({
  children,
  space = null,
  flexDirection = "row"
}) => {
  const cardbody = clsx("card-body", {
    [`p-${space}`]: space,
    [`gap-${space}`]: space,
    "align-items-start": flexDirection === "column",
    "flex-column": flexDirection === "column"
  });
  return /* @__PURE__ */ jsx("div", { className: cardbody, children });
}, CardBody$1 = CardBody, CardContext = /* @__PURE__ */ createContext(null), useCardContext = () => {
  const context = useContext(CardContext);
  if (!context)
    throw new Error("Cannot be rendered outside the Card component");
  return context;
}, CardFooter = ({
  children
}) => /* @__PURE__ */ jsx("div", { className: "card-footer gap-16", children }), CardFooter$1 = CardFooter, CardHeader = () => {
  const {
    isSelectable,
    isClickable,
    onClick,
    onSelect
  } = useCardContext(), {
    t
  } = useTranslation();
  return isSelectable || isClickable ? /* @__PURE__ */ jsxs("div", { className: "card-header", children: [
    isSelectable ? /* @__PURE__ */ jsx(IconButton$1, { "aria-label": t("card.open.menu"), className: "z-3 bg-white", color: "secondary", icon: /* @__PURE__ */ jsx(Options, {}), onClick: onSelect, variant: "ghost" }) : null,
    isClickable ? /* @__PURE__ */ jsx("button", { type: "button", onClick, className: "position-absolute bottom-0 end-0 top-0 start-0 opacity-0 z-1 w-100", "aria-label": t("card.open.resource") }) : null
  ] }) : null;
}, CardHeader$1 = CardHeader, AppIcon = /* @__PURE__ */ forwardRef(({
  app,
  size: size2 = "24",
  iconFit = "contain",
  variant = "square",
  className = ""
}, ref) => {
  const {
    isIconUrl,
    getIconCode
  } = useOdeIcons(), [, iconPath] = usePaths(), isSquare = variant === "square", isRounded = variant === "rounded", isCircle = variant === "circle", isContain = iconFit === "contain", isRatio = iconFit === "ratio", iconSizes = {
    "icon-xs": size2 === "24",
    "icon-sm": size2 === "40",
    "icon-md": size2 === "48",
    "icon-lg": size2 === "80",
    "icon-xl": size2 === "160"
  }, iconVariant = {
    square: isSquare,
    rounded: isRounded,
    "rounded-circle": isCircle
  }, iconFits = {
    "icon-contain": isContain,
    "icon-ratio": isRatio
  }, icon = typeof app == "string" ? app : (app == null ? void 0 : app.icon) !== void 0 ? app.icon : "placeholder", displayName = typeof app != "string" && (app == null ? void 0 : app.displayName) !== void 0 ? app.displayName : "", code = app ? getIconCode(app) : "", isIconURL = isIconUrl(icon), appCode = code || "placeholder";
  if (isIconURL) {
    const classes2 = clsx("h-full", className);
    return /* @__PURE__ */ jsx(Image$1, { src: icon, alt: displayName, objectFit: "contain", width: size2, height: size2, className: classes2, style: {
      minWidth: size2 + "px"
    } });
  }
  const classes = clsx("app-icon", {
    ...iconSizes,
    ...iconVariant,
    ...iconFits,
    [`bg-light-${appCode}`]: appCode && !isContain,
    [`color-app-${appCode}`]: appCode
  }, className);
  return /* @__PURE__ */ jsx("div", { className: classes, style: {
    width: size2 + "px",
    height: size2 + "px"
  }, children: /* @__PURE__ */ jsx("svg", { ref, width: size2, height: size2, role: "img", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: /* @__PURE__ */ jsx("use", { xlinkHref: `${iconPath}/apps.svg#${appCode}` }) }) });
}), AppIcon$1 = AppIcon, CardImage = ({
  imageSrc,
  className,
  variant = "medium"
}) => {
  const {
    app
  } = useCardContext(), style = variant === "landscape" ? {
    width: "100%",
    height: "auto"
  } : null;
  return /* @__PURE__ */ jsx("div", { className: clsx("card-image", variant), children: imageSrc ? /* @__PURE__ */ jsx(Image$1, { alt: "", src: imageSrc, objectFit: "cover", className: clsx("h-full w-100", className) }) : /* @__PURE__ */ jsx(AppIcon$1, { app, iconFit: "ratio", size: "80", variant: "rounded", ...style }) });
}, CardImage$1 = CardImage, CardText = ({
  children,
  className
}) => {
  const text = clsx("card-text small text-break text-truncate text-truncate-1", className);
  return /* @__PURE__ */ jsx("p", { className: text, children });
}, CardText$1 = CardText, CardTitle = ({
  children,
  className
}) => {
  const title = clsx("card-title body text-break text-truncate text-truncate-2", className);
  return /* @__PURE__ */ jsx("h3", { className: title, children: /* @__PURE__ */ jsx("strong", { children }) });
}, CardTitle$1 = CardTitle, CardUser = ({
  userSrc,
  creatorName
}) => userSrc ? /* @__PURE__ */ jsx(Avatar, { alt: creatorName || "", size: "xs", src: userSrc, variant: "circle", width: "24", height: "24" }) : /* @__PURE__ */ jsx(OneProfile, {}), CardUser$1 = CardUser, Root$3 = /* @__PURE__ */ forwardRef(({
  app,
  isSelectable = !0,
  isClickable = !0,
  isSelected = !1,
  isFocused = !1,
  onClick,
  onSelect,
  children,
  className
}, ref) => {
  const {
    getIconCode
  } = useOdeIcons(), appCode = app ? getIconCode(app) : "placeholder", values = useMemo(() => ({
    app,
    appCode,
    isSelectable,
    isClickable,
    onClick,
    onSelect
  }), [app, appCode, isSelectable, isClickable, onClick, onSelect]);
  return /* @__PURE__ */ jsx(CardContext.Provider, { value: values, children: /* @__PURE__ */ jsxs("div", { ref, className: clsx("card", {
    "drag-focus": isFocused,
    "is-selected": isSelected,
    "c-pointer": isClickable
  }, className), children: [
    /* @__PURE__ */ jsx(Card.Header, {}),
    typeof children == "function" ? children(appCode) : children
  ] }) });
}), Card = /* @__PURE__ */ Object.assign(Root$3, {
  Title: CardTitle$1,
  Text: CardText$1,
  Image: CardImage$1,
  Body: CardBody$1,
  User: CardUser$1,
  Footer: CardFooter$1,
  Header: CardHeader$1
}), Card$1 = Card;
function useThumbnail(src, options) {
  const [status, setStatus] = useState(null), {
    ref: inViewRef,
    inView
  } = useInView({
    triggerOnce: !0,
    ...options == null ? void 0 : options.intersectionOptions
  });
  return useEffect(() => {
    var _a;
    (_a = options == null ? void 0 : options.ref) != null && _a.current && (inViewRef == null || inViewRef(options.ref.current));
  }, [options == null ? void 0 : options.ref, inViewRef]), useEffect(() => {
    if ((options == null ? void 0 : options.ref) === void 0 || inView) {
      const img = new Image();
      return img.src = src, img.onload = () => {
        setStatus(!0);
      }, img.onerror = () => {
        setStatus(!1);
      }, () => {
        img.onload = null, img.onerror = null, setStatus(null);
      };
    }
  }, [inView]), status;
}
const FileIcon = ({
  type,
  roleMap
}) => {
  const hasNoShadow = typeof (roleMap == null ? void 0 : roleMap.icon) != "string" && type !== "unknown", fileicon = clsx("position-absolute top-50 start-50 translate-middle", {
    "p-12 rounded-circle shadow": hasNoShadow
  }, roleMap == null ? void 0 : roleMap.color);
  return /* @__PURE__ */ jsx("div", { className: fileicon, children: (roleMap == null ? void 0 : roleMap.icon) ?? /* @__PURE__ */ jsx(Paperclip, {}) });
}, FileIcon$1 = FileIcon, FileCard = ({
  doc,
  isClickable = !0,
  isSelectable = !1,
  isSelected = !1,
  onClick,
  className
}) => {
  var _a;
  const ref = useRef(null), type = DocumentHelper.getRole(doc);
  function getRoleMap(type2) {
    const roleMappings = {
      csv: {
        icon: ".CSV",
        color: "bg-orange-200"
      },
      xls: {
        icon: ".XLS",
        color: "bg-green-200"
      },
      doc: {
        icon: ".DOC",
        color: "bg-blue-200"
      },
      txt: {
        icon: ".TXT",
        color: "bg-blue-200"
      },
      pdf: {
        icon: ".PDF",
        color: "bg-red-200"
      },
      audio: {
        icon: /* @__PURE__ */ jsx(Mic, { width: 22, height: 22 }),
        color: "bg-red-200"
      },
      ppt: {
        icon: ".PPT",
        color: "bg-yellow-200"
      },
      img: {
        icon: /* @__PURE__ */ jsx(Landscape, { width: 22, height: 22 }),
        color: "bg-green-200"
      },
      video: {
        icon: /* @__PURE__ */ jsx(Video$1, { width: 22, height: 22 }),
        color: "bg-purple-200"
      },
      zip: {
        icon: ".ZIP",
        color: "bg-gray-300"
      },
      md: {
        icon: ".MD",
        color: "bg-blue-200"
      },
      unknown: {
        icon: /* @__PURE__ */ jsx(TextPage, { width: 22, height: 22 }),
        color: "bg-gray-300"
      }
    };
    return roleMappings[type2] || roleMappings.unknown;
  }
  const file = clsx("file position-relative rounded", ((_a = getRoleMap(type ?? "default")) == null ? void 0 : _a.color) ?? "bg-yellow-200"), mediaSrc = type === "img" || type === "video" ? odeServices.workspace().getThumbnailUrl(doc) : null, hasThumbnail = useThumbnail(mediaSrc, {
    ref
  }), imageStyles = hasThumbnail && {
    backgroundImage: `url(${mediaSrc})`,
    backgroundSize: "cover"
  };
  return /* @__PURE__ */ jsx(Card$1, { className: clsx("card-file", className), isClickable, isSelectable, isSelected, onClick, children: /* @__PURE__ */ jsxs(Card$1.Body, { space: "8", children: [
    /* @__PURE__ */ jsx("div", { ref, className: file, style: {
      aspectRatio: "16/10",
      ...imageStyles
    }, children: type !== "img" || type === "img" && !hasThumbnail ? /* @__PURE__ */ jsx(FileIcon$1, { type, roleMap: getRoleMap(type) }) : null }),
    /* @__PURE__ */ jsxs("div", { className: "mt-4", children: [
      /* @__PURE__ */ jsx(Card$1.Text, { children: doc.name }),
      /* @__PURE__ */ jsx(Card$1.Text, { className: "text-black-50", children: doc == null ? void 0 : doc.ownerName })
    ] })
  ] }) });
}, FileCard$1 = FileCard, UploadCard = ({
  item,
  status = "idle",
  isClickable = !1,
  isSelectable = !1,
  onDelete,
  onEdit,
  onRetry
}) => {
  const [imagePath] = usePaths(), {
    t
  } = useTranslation(), {
    src,
    name,
    info
  } = item, isIdle = status === "idle", isLoading = status === "loading", isSuccess = status === "success", isTypeImage = info == null ? void 0 : info.type.startsWith("image"), imgPlaceholder = `${imagePath}/common/image-placeholder.png`, defaultMapping = {
    text: "",
    context: null,
    image: /* @__PURE__ */ jsx("img", { src: imgPlaceholder, alt: "", width: "48", height: "48" })
  }, mapping = {
    error: {
      text: /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsx("small", { className: "text-danger caption", children: t("tiptap.upload.error") }) }),
      context: /* @__PURE__ */ jsx(Button, { leftIcon: /* @__PURE__ */ jsx(Reset, {}), variant: "ghost", color: "tertiary", onClick: onRetry, children: t("tiptap.upload.retry") }),
      image: /* @__PURE__ */ jsx(Image$1, { alt: "", src: `${imagePath}/common/image-status-error.svg`, objectFit: "cover" })
    },
    idle: defaultMapping,
    loading: {
      text: "",
      context: /* @__PURE__ */ jsx(Tooltip$1, { message: t("tiptap.tooltip.upload.loading"), placement: "top", children: /* @__PURE__ */ jsx(Loading, { isLoading: !0, loadingPosition: "left", className: "text-secondary" }) }),
      image: defaultMapping.image
    },
    warning: defaultMapping,
    success: {
      text: /* @__PURE__ */ jsxs("em", { children: [
        info == null ? void 0 : info.type,
        " ",
        (info == null ? void 0 : info.weight) && `- ${info.weight}`
      ] }),
      context: /* @__PURE__ */ jsx(Tooltip$1, { message: t("tiptap.tooltip.upload.loaded"), placement: "top", children: /* @__PURE__ */ jsx(SuccessOutline, { className: "text-success" }) }),
      image: /* @__PURE__ */ jsx(Image$1, { alt: "", src: src ?? "", width: "48", objectFit: "cover", className: "rounded", style: {
        aspectRatio: 1 / 1
      } })
    },
    unknown: defaultMapping
  }, canEditItem = () => isTypeImage && /* @__PURE__ */ jsx(Tooltip$1, { message: t("tiptap.tooltip.upload.edit"), placement: "top", children: /* @__PURE__ */ jsx(IconButton$1, { icon: /* @__PURE__ */ jsx(Wand, {}), variant: "ghost", "aria-label": t("tiptap.tooltip.upload.loading"), disabled: isLoading || !isSuccess, onClick: onEdit, color: "secondary" }) });
  return /* @__PURE__ */ jsx(Card$1, { isClickable, isSelectable, className: "card-upload", children: /* @__PURE__ */ jsxs(Card$1.Body, { children: [
    /* @__PURE__ */ jsx("div", { className: "card-image", children: mapping[status].image }),
    /* @__PURE__ */ jsxs("div", { className: "text-truncate", children: [
      /* @__PURE__ */ jsx(Card$1.Text, { children: name }),
      /* @__PURE__ */ jsx(Card$1.Text, { className: "caption", children: mapping[status].text })
    ] }),
    !isIdle && /* @__PURE__ */ jsx("div", { className: "ms-auto", children: /* @__PURE__ */ jsxs("div", { className: "d-flex align-items-center gap-12", children: [
      mapping[status].context,
      !isIdle && /* @__PURE__ */ jsx("div", { className: "vr" }),
      canEditItem(),
      /* @__PURE__ */ jsx(Tooltip$1, { message: t("tiptap.tooltip.upload.delete"), placement: "top", children: /* @__PURE__ */ jsx(IconButton$1, { icon: /* @__PURE__ */ jsx(Close, {}), variant: "ghost", "aria-label": t("tiptap.tooltip.upload.delete"), color: "tertiary", onClick: onDelete }) })
    ] }) })
  ] }) });
}, UploadCard$1 = UploadCard, ActionBar = /* @__PURE__ */ forwardRef(({
  children
}, ref) => /* @__PURE__ */ jsx("div", { ref, className: "actionbar", children })), ActionBar$1 = ActionBar, AppHeader = /* @__PURE__ */ forwardRef(({
  children,
  render,
  isFullscreen = !1,
  ...restProps
}, ref) => {
  const classes = clsx("d-flex flex-wrap p-16 gap-8 border-bottom bg-white", {
    "justify-content-between": render,
    "mx-n16": !isFullscreen,
    "z-3 top-0 start-0 end-0": isFullscreen
  });
  return /* @__PURE__ */ jsxs("div", { ref, className: classes, ...restProps, children: [
    children,
    render ? /* @__PURE__ */ jsx("div", { className: "d-flex align-items-center ms-auto gap-8", children: render() }) : null
  ] });
}), AppHeader$1 = AppHeader, Attachment = /* @__PURE__ */ forwardRef(({
  name = "Attachment Name",
  options,
  ...restProps
}, ref) => /* @__PURE__ */ jsxs("div", { ref, className: "attachment px-12 py-8", ...restProps, children: [
  /* @__PURE__ */ jsxs(Tooltip$1, { message: name, className: "filename text-truncate d-flex align-items-center gap-8", children: [
    /* @__PURE__ */ jsx(Paperclip, { height: 22, width: 22 }),
    /* @__PURE__ */ jsx("div", { className: "filename text-truncate", children: name })
  ] }),
  options && /* @__PURE__ */ jsx("div", { className: "options ps-12", children: options })
] })), Attachment$1 = Attachment;
function getDragDepth(offset2, indentationWidth) {
  return Math.round(offset2 / indentationWidth);
}
function getSubtreeIndices(flattenedTree, activeIndex) {
  const indices = [activeIndex], nodeIds = [flattenedTree[activeIndex].id];
  for (let i = activeIndex + 1; i < flattenedTree.length; i++) {
    const item = flattenedTree[i];
    item.parentId && nodeIds.includes(item.parentId) && (indices.push(i), nodeIds.push(item.id));
  }
  return indices;
}
function determineNewParentId(active, over, activeNode, overNode, projected) {
  if (projected && (projected.depth === 0 || projected.depth === 1))
    return projected.parentId;
  if (active.id !== (over == null ? void 0 : over.id) && overNode)
    return overNode.parentId === activeNode.parentId ? activeNode.parentId : overNode.parentId;
}
function getActiveAndOverNodes(tree, activeId, overId) {
  const activeNodeIndex = tree.findIndex(({
    id
  }) => id === activeId), overNodeIndex = overId ? tree.findIndex(({
    id
  }) => id === overId) : -1, activeNode = tree[activeNodeIndex], overNode = overNodeIndex !== -1 ? tree[overNodeIndex] : null;
  return {
    activeNode,
    activeNodeIndex,
    overNode,
    overNodeIndex
  };
}
function getIndicesToUpdate(activeNode, activeNodeIndex, flattenedTree, projected) {
  return activeNode.children && activeNode.children.length > 0 && (projected == null ? void 0 : projected.depth) === 1 ? getSubtreeIndices(flattenedTree, activeNodeIndex) : [activeNodeIndex];
}
function flattenTree(tree, parentId, depth = 0) {
  return tree.reduce((acc, node) => (acc.push({
    id: node.id,
    name: node.name,
    parentId: parentId ?? null,
    position: node.position ?? void 0,
    depth: depth ?? 0,
    children: node.children,
    isVisible: node.isVisible
  }), node.children && node.children.length > 0 && (acc = acc.concat(flattenTree(node.children, node.id, depth + 1))), acc), []);
}
function updateParentIds(flattenedTree, indices, newParentId) {
  indices.forEach((index) => {
    flattenedTree[index] = {
      ...flattenedTree[index],
      parentId: newParentId
    };
  });
}
function findItemIndexInTree(tree, itemId) {
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    if (node.id === itemId)
      return i;
    if (node.children && node.children.length > 0) {
      const result = findItemIndexInTree(node.children, itemId);
      if (result)
        return result;
    }
  }
  return 0;
}
function generateUpdateData(updatedFlattenedTree, tree) {
  const updateArray = [];
  let positionCounter = 0;
  const itemMap = /* @__PURE__ */ new Map();
  updatedFlattenedTree.forEach((item) => {
    itemMap.set(item.id, item);
  });
  function traverse(items, parentId) {
    for (const item of items) {
      const updateItem = {
        _id: item.id,
        position: positionCounter,
        parentId: parentId ?? void 0,
        isVisible: item.isVisible
      };
      updateArray.push(updateItem);
      const flattenedItem = itemMap.get(item.id);
      flattenedItem && (flattenedItem.position = positionCounter), positionCounter++, item.children && item.children.length > 0 && traverse(item.children, item.id);
    }
  }
  return traverse(tree, null), {
    updateArray,
    updatedTreeData: updatedFlattenedTree
  };
}
const buildTree = (flatNodes) => {
  const nodeMap = /* @__PURE__ */ new Map();
  flatNodes.forEach((node) => {
    nodeMap.set(node.id, {
      id: node.id,
      name: node.name,
      children: [],
      position: node.position,
      isVisible: node.isVisible
    });
  });
  const tree = [];
  return flatNodes.forEach((node) => {
    var _a;
    const treeNode = nodeMap.get(node.id);
    if (node.parentId === null || node.parentId === void 0)
      tree.push(treeNode);
    else {
      const parentNode = nodeMap.get(node.parentId);
      parentNode && (parentNode.children = parentNode.children ?? void 0, (_a = parentNode.children) == null || _a.push(treeNode));
    }
  }), tree;
};
function getProjection(items, activeId, overId, dragOffset, indentationWidth) {
  const overItemIndex = items.findIndex(({
    id
  }) => id === overId), activeItemIndex = items.findIndex(({
    id
  }) => id === activeId), activeItem = items[activeItemIndex], newItems = arrayMove(items, activeItemIndex, overItemIndex), previousItem = newItems[overItemIndex - 1], dragDepth = getDragDepth(dragOffset, indentationWidth), projectedDepth = activeItem.depth + dragDepth;
  let depth = projectedDepth + activeItem.depth;
  return previousItem ? depth = Math.max(0, Math.min(1, projectedDepth)) : depth = 0, {
    depth,
    parentId: getParentId(),
    activeId,
    previousItem
  };
  function getParentId() {
    var _a;
    return depth === 0 || !previousItem ? null : depth === previousItem.depth ? previousItem.parentId : depth > previousItem.depth ? previousItem.id : ((_a = newItems.slice(0, overItemIndex).reverse().find((item) => item.depth === depth)) == null ? void 0 : _a.parentId) ?? null;
  }
}
function findNodeById$1(data, id) {
  if (Array.isArray(data))
    for (const node of data) {
      const result = findNodeById$1(node, id);
      if (result)
        return result;
    }
  else {
    if (data.id === id)
      return data;
    if (data.children)
      for (const child of data.children) {
        const result = findNodeById$1(child, id);
        if (result)
          return result;
      }
  }
}
function addNode(node, {
  parentId,
  newFolder
}) {
  return modifyNode(node, (node2) => {
    var _a;
    if (node2.id === parentId) {
      const parentAncestors = [...((_a = node2.folder) == null ? void 0 : _a.ancestors) || []], ancestors = arrayUnique([...parentAncestors, node2.id]);
      return {
        ...node2,
        children: [...node2.children || [], new TreeNodeFolderWrapper({
          ...newFolder,
          ancestors
        })]
      };
    } else
      return node2;
  });
}
function arrayUnique(array) {
  return array.filter((item, index) => array.indexOf(item) === index);
}
function deleteNode(node, {
  folders
}) {
  return modifyNode(node, (node2) => {
    if (!folders.includes(node2.id))
      return node2;
  });
}
const findParentNode = (parentNode, childId) => {
  if (parentNode.children)
    for (const child of parentNode.children) {
      if (child.id === childId)
        return parentNode;
      const foundNode = findParentNode(child, childId);
      if (foundNode)
        return foundNode;
    }
};
function getAncestors(data, folderId) {
  var _a;
  const findItem = findNodeById$1(data, folderId);
  return (_a = findItem == null ? void 0 : findItem.folder) != null && _a.ancestors ? [...(findItem == null ? void 0 : findItem.folder.ancestors) || [], folderId] : folderId === FOLDER.BIN ? [FOLDER.BIN] : [FOLDER.DEFAULT];
}
function hasChildren(folderId, data) {
  return data.id === folderId && data.children ? data.children.length > 0 : data.children ? data.children.some((child) => hasChildren(data.id, child)) : !1;
}
function modifyNode(data, callback) {
  return doModify(data, callback) || data;
}
function doModify(current, callback, parent) {
  var _a;
  const result = callback(current, parent);
  if ((_a = result == null ? void 0 : result.children) != null && _a.length) {
    const children = [];
    for (const child of (result == null ? void 0 : result.children) || []) {
      const res = doModify(child, callback, result);
      res && children.push(res);
    }
    return {
      ...result,
      children
    };
  }
  return result;
}
function moveNode(node, {
  destinationId,
  folders
}) {
  return modifyNode(node, (node2, parent) => {
    var _a, _b;
    if (destinationId === node2.id) {
      const parentAncestors = [...((_a = node2.folder) == null ? void 0 : _a.ancestors) || []], ancestors = arrayUnique([...parentAncestors, node2.id]), newChildren = [...node2.children || []], childrenIds = ((_b = node2.children) == null ? void 0 : _b.map((child) => child.id)) || [];
      for (const folder of folders)
        if (!childrenIds.includes(folder)) {
          const item = findNodeById$1(node2, folder);
          item && newChildren.push({
            ...item,
            folder: {
              ...item == null ? void 0 : item.folder,
              ancestors
            }
          });
        }
      return {
        ...node2,
        children: newChildren
      };
    } else
      return folders.includes(node2.id) && destinationId !== (parent == null ? void 0 : parent.id) ? void 0 : node2;
  });
}
const wrapTreeNode = (node, folders, parentId) => modifyNode(node, (node2) => (node2.id === parentId && (node2.children = folders == null ? void 0 : folders.map((e2) => new TreeNodeFolderWrapper(e2))), node2));
function updateNode(node, {
  folderId,
  newFolder
}) {
  return modifyNode(node, (node2) => node2.id === folderId ? new TreeNodeFolderWrapper(newFolder) : node2);
}
function findPathById$1(tree, nodeId) {
  let path = [];
  function traverse(node, currentPath) {
    if (node.id === nodeId)
      return path = currentPath.concat(node.id), !0;
    if (node.children) {
      for (const child of node.children)
        if (traverse(child, currentPath.concat(node.id)))
          return !0;
    }
    return !1;
  }
  function startTraverse(nodes) {
    if (Array.isArray(nodes)) {
      for (const node of nodes)
        if (traverse(node, []))
          break;
    } else
      traverse(nodes, []);
  }
  return startTraverse(tree), path;
}
class TreeNodeFolderWrapper {
  constructor(folder) {
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "childNumber");
    __publicField(this, "section", !1);
    __publicField(this, "children", []);
    this.folder = folder, this.id = folder.id, this.name = folder.name, this.childNumber = folder.childNumber;
  }
}
const MockedDataContext = /* @__PURE__ */ createContext(null);
function MockedDataProvider({
  children,
  mocks
}) {
  const values = useMemo(() => {
    const value = {};
    return typeof mocks.app < "u" && (value.app = mocks.app), Array.isArray(mocks.availableApps) && (value.availableApps = Promise.resolve(mocks.availableApps)), typeof mocks.workflows < "u" && (value.hasWorkflow = async (workflow) => {
      var _a;
      return ((_a = mocks.workflows) == null ? void 0 : _a.findIndex((w) => w === workflow)) !== -1;
    }), mocks.workspaceDocuments && (value.listWorkspaceDocuments = async () => mocks.workspaceDocuments ?? []), mocks.appResources && (value.loadResources = async (filters) => {
      var _a, _b;
      return ((_b = (_a = mocks.appResources) == null ? void 0 : _a[filters.types[0]]) == null ? void 0 : _b.filter(() => (filters && console.log(filters.search || "none"), !0))) || [];
    }), value;
  }, [mocks]);
  return /* @__PURE__ */ jsx(MockedDataContext.Provider, { value: values, children });
}
function useMockedData() {
  return useContext(MockedDataContext);
}
class StringUtils {
  static isLocalURL(str) {
    return str.length > 0 && str.charAt(0) === "/";
  }
  static startWithHttp(str) {
    return /^https?:\/\//gi.test(str);
  }
  static toCounter(counter) {
    return counter > 999 ? `${Number(counter / 1e3).toFixed(1)} k` : "" + counter;
  }
}
function addTimestampToImageUrl(imageUrl) {
  const timestamp = (/* @__PURE__ */ new Date()).getTime(), separator = imageUrl.includes("?") ? "&" : "?";
  return `${imageUrl}${separator}timestamp=${timestamp}`;
}
const getOrGenerateBlobId = (blob, id) => {
  const KEY = "virtualID";
  if (!Object.hasOwnProperty.apply(blob, [KEY])) {
    const value = id ?? `${StringUtils$1.generateVirtualId()}#${blob.size}`;
    Object.defineProperty(blob, KEY, {
      value,
      writable: !1
    });
  }
  return blob[KEY];
}, convertToArray = (rights) => rights instanceof Array ? rights : [rights], checkRightForMultipleResources = async (roles, rights) => Array.isArray(roles) ? await odeServices.rights().sessionHasAtLeastOneResourceRightForEachList(roles, rights) : await odeServices.rights().sessionHasResourceRightForEachList(roles, rights), checkRights = async (roles, rights) => {
  const safeRights = convertToArray(rights);
  return Array.isArray(roles) ? await odeServices.rights().sessionHasAtLeastOneResourceRight(roles, safeRights) : await odeServices.rights().sessionHasResourceRight(roles, safeRights);
}, checkHasRights = async ({
  roles,
  rights
}) => {
  if (roles !== void 0)
    if (Array.isArray(rights))
      if (rights.length > 0) {
        if (typeof rights[0] == "string")
          return await checkRights(roles, rights);
        {
          const rightsArray = rights.map((right) => right.rights);
          return await checkRightForMultipleResources(roles, rightsArray);
        }
      } else
        return !1;
    else {
      if (typeof rights == "string")
        return await checkRights(roles, rights);
      if (rights)
        return await checkRights(roles, rights.rights);
    }
}, checkUserRight = async (rights, additionalRoles) => {
  let roles = ["contrib", "creator", "manager", "read"];
  Array.isArray(additionalRoles) ? roles = [...roles, ...additionalRoles] : additionalRoles && (roles = [...roles, additionalRoles]);
  const userRights = {
    creator: !1,
    contrib: !1,
    manager: !1,
    read: !1
  };
  for (const role of roles) {
    const hasRight2 = await checkHasRights({
      roles: role,
      rights
    });
    userRights[role] = hasRight2;
  }
  return userRights;
};
function findTreeNode(root, predicate) {
  if (predicate(root))
    return root;
  if (Array.isArray(root.children))
    for (const child of root.children) {
      const found = findTreeNode(child, predicate);
      if (found)
        return found;
    }
}
const isActionAvailable = (workflow, actions) => {
  const found = actions == null ? void 0 : actions.filter((action) => action.id === workflow && action.available);
  return found && found.length > 0;
}, libraryMaps = {
  blog: "Blog",
  mindmap: "MindMap",
  scrapbook: "ScrapBook",
  collaborativewall: "CollaborativeWall",
  timelinegenerator: "TimelineGenerator",
  wiki: "Wiki",
  exercizer: "Exercizer"
}, NOOP = () => {
};
function getThumbnail(src, width = 0, height = 0) {
  return !src.includes("data:image") && !src.includes("thumbnail") && (src = src + (src.includes("?") ? "&thumbnail=" : "?thumbnail=") + `${width}x${height}`), src;
}
const convertMsToMS = (milliseconds) => {
  if (milliseconds > 0) {
    let seconds = Math.floor(milliseconds / 1e3), minutes = Math.floor(seconds / 60);
    return seconds = seconds % 60, minutes = minutes % 60, padTo2Digits(minutes) + ":" + padTo2Digits(seconds);
  }
  return "00:00";
}, padTo2Digits = (val) => val.toString().padStart(2, "0"), getBestSupportedMimeType = () => MediaRecorder.isTypeSupported ? ["video/webm;codecs=vp9", 'video/mp4; codecs="avc1.424028, mp4a.40.2"', "video/webm;codecs=vp8,opus", "video/webm"].find((type) => MediaRecorder.isTypeSupported(type) ? !0 : (console.error(`${type} is not Supported`), !1)) || "video/ogg" : "video/webm;codecs=vp8,opus", ViewsCounter = ({
  viewsCounter,
  onClick,
  className
}) => {
  const handleButtonClick = (event) => {
    event.preventDefault(), event.stopPropagation(), onClick == null || onClick();
  };
  return className = clsx("text-gray-700 fw-normal py-4 px-8 btn-icon", className), /* @__PURE__ */ jsx(Button, { rightIcon: /* @__PURE__ */ jsx(See, {}), variant: "ghost", type: "button", className, onClick: handleButtonClick, disabled: !viewsCounter, children: StringUtils.toCounter(viewsCounter) });
}, ViewsCounter$1 = ViewsCounter, ModalContext = /* @__PURE__ */ createContext({
  ariaLabelId: "",
  ariaDescriptionId: "",
  focusId: ""
}), useModalContext = () => {
  const context = useContext(ModalContext);
  if (!context)
    throw new Error("Cannot be rendered outside the Modal component");
  return context;
}, ModalBody = (props) => {
  const {
    ariaDescriptionId
  } = useModalContext(), {
    children,
    className
  } = props, classes = clsx("modal-body", className);
  return /* @__PURE__ */ jsx("div", { id: ariaDescriptionId, className: classes, children });
}, ModalBody$1 = ModalBody, ModalFooter = (props) => /* @__PURE__ */ jsx("div", { className: "modal-footer", children: props.children }), ModalFooter$1 = ModalFooter, ModalHeader = (props) => {
  const {
    onModalClose,
    children
  } = props, {
    ariaLabelId,
    focusId
  } = useModalContext(), closeButtonRef = useRef(null), {
    t
  } = useTranslation();
  return useEffect(() => {
    var _a;
    focusId || (_a = closeButtonRef.current) == null || _a.focus();
  }, [focusId]), /* @__PURE__ */ jsxs("div", { className: "modal-header", children: [
    /* @__PURE__ */ jsx("h2", { id: ariaLabelId, className: "modal-title", tabIndex: -1, children }),
    /* @__PURE__ */ jsx(IconButton$1, { ref: closeButtonRef, "aria-label": t("close"), color: "tertiary", icon: /* @__PURE__ */ jsx(Close, {}), type: "button", variant: "ghost", title: t("close"), onClick: onModalClose, className: "btn-close" })
  ] });
}, ModalHeader$1 = ModalHeader, ModalSubtitle = (props) => /* @__PURE__ */ jsx("p", { className: "modal-subtitle", children: props.children }), ModalSubtitle$1 = ModalSubtitle, Root$2 = /* @__PURE__ */ forwardRef((props, ref) => {
  const {
    id,
    isOpen,
    onModalClose,
    size: size2 = "md",
    viewport = !1,
    scrollable = !1,
    focusId,
    children
  } = props, ariaLabelId = `aria_label_${id}`, ariaDescriptionId = `aria_desc_${id}`, modalRef = useClickOutside(onModalClose), trapRef = useTrapFocus();
  useKeyPress(onModalClose, ["Escape"]), useEffect(() => {
    if (isOpen && (document.body.style.overflow = "hidden", focusId)) {
      const elem = document.getElementById(focusId);
      elem == null || elem.focus();
    }
    return () => {
      document.body.style.overflow = "";
    };
  }, [focusId, isOpen]);
  const modalClasses = clsx("modal fade", {
    "show d-block": isOpen,
    "modal-scrollable": scrollable,
    viewport,
    [`modal-${size2}`]: size2
  }), dialogClasses = clsx("modal-dialog"), modalContextValue = {
    ariaLabelId,
    ariaDescriptionId,
    focusId
  }, transition = useTransition(isOpen, {
    from: {
      x: -50,
      opacity: 0
    },
    enter: {
      x: 0,
      opacity: 1
    },
    leave: {
      x: 50,
      opacity: 0
    }
  });
  return /* @__PURE__ */ jsx(ModalContext.Provider, { value: modalContextValue, children: transition((style, isOpen2) => /* @__PURE__ */ jsxs(Fragment, { children: [
    isOpen2 && /* @__PURE__ */ jsx(animated.div, { id, ref, role: "dialog", "aria-modal": "true", "aria-labelledby": ariaLabelId, "aria-describedby": ariaDescriptionId, className: modalClasses, style, tabIndex: -1, children: /* @__PURE__ */ jsx("div", { id: `${id}_ref`, ref: (node) => {
      modalRef.current = node, isOpen2 && (trapRef.current = node);
    }, className: dialogClasses, children: /* @__PURE__ */ jsx("div", { className: "modal-content", children }) }) }),
    isOpen2 && /* @__PURE__ */ jsx(animated.div, { className: "modal-backdrop fade show", style: {
      opacity: 0.65
    } })
  ] })) });
}), Modal = /* @__PURE__ */ Object.assign(Root$2, {
  Header: ModalHeader$1,
  Subtitle: ModalSubtitle$1,
  Body: ModalBody$1,
  Footer: ModalFooter$1
}), Modal$1 = Modal, ViewsByProfileCard = ({
  viewsByProfile
}) => {
  const {
    t
  } = useTranslation(), profile = viewsByProfile.profile.toLowerCase(), classNameIcon = `views-detail-icon rounded p-8 views-detail-icon-${profile}`;
  function getIcon(profile2) {
    switch (profile2) {
      case "student":
        return /* @__PURE__ */ jsx(Student, {});
      case "relative":
        return /* @__PURE__ */ jsx(Parent, {});
      case "teacher":
        return /* @__PURE__ */ jsx(Teacher, {});
      case "personnel":
        return /* @__PURE__ */ jsx(Personnel, {});
      case "guest":
        return /* @__PURE__ */ jsx(Guest, {});
      default:
        return /* @__PURE__ */ jsx(Users, {});
    }
  }
  return /* @__PURE__ */ jsxs("div", { className: "views-detail-line p-8 ms-32 mb-12", children: [
    /* @__PURE__ */ jsx("div", { className: classNameIcon, children: getIcon(profile) }),
    /* @__PURE__ */ jsx("div", { className: "h3", children: StringUtils.toCounter(viewsByProfile.counter) }),
    /* @__PURE__ */ jsx("div", { children: t(`audience.views.uniqueViewsPerProfile.${profile}`) })
  ] }, profile);
}, ViewsByProfileCard$1 = ViewsByProfileCard, ViewsModal = ({
  viewsDetails,
  isOpen,
  onModalClose
}) => {
  var _a;
  const {
    t
  } = useTranslation(), hasUniqueViews = viewsDetails.uniqueViewsCounter !== void 0;
  return /* @__PURE__ */ createPortal(/* @__PURE__ */ jsxs(Modal$1, { id: "ViewsModal", isOpen, onModalClose, children: [
    /* @__PURE__ */ jsx(Modal$1.Header, { onModalClose, children: t("audience.views.title") }),
    /* @__PURE__ */ jsxs(Modal$1.Body, { children: [
      /* @__PURE__ */ jsxs("div", { className: "views-detail-line p-8 mb-12", children: [
        /* @__PURE__ */ jsx("div", { className: "views-detail-icon rounded p-8", children: /* @__PURE__ */ jsx(See, {}) }),
        /* @__PURE__ */ jsx("div", { className: "h3", children: StringUtils.toCounter(viewsDetails.viewsCounter) }),
        /* @__PURE__ */ jsx("div", { children: t("audience.views.detail.viewsCounter") })
      ] }),
      /* @__PURE__ */ jsxs("div", { className: "views-detail-line p-8 mb-12", children: [
        /* @__PURE__ */ jsx("div", { className: "views-detail-icon rounded p-8", children: /* @__PURE__ */ jsx(Users, {}) }),
        hasUniqueViews ? /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx("div", { className: "h3", children: StringUtils.toCounter(viewsDetails.uniqueViewsCounter) }),
          /* @__PURE__ */ jsx("div", { children: t("audience.views.detail.uniqueViewsCounter") })
        ] }) : /* @__PURE__ */ jsx("div", { children: t("audience.views.detail.noUniqueViews") })
      ] }),
      hasUniqueViews ? (_a = viewsDetails.uniqueViewsPerProfile) == null ? void 0 : _a.map((viewsByProfile) => /* @__PURE__ */ jsx(ViewsByProfileCard$1, { viewsByProfile }, viewsByProfile.profile)) : null
    ] }),
    /* @__PURE__ */ jsx(Modal$1.Footer, { children: /* @__PURE__ */ jsx(Button, { color: "primary", onClick: onModalClose, type: "button", variant: "filled", children: t("audience.views.cancel") }) })
  ] }), document.getElementById("portal"));
}, ViewsModal$1 = ViewsModal;
function useReactionIcons() {
  return {
    getReactionIcon: (reactionType, asCounter) => {
      switch (reactionType) {
        case "REACTION_1":
          return asCounter ? /* @__PURE__ */ jsx(ThanksCounter, {}) : /* @__PURE__ */ jsx(Thanks, {});
        case "REACTION_2":
          return asCounter ? /* @__PURE__ */ jsx(GreatCounter, {}) : /* @__PURE__ */ jsx(Great, {});
        case "REACTION_3":
          return asCounter ? /* @__PURE__ */ jsx(CongratsCounter, {}) : /* @__PURE__ */ jsx(Congrats, {});
        case "REACTION_4":
          return asCounter ? /* @__PURE__ */ jsx(InterestingCounter, {}) : /* @__PURE__ */ jsx(Interesting, {});
        default:
          return /* @__PURE__ */ jsx(Reaction, {});
      }
    },
    getReactionLabel: (reactionType) => {
      switch (reactionType) {
        case "REACTION_1":
          return "audience.reaction.thanks";
        case "REACTION_2":
          return "audience.reaction.great";
        case "REACTION_3":
          return "audience.reaction.congrats";
        case "REACTION_4":
          return "audience.reaction.interesting";
        default:
          return "audience.reaction.default";
      }
    }
  };
}
const ReactionSummary = ({
  summary = {
    userReaction: null,
    totalReactionsCounter: 0
  },
  onClick
}) => {
  const {
    getReactionIcon
  } = useReactionIcons(), {
    totalReactionsCounter,
    reactionTypes
  } = summary, hasNoReactions = totalReactionsCounter === 0;
  return /* @__PURE__ */ jsx(Button, { variant: "ghost", className: "py-4 px-8 btn-icon", disabled: hasNoReactions, onClick: (event) => {
    event.preventDefault(), event.stopPropagation(), onClick == null || onClick();
  }, children: /* @__PURE__ */ jsxs("div", { className: "d-flex align-items-center", children: [
    /* @__PURE__ */ jsx("div", { className: "text-gray-700 fw-normal me-8", children: StringUtils.toCounter(totalReactionsCounter) }),
    hasNoReactions ? /* @__PURE__ */ jsx("div", { className: "reaction-overlap", children: getReactionIcon("REACTION_1", !0) }) : reactionTypes == null ? void 0 : reactionTypes.map((reactionType) => /* @__PURE__ */ jsx("div", { className: "reaction-overlap", children: getReactionIcon(reactionType, !0) }, reactionType))
  ] }) });
}, ReactionSummary$1 = ReactionSummary, Tooltip = ({
  children,
  message,
  icon = null,
  placement = "auto",
  ...restProps
}) => {
  const [referenceElement, setReferenceElement] = useState(null), [popperElement, setPopperElement] = useState(null), [arrowElement, setArrowElement] = useState(null), {
    styles,
    attributes
  } = usePopper(referenceElement, popperElement, {
    placement,
    modifiers: [{
      name: "arrow",
      options: {
        element: arrowElement
      }
    }]
  }), [visible, setVisible] = useState(!1);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("div", { className: "d-inline-block position-relative z-2", ref: setReferenceElement, onMouseEnter: () => {
      setVisible(!0);
    }, onMouseLeave: () => {
      setVisible(!1);
    }, ...restProps, children }),
    visible && message && /* @__PURE__ */ jsxs("div", { className: clsx("tooltip d-block show mb-12", "bs-tooltip-auto"), ref: setPopperElement, style: styles.popper, ...attributes.popper, children: [
      /* @__PURE__ */ jsxs("div", { className: "tooltip-inner shadow-hover d-flex gap-8 align-items-center", children: [
        icon && icon,
        /* @__PURE__ */ jsx("div", { children: message })
      ] }),
      /* @__PURE__ */ jsx("div", { className: "tooltip-arrow", ref: setArrowElement, style: styles.arrow })
    ] })
  ] });
}, Tooltip$1 = Tooltip, ReactionChoice = ({
  availableReactions,
  summary = {
    totalReactionsCounter: 0,
    userReaction: null
  },
  onChange
}) => {
  const {
    t
  } = useTranslation(), {
    getReactionIcon,
    getReactionLabel
  } = useReactionIcons(), {
    userReaction
  } = summary, classes = clsx({
    "fw-bold": !!userReaction
  });
  return /* @__PURE__ */ jsx("div", { className: "reaction-choice", children: /* @__PURE__ */ jsxs(Dropdown$1, { placement: "top-start", children: [
    /* @__PURE__ */ jsx(Dropdown$1.Trigger, { className: classes, color: "tertiary", variant: "ghost", size: "sm", icon: getReactionIcon(userReaction), hideCarret: !0, label: t(getReactionLabel(userReaction)) }),
    /* @__PURE__ */ jsx(Dropdown$1.Menu, { unstyled: !0, className: "bg-white shadow rounded-8 overflow-visible", children: /* @__PURE__ */ jsx("div", { className: "d-flex align-items-center justify-content-between", children: availableReactions == null ? void 0 : availableReactions.map((reactionType) => /* @__PURE__ */ jsx(Dropdown$1.Item, { className: "p-0", children: /* @__PURE__ */ jsx(Tooltip$1, { message: t(getReactionLabel(reactionType)), placement: "top", children: /* @__PURE__ */ jsx(IconButton$1, { className: "reaction-available m-4", variant: "ghost", size: "sm", icon: getReactionIcon(reactionType), onClick: () => onChange == null ? void 0 : onChange(reactionType) }) }) }, reactionType)) }) })
  ] }) });
}, ReactionChoice$1 = ReactionChoice, TabsContext = /* @__PURE__ */ createContext(null);
function useTabsContext() {
  const context = useContext(TabsContext);
  if (!context)
    throw new Error("Tabs compound components cannot be rendered outside the Tabs component");
  return context;
}
const useTabs = ({
  defaultId,
  items,
  onChange
}) => {
  const [activeTab, setActiveTab] = useState(defaultId || ""), [tabUnderlineWidth, setTabUnderlineWidth] = useState(0), [tabUnderlineLeft, setTabUnderlineLeft] = useState(0), tabsRef = useRef([]), setSelectedTab = useCallback((id) => {
    setActiveTab(id);
  }, []);
  useEffect(() => {
    const currentItem = items.find((item) => item.id === activeTab);
    currentItem && (onChange == null || onChange(currentItem));
  }, [activeTab]), useEffect(() => {
    function setTabPosition() {
      var _a;
      if (((_a = document == null ? void 0 : document.activeElement) == null ? void 0 : _a.tagName) !== "INPUT") {
        const currentTabIndex = items.findIndex((item) => item.id === activeTab);
        currentTabIndex === -1 && defaultId && setActiveTab(defaultId);
        const currentTabRef = tabsRef.current[currentTabIndex];
        currentTabRef && (currentTabRef.focus(), setTabUnderlineLeft((currentTabRef == null ? void 0 : currentTabRef.offsetLeft) ?? 0), setTabUnderlineWidth((currentTabRef == null ? void 0 : currentTabRef.clientWidth) ?? 0));
      }
    }
    return setTabPosition(), window.addEventListener("resize", setTabPosition), () => window.removeEventListener("resize", setTabPosition);
  }, [activeTab, items, defaultId]);
  const moveFocusToPreviousTab = useCallback((activeTab2) => {
    var _a, _b, _c;
    const index = items.findIndex((item) => item.id === activeTab2);
    activeTab2 === ((_a = items[0]) == null ? void 0 : _a.id) ? setActiveTab((_b = items[items.length - 1]) == null ? void 0 : _b.id) : setActiveTab((_c = items[index - 1]) == null ? void 0 : _c.id);
  }, [items]), moveFocusToNextTab = useCallback((activeTab2) => {
    var _a, _b, _c;
    const index = items.findIndex((item) => item.id === activeTab2);
    activeTab2 === ((_a = items[items.length - 1]) == null ? void 0 : _a.id) ? setActiveTab((_b = items[0]) == null ? void 0 : _b.id) : setActiveTab((_c = items[index + 1]) == null ? void 0 : _c.id);
  }, [items]), onKeyDown = useCallback((event) => {
    var _a, _b;
    switch (event.code) {
      case "ArrowLeft":
        moveFocusToPreviousTab(activeTab);
        break;
      case "ArrowRight":
        moveFocusToNextTab(activeTab);
        break;
      case "Home":
        setActiveTab((_a = items[0]) == null ? void 0 : _a.id);
        break;
      case "End":
        setActiveTab((_b = items[items.length - 1]) == null ? void 0 : _b.id);
        break;
    }
  }, [activeTab, items, moveFocusToNextTab, moveFocusToPreviousTab]);
  return {
    activeTab,
    setSelectedTab,
    tabsRef,
    tabUnderlineLeft,
    tabUnderlineWidth,
    onKeyDown
  };
}, TabsItem = ({
  icon,
  label,
  id,
  order
}) => {
  const {
    activeTab,
    setSelectedTab,
    onKeyDown,
    tabsRef
  } = useTabsContext(), {
    t
  } = useTranslation(), classes = clsx("nav-link d-inline-flex gap-8 border-0", activeTab === id ? "selected" : "");
  return /* @__PURE__ */ jsx("li", { className: "nav-item flex-shrink-0", role: "presentation", children: /* @__PURE__ */ jsxs("button", { ref: (el) => tabsRef.current[order] = el, type: "button", id: `tab-${id}`, className: classes, onClick: () => setSelectedTab(id), onKeyDown: (event) => onKeyDown(event), role: "tab", "aria-controls": `tabpanel-${id}`, "aria-selected": activeTab === id, tabIndex: activeTab === id ? 0 : -1, children: [
    icon,
    /* @__PURE__ */ jsx("small", { children: t(label) })
  ] }) });
}, TabsItem$1 = TabsItem, TabsList = (props) => {
  const {
    items,
    tabUnderlineLeft,
    tabUnderlineWidth
  } = useTabsContext(), {
    className,
    ...restProps
  } = props, tabslist = clsx("position-relative flex-shrink-0 overflow-x-auto", className);
  return /* @__PURE__ */ jsxs("div", { className: tabslist, ...restProps, children: [
    /* @__PURE__ */ jsx("ul", { className: "nav nav-tabs flex-nowrap", role: "tablist", children: items.map((item, order) => /* @__PURE__ */ jsx(Tabs.Item, { order, ...item }, item.id)) }),
    /* @__PURE__ */ jsx("span", { className: "nav-slide", style: {
      left: tabUnderlineLeft,
      width: tabUnderlineWidth
    } })
  ] });
}, TabsList$1 = TabsList, TabsPanel = ({
  children,
  currentItem
}) => {
  const {
    activeTab
  } = useTabsContext();
  return /* @__PURE__ */ jsx("div", { className: "tab-content d-flex flex-fill w-100", children: /* @__PURE__ */ jsx("div", { className: `tab-pane flex-fill w-100 fade ${activeTab === (currentItem == null ? void 0 : currentItem.id) ? "show active" : ""}`, id: `tabpanel-${currentItem == null ? void 0 : currentItem.id}`, role: "tabpanel", "aria-labelledby": `tab-${currentItem == null ? void 0 : currentItem.id}`, tabIndex: 0, children }) });
}, TabsPanel$1 = TabsPanel, Tabs = ({
  defaultId,
  items,
  onChange,
  children
}) => {
  const {
    activeTab,
    setSelectedTab,
    tabsRef,
    tabUnderlineLeft,
    tabUnderlineWidth,
    onKeyDown
  } = useTabs({
    defaultId,
    items,
    onChange
  }), value = useMemo(() => ({
    activeTab,
    items,
    setSelectedTab,
    tabsRef,
    tabUnderlineLeft,
    tabUnderlineWidth,
    onKeyDown
  }), [activeTab, items, onKeyDown, setSelectedTab, tabUnderlineLeft, tabUnderlineWidth, tabsRef]), currentItem = items.find((item) => item.id === activeTab);
  return /* @__PURE__ */ jsx(TabsContext.Provider, { value, children: typeof children == "function" ? children(currentItem) : /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Tabs.List, {}),
    /* @__PURE__ */ jsx(Tabs.Panel, { currentItem, children: currentItem == null ? void 0 : currentItem.content })
  ] }) });
};
Tabs.Item = TabsItem$1;
Tabs.Panel = TabsPanel$1;
Tabs.List = TabsList$1;
function ReactionModalCard({
  reaction
}) {
  const {
    t
  } = useTranslation(), {
    avatarURL
  } = useAvatar(reaction.userId, reaction.profile), {
    getReactionIcon,
    getReactionLabel
  } = useReactionIcons();
  return /* @__PURE__ */ jsxs("div", { className: "reaction-modal-card w-100 d-flex gap-8", children: [
    /* @__PURE__ */ jsxs("div", { className: "position-relative p-8", children: [
      /* @__PURE__ */ jsx(Avatar, { variant: "circle", size: "md", src: avatarURL, alt: reaction.displayName }),
      /* @__PURE__ */ jsx("div", { className: "position-absolute end-0 bottom-0", children: getReactionIcon(reaction.reactionType, !0) })
    ] }),
    /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column w-100 pt-8", children: [
      /* @__PURE__ */ jsxs("div", { className: "d-flex align-items-baseline", children: [
        /* @__PURE__ */ jsx("div", { className: "d-flex overflow-hidden", children: /* @__PURE__ */ jsx("div", { className: "text-reset flex-shrink-0", children: reaction.displayName }) }),
        /* @__PURE__ */ jsx("strong", { className: "ms-12 caption text-gray-700", children: t(reaction.profile) })
      ] }),
      /* @__PURE__ */ jsx("p", { className: "caption text-gray-700", children: t(getReactionLabel(reaction.reactionType)) })
    ] })
  ] });
}
const ALL_TAB_ID = "all", ReactionModal = ({
  resourceId,
  pageSize = 30,
  reactionDetailsLoader: loadReactionDetails,
  onModalClose,
  ...restProps
}) => {
  const [counters, setCounters] = useState({
    countByType: {},
    allReactionsCounter: 0
  }), [reactions, setReactions] = useState([]), [currentTabId, setCurrentTabId] = useState(ALL_TAB_ID), id = useId(), {
    t
  } = useTranslation(), {
    getReactionIcon
  } = useReactionIcons(), [latestPage, setLatestPage] = useState(0), loadNextPage = useCallback(async () => {
    const nextPage = latestPage + 1;
    setLatestPage(nextPage);
    const data = await loadReactionDetails(resourceId, nextPage, pageSize);
    if (data) {
      const {
        reactionCounters,
        userReactions
      } = data;
      nextPage === 1 && setCounters(reactionCounters), setReactions((old) => [...old, ...userReactions.filter((reaction) => !old.some((oldReaction) => oldReaction.userId === reaction.userId))]);
    }
  }, [latestPage, loadReactionDetails, pageSize, resourceId]), panel = useMemo(() => /* @__PURE__ */ jsx("div", { className: "d-flex flex-column w-100 gap-8 mt-32", children: reactions.filter((reaction) => currentTabId === ALL_TAB_ID || reaction.reactionType === currentTabId).map((reaction) => /* @__PURE__ */ jsx(ReactionModal.Card, { reaction }, reaction.userId)) }), [currentTabId, reactions]), tabs = useMemo(() => {
    const items = ReactionTypes.filter((type) => {
      var _a;
      return typeof ((_a = counters.countByType) == null ? void 0 : _a[type]) == "number";
    }).map((type) => ({
      id: type,
      icon: getReactionIcon(type),
      label: StringUtils.toCounter(counters.countByType[type]),
      content: panel
    }));
    return [{
      id: ALL_TAB_ID,
      icon: null,
      label: t("audience.reaction.tab.all"),
      content: panel
    }, ...items];
  }, [counters.countByType, panel]);
  useEffect(() => {
    loadNextPage();
  }, []);
  const handleTabChange = (tab) => {
    setCurrentTabId(tab.id);
  }, hasMore = reactions.length < counters.allReactionsCounter;
  return /* @__PURE__ */ createPortal(/* @__PURE__ */ jsxs(Modal$1, { id, ...restProps, onModalClose, size: "md", scrollable: !0, children: [
    /* @__PURE__ */ jsx(Modal$1.Header, { onModalClose, children: t("audience.reaction.modal.header") }),
    /* @__PURE__ */ jsx(Modal$1.Body, { children: /* @__PURE__ */ jsx(Tabs, { items: tabs, defaultId: ALL_TAB_ID, onChange: handleTabChange }) }),
    /* @__PURE__ */ jsxs(Modal$1.Footer, { children: [
      hasMore && /* @__PURE__ */ jsx(Button, { color: "tertiary", onClick: loadNextPage, children: t("audience.reaction.modal.more") }),
      /* @__PURE__ */ jsx(Button, { color: "primary", onClick: onModalClose, type: "button", variant: "filled", children: t("close") })
    ] })
  ] }), document.getElementById("portal"));
};
ReactionModal.Card = ReactionModalCard;
const ReactionModal$1 = ReactionModal;
function useReactions(module, resourceType) {
  const {
    reactions
  } = useRef(odeServices.audience(module, resourceType)).current, [availableReactions, setAvailableReactions] = useState([]);
  async function loadAvailableReactions() {
    const results = await reactions.loadAvailableReactions();
    results && setAvailableReactions(results);
  }
  async function loadReactionSummaries(resourceIds) {
    return await reactions.loadReactionSummaries(resourceIds);
  }
  const loadReactionDetails = async (resourceId, page, size2 = 30) => await reactions.loadReactionDetails(resourceId, page, size2), applyReaction = useCallback(
    async (resourceId, newReaction, oldReaction) => {
      if (newReaction !== oldReaction && availableReactions.indexOf(newReaction) < 0)
        return Promise.reject(ERROR_CODE.MALFORMED_DATA);
      let result = "+";
      return oldReaction ? newReaction === oldReaction ? (await reactions.deleteReaction(resourceId), result = "-") : (await reactions.updateReaction(resourceId, newReaction), result = "=") : await reactions.createReaction(resourceId, newReaction), odeServices.http().isResponseError() ? Promise.reject(ERROR_CODE.UNKNOWN) : result;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [availableReactions]
  );
  return useEffect(() => {
    loadAvailableReactions();
  }, []), {
    availableReactions,
    loadReactionDetails,
    loadReactionSummaries,
    applyReaction
  };
}
const BreadcrumbItem = /* @__PURE__ */ forwardRef(({
  children,
  className,
  ...restProps
}, forwardRef2) => {
  const classes = clsx("breadcrumb-item", className);
  return /* @__PURE__ */ jsx("li", { ref: forwardRef2, className: classes, ...restProps, children });
}), BreadcrumbItem$1 = BreadcrumbItem, BreadcrumbList = /* @__PURE__ */ forwardRef(({
  children,
  className
}, ref) => {
  const classes = clsx("breadcrumb d-flex flex-nowrap align-items-center mb-0", className);
  return /* @__PURE__ */ jsx("ol", { ref, className: classes, children });
}), BreadcrumbList$1 = BreadcrumbList;
function useOdeIcons() {
  const iconOfWidget = {
    "last-infos-widget": "ic-widget-actualites",
    birthday: "ic-star",
    "calendar-widget": "ic-widget-calendar",
    "carnet-de-bord": "ic-widget-carnet-de-bord",
    "record-me": "ic-widget-microphone",
    mood: "ic-star",
    "my-apps": "ic-widget-apps",
    notes: "ic-widget-notes",
    "rss-widget": "ic-widget-rss",
    "bookmark-widget": "ic-widget-signets",
    qwant: "ic-widget-qwant",
    "qwant-junior": "ic-widget-qwant",
    "agenda-widget": "ic-widget-agenda",
    "cursus-widget": "ic-widget-aide-devoirs",
    "maxicours-widget": "ic-widget-maxicours",
    "school-widget": "ic-widget-schoolbook",
    "universalis-widget": "ic-widget-universalis",
    "briefme-widget": "ic-widget-briefme"
  };
  function getIconCode(app) {
    let appCode = "";
    switch (typeof app == "string" ? appCode = app : appCode = (app == null ? void 0 : app.icon) !== void 0 ? app == null ? void 0 : app.icon.trim().toLowerCase() : "placeholder", appCode && appCode.length > 0 ? appCode.endsWith("-large") && (appCode = appCode.replace("-large", "")) : typeof app == "object" && (appCode = (app == null ? void 0 : app.displayName) !== void 0 ? app == null ? void 0 : app.displayName.trim().toLowerCase() : ""), appCode) {
      case "admin.title":
        appCode = "admin";
        break;
      case "banques des savoirs":
        appCode = "banquesavoir";
        break;
      case "collaborativewall":
        appCode = "collaborative-wall";
        break;
      case "communautés":
        appCode = "community";
        break;
      case "directory.user":
        appCode = "userbook";
        break;
      case "emploi du temps":
        appCode = "edt";
        break;
      case "formulaire":
        appCode = "forms";
        break;
      case "messagerie":
        appCode = "conversation";
        break;
      case "news":
        appCode = "actualites";
        break;
      case "homeworks":
      case "cahier de texte":
        appCode = "cahier-de-texte";
        break;
      case "diary":
      case "cahier de texte 2d":
        appCode = "cahier-textes";
        break;
    }
    return appCode;
  }
  function isIconUrl(icon) {
    return icon && (icon.startsWith("/") || icon.startsWith("http://") || icon.startsWith("https://"));
  }
  function getIconClass(app) {
    const appCode = getIconCode(app);
    return appCode ? `color-app-${appCode}` : "color-app-placeholder";
  }
  function getBackgroundIconClass(app) {
    const appCode = getIconCode(app);
    return appCode ? `bg-app-${appCode}` : "bg-app-placeholder";
  }
  function getBackgroundLightIconClass(app) {
    const appCode = getIconCode(app);
    return appCode ? `bg-light-${appCode}` : "bg-light-placeholder";
  }
  function getWidgetIconClass(widget) {
    return iconOfWidget[widget.platformConf.name];
  }
  return {
    getIconClass,
    getBackgroundIconClass,
    getBackgroundLightIconClass,
    getIconCode,
    getWidgetIconClass,
    isIconUrl
  };
}
const BreadcrumbNav = /* @__PURE__ */ forwardRef(({
  children,
  app,
  className
}, ref) => {
  const {
    t
  } = useTranslation(), {
    getIconClass
  } = useOdeIcons(), classes = clsx("d-flex align-items-center mb-0", getIconClass(app), className), style = {
    "--edifice-breadcrumb-divider": "-"
  };
  return /* @__PURE__ */ jsx("nav", { ref, className: classes, "aria-label": t("breadcrumb"), style, children });
}), BreadcrumbNav$1 = BreadcrumbNav, Breadcrumb = /* @__PURE__ */ forwardRef(({
  app,
  name
}, ref) => {
  const {
    t
  } = useTranslation();
  return /* @__PURE__ */ jsx(BreadcrumbNav$1, { app, ref, className: "mw-100", children: /* @__PURE__ */ jsx(BreadcrumbList$1, { className: "gap-12 mw-100", children: name ? /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(BreadcrumbItem$1, { children: /* @__PURE__ */ jsx("a", { href: app == null ? void 0 : app.address, className: "d-flex", "aria-label": t(app == null ? void 0 : app.displayName), children: /* @__PURE__ */ jsx(AppIcon$1, { app, size: "40" }) }) }),
    /* @__PURE__ */ jsx(BreadcrumbItem$1, { children: /* @__PURE__ */ jsx(RafterRight, { color: "var(--edifice-gray-600)", width: 20, height: 20 }) }),
    /* @__PURE__ */ jsx(BreadcrumbItem$1, { className: "text-truncate", children: /* @__PURE__ */ jsx(Heading, { level: "h1", headingStyle: "h3", className: "text-truncate", children: name }) })
  ] }) : /* @__PURE__ */ jsxs(BreadcrumbItem$1, { className: "gap-12 d-flex align-items-center", children: [
    /* @__PURE__ */ jsx("a", { href: app == null ? void 0 : app.address, className: "d-flex", "aria-label": t(app == null ? void 0 : app.displayName), children: /* @__PURE__ */ jsx(AppIcon$1, { app, size: "40" }) }),
    /* @__PURE__ */ jsx(Heading, { level: "h1", headingStyle: "h3", className: "d-none d-md-flex", children: t(app == null ? void 0 : app.displayName) })
  ] }) }) });
}), Breadcrumb$1 = Breadcrumb, DefaultPalette = {
  className: "fw-bold",
  label: "defaultPalette",
  colors: [
    /* Paint It Black */
    [{
      value: "#4A4A4A",
      description: "color.gray.darkest"
    }, {
      value: "#909090",
      description: "color.gray.dark"
    }, {
      value: "#C7C7C7",
      description: "color.gray.medium"
    }, {
      value: "#F2F2F2",
      description: "color.gray.light",
      hue: "light"
    }, {
      value: "#FFFFFF",
      description: "color.white",
      hue: "light"
    }],
    /* Blue Sunday */
    [{
      value: "#005A8A",
      description: "color.blue.darkest"
    }, {
      value: "#2F7EA7",
      description: "color.blue.dark"
    }, {
      value: "#46AFE6",
      description: "color.blue.medium"
    }, {
      value: "#B9E3F8",
      description: "color.blue.light",
      hue: "light"
    }, {
      value: "#E5F5FF",
      description: "color.blue.lightest",
      hue: "light"
    }],
    /* Purple haze */
    [{
      value: "#550070",
      description: "color.purple.darkest"
    }, {
      value: "#7C2C96",
      description: "color.purple.dark"
    }, {
      value: "#A348C0",
      description: "color.purple.medium"
    }, {
      value: "#D7B5E2",
      description: "color.purple.light",
      hue: "light"
    }, {
      value: "#F6ECF9",
      description: "color.purple.lightest",
      hue: "light"
    }],
    /* Red House */
    [{
      value: "#9E0016",
      description: "color.red.darkest"
    }, {
      value: "#C6253B",
      description: "color.red.dark"
    }, {
      value: "#FF3A55",
      description: "color.red.medium"
    }, {
      value: "#FFB6C0",
      description: "color.red.light",
      hue: "light"
    }, {
      value: "#FFECEE",
      description: "color.red.lightest",
      hue: "light"
    }],
    /* The Brown Album */
    [{
      value: "#9E4800",
      description: "color.brown.darkest"
    }, {
      value: "#DA6A0B",
      description: "color.brown.dark"
    }, {
      value: "#FF8D2E",
      description: "color.brown.medium"
    }, {
      value: "#FFCBA0",
      description: "color.brown.light",
      hue: "light"
    }, {
      value: "#FFEFE3",
      description: "color.brown.lightest",
      hue: "light"
    }],
    /* Yellow Submarine */
    [{
      value: "#A89400",
      description: "color.yellow.darkest"
    }, {
      value: "#D1AF00",
      description: "color.yellow.dark"
    }, {
      value: "#F1CA00",
      description: "color.yellow.medium"
    }, {
      value: "#FAEA9C",
      description: "color.yellow.light",
      hue: "light"
    }, {
      value: "#FBF4D5",
      description: "color.yellow.lightest",
      hue: "light"
    }],
    /* Green Naugahyde */
    [{
      value: "#2E6105",
      description: "color.green.darkest"
    }, {
      value: "#4E9019",
      description: "color.green.dark"
    }, {
      value: "#5AC235",
      description: "color.green.medium"
    }, {
      value: "#C8E4AF",
      description: "color.green.light",
      hue: "light"
    }, {
      value: "#EAF7E4",
      description: "color.green.lightest",
      hue: "light"
    }]
  ]
}, AccessiblePalette = {
  label: "accessiblePalette",
  tooltip: {
    message: "Veni, vidi, vici"
  },
  colors: [[{
    value: "#4A4A4A",
    description: "color.gray"
  }], [{
    value: "#648FFF",
    description: "color.blue"
  }], [{
    value: "#785EF0",
    description: "color.purple"
  }], [{
    value: "#DC267F",
    description: "color.red"
  }], [{
    value: "#FE6100",
    description: "color.brown"
  }], [{
    value: "#FFB000",
    description: "color.orange"
  }], [{
    value: "#F3EA14",
    description: "color.yellow"
  }]],
  className: "mt-16"
}, ColorPickerItem = ({
  model,
  selected,
  className
}) => model.isReset ? /* @__PURE__ */ jsx(DeleteColor, {}) : /* @__PURE__ */ jsx("div", { "aria-label": model.description, className: clsx("color-picker-hue-color-item rounded-1", className, model.hue === "light" ? "light" : "dark", selected && "selected"), style: {
  backgroundColor: model.value
} }), ColorPickerItem$1 = ColorPickerItem, ColorPicker = /* @__PURE__ */ forwardRef(({
  palettes = [DefaultPalette, AccessiblePalette],
  model = "#4A4A4A",
  onSuccess,
  ...restProps
}, ref) => {
  const {
    t
  } = useTranslation(), handleClick = (item) => {
    item && (onSuccess == null || onSuccess(item));
  };
  return /* @__PURE__ */ jsx("div", { ref, ...restProps, children: palettes.map((palette, paletteIdx) => /* @__PURE__ */ jsxs("div", { className: clsx("color-picker mx-8", palette.className), children: [
    /* @__PURE__ */ jsxs("div", { className: "color-picker-label small mt-4 mb-8", children: [
      t(palette.label),
      palette.tooltip && /* @__PURE__ */ jsx(Tooltip$1, { message: "", placement: "auto", ...palette.tooltip, children: /* @__PURE__ */ jsx(InfoCircle, { width: 18, height: 18, className: "mx-4 position-relative", style: {
        top: "4px"
      } }) })
    ] }),
    // Show/hide the reset option
    palette.reset && /* @__PURE__ */ jsxs("button", { type: "button", className: "color-picker-reset small my-8 gap-4", onClick: () => handleClick(palette.reset), children: [
      /* @__PURE__ */ jsx(DeleteColor, { width: 20, height: 20 }),
      palette.reset.description
    ] }),
    /* @__PURE__ */ jsx("div", { className: "color-picker-palette d-flex gap-2 justify-content-between", children: palette.colors.map((hues, hueIndex) => /* @__PURE__ */ jsx("div", { className: "color-picker-hue d-flex gap-2 justify-content-between flex-column ", children: hues.map((color) => /* @__PURE__ */ jsx("button", { type: "button", "aria-label": color.description, className: "color-picker-hue-color", onClick: () => handleClick(color), children: /* @__PURE__ */ jsx(ColorPickerItem$1, { ...restProps, model: color, selected: model === color.value }) }, color.value)) }, hueIndex)) })
  ] }, paletteIdx)) });
}), ColorPicker$1 = ColorPicker, Context = /* @__PURE__ */ createContext(null), useFormControl = () => {
  const context = useContext(Context);
  if (!context)
    throw new Error("Cannot be rendered outside the FormControl component");
  return context;
}, FormText = ({
  children
}) => {
  const {
    status
  } = useFormControl(), classes = clsx("form-text", {
    "is-invalid": status === "invalid",
    valid: status === "valid"
  });
  return /* @__PURE__ */ jsx("p", { className: classes, children: /* @__PURE__ */ jsx("em", { children }) });
}, FormText$1 = FormText, Input = /* @__PURE__ */ forwardRef(({
  noValidationIcon,
  placeholder,
  size: size2 = "md",
  type = "text",
  className,
  ...restProps
}, ref) => {
  const {
    id,
    isRequired,
    isReadOnly,
    status
  } = useFormControl(), classes = clsx({
    "form-control": !isReadOnly,
    "form-control-lg": size2 === "lg",
    "form-control-sm": size2 === "sm",
    "is-invalid": status === "invalid",
    "is-valid": status === "valid",
    "form-control-plaintext": isReadOnly,
    "no-validation-icon": noValidationIcon
  }, className);
  return /* @__PURE__ */ jsx("input", { ref, id, className: classes, type, placeholder, required: isRequired, readOnly: isReadOnly, ...restProps });
}), Input$1 = Input, Label = /* @__PURE__ */ forwardRef(({
  leftIcon,
  optionalText,
  requiredText = "*",
  children,
  className
}, ref) => {
  const {
    id,
    isOptional,
    isRequired
  } = useFormControl(), {
    t
  } = useTranslation(), classes = clsx("form-label", {
    "has-icon": leftIcon
  }, className), optionalState = isOptional && !isRequired, requiredState = isRequired && !isOptional;
  return useEffect(() => {
    if (isOptional && isRequired)
      throw new Error("Cannot be optional and required at the same time");
  }, [isOptional, isRequired]), /* @__PURE__ */ jsxs("label", { ref, htmlFor: id, className: classes, children: [
    leftIcon,
    children,
    optionalState && /* @__PURE__ */ jsxs("em", { className: "optional", children: [
      "- ",
      optionalText ?? t("explorer.optional")
    ] }),
    requiredState && /* @__PURE__ */ jsx("em", { className: "required", children: requiredText })
  ] });
}), Label$1 = Label, Root$1 = /* @__PURE__ */ forwardRef(({
  children,
  className,
  id,
  isOptional,
  isReadOnly,
  isRequired,
  status,
  ...restProps
}, ref) => {
  const values = useMemo(() => ({
    id,
    isOptional,
    isRequired,
    isReadOnly,
    status
  }), [id, isOptional, isReadOnly, isRequired, status]);
  return /* @__PURE__ */ jsx(Context.Provider, { value: values, children: /* @__PURE__ */ jsx("div", { ref, className, ...restProps, children }) });
}), FormControl = /* @__PURE__ */ Object.assign(Root$1, {
  Label: Label$1,
  Input: Input$1,
  Text: FormText$1
}), FormControl$1 = FormControl, ComboboxTrigger = ({
  placeholder,
  value = "",
  searchMinLength = 3,
  handleSearchInputChange
}) => {
  const {
    triggerProps,
    itemProps,
    setVisible
  } = useDropdownContext(), inputProps = {
    ...triggerProps,
    role: "combobox",
    onClick: () => {
      value.length >= searchMinLength && setVisible(!0);
    },
    onChange: handleSearchInputChange
  };
  return useEffect(() => {
    setVisible(value.length >= searchMinLength);
  }, [setVisible, value, searchMinLength]), /* @__PURE__ */ jsx(FormControl$1, { className: "d-flex align-items-center", id: "search", children: /* @__PURE__ */ jsx(Input$1, { ...inputProps, className: "max-w-512", noValidationIcon: !0, placeholder, size: "md", type: "search", onKeyDown: itemProps.onMenuItemKeyDown }) });
}, ComboboxTrigger$1 = ComboboxTrigger, Combobox = ({
  onSearchResultsChange,
  onSearchInputChange,
  options,
  value,
  isLoading,
  noResult,
  searchMinLength,
  placeholder
}) => {
  const {
    t
  } = useTranslation(), [localValue, setLocalValue] = useState([]);
  useEffect(() => {
    onSearchResultsChange(localValue);
  }, [localValue]);
  const handleOptionClick = (value2) => {
    setLocalValue([value2]);
  }, renderContent = () => isLoading ? /* @__PURE__ */ jsxs("div", { className: "d-flex align-items-center p-4", children: [
    /* @__PURE__ */ jsx(Loading, { isLoading }),
    /* @__PURE__ */ jsx("span", { className: "ps-4", children: t("explorer.search.pending") })
  ] }) : noResult ? /* @__PURE__ */ jsx("div", { className: "p-4", children: t("portal.no.result") }) : options.map((option, index) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(Dropdown$1.Item, { type: "select", icon: option.icon, onClick: () => handleOptionClick(option.value), children: option.label }),
    index < options.length - 1 && /* @__PURE__ */ jsx(Dropdown$1.Separator, {})
  ] }, index));
  return /* @__PURE__ */ jsxs(Dropdown$1, { block: !0, children: [
    /* @__PURE__ */ jsx(Combobox.Trigger, { placeholder, searchMinLength, handleSearchInputChange: onSearchInputChange, value }),
    /* @__PURE__ */ jsx(Dropdown$1.Menu, { children: renderContent() })
  ] });
};
Combobox.Trigger = ComboboxTrigger$1;
const Combobox$1 = Combobox, DropzoneContext = /* @__PURE__ */ createContext(null);
function useDropzoneContext() {
  const context = useContext(DropzoneContext);
  if (!context)
    throw new Error("Cannot be rendered outside Dropzone Provider");
  return context;
}
const DropzoneDrag = () => {
  const {
    t
  } = useTranslation();
  return /* @__PURE__ */ jsx("div", { className: "drop-wrapper", children: /* @__PURE__ */ jsx("div", { className: "drop-content", children: /* @__PURE__ */ jsx("p", { className: "drop-text", children: t("dropzone.drop") }) }) });
}, DropzoneDrag$1 = DropzoneDrag, DropzoneFile = ({
  children,
  multiple
}) => {
  const {
    t
  } = useTranslation(), {
    files,
    inputRef
  } = useDropzoneContext(), hasFiles = files && files.length > 0, classes = clsx("drop-file-wrapper", {
    "d-block": hasFiles,
    "d-none": !hasFiles
  });
  return /* @__PURE__ */ jsxs("div", { className: classes, children: [
    /* @__PURE__ */ jsx("div", { className: "drop-file-content", children: /* @__PURE__ */ jsx("div", { className: "add-button p-4", children: /* @__PURE__ */ jsx(Button, { variant: "ghost", leftIcon: /* @__PURE__ */ jsx(Plus, {}), disabled: !multiple, onClick: () => {
      var _a;
      return (_a = inputRef == null ? void 0 : inputRef.current) == null ? void 0 : _a.click();
    }, children: t("dropzone.add.more") }) }) }),
    /* @__PURE__ */ jsx("div", { className: "p-8", children })
  ] });
}, DropzoneFile$1 = DropzoneFile, DropzoneImport = () => {
  const {
    t
  } = useTranslation(), {
    files,
    inputRef
  } = useDropzoneContext(), hasFiles = files && files.length > 0, classes = clsx("dropzone-import-wrapper", {
    "d-flex": !hasFiles,
    "d-none": hasFiles
  });
  return /* @__PURE__ */ jsxs("div", { className: classes, children: [
    /* @__PURE__ */ jsx(Download, { height: 48, width: 48 }),
    /* @__PURE__ */ jsx("p", { className: "my-16", children: t("dropzone.text") }),
    /* @__PURE__ */ jsx(Button, { onClick: () => {
      var _a;
      return (_a = inputRef == null ? void 0 : inputRef.current) == null ? void 0 : _a.click();
    }, children: t("dropzone.import") })
  ] });
}, DropzoneImport$1 = DropzoneImport, Dropzone = ({
  className,
  accept,
  multiple = !0,
  handle = !1,
  children
}) => {
  const {
    inputRef,
    dragging,
    files,
    addFile,
    deleteFile,
    replaceFileAt,
    handleDragLeave,
    handleDragging,
    handleDrop,
    handleOnChange
  } = useDropzone$1(accept ? {
    forceFilters: !0
  } : void 0), classes = clsx("dropzone", {
    "is-dragging": (multiple || files.length < 1) && dragging,
    "is-drop-files": !(files.length !== 0 && !handle)
  }, className), value = useMemo(() => ({
    inputRef,
    files,
    addFile,
    deleteFile,
    replaceFileAt
  }), [addFile, deleteFile, replaceFileAt, files, inputRef]);
  return /* @__PURE__ */ jsx(DropzoneContext.Provider, { value, children: /* @__PURE__ */ jsxs("div", { className: classes, onDragEnter: handleDragging, onDragOver: handleDragging, onDragLeave: handleDragLeave, onDrop: files.length > 0 && !multiple ? void 0 : handleDrop, children: [
    /* @__PURE__ */ jsxs("div", { className: "d-flex flex-fill", children: [
      handle ? null : /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Dropzone.File, { multiple, children }),
        /* @__PURE__ */ jsx(Dropzone.Import, {})
      ] }),
      /* @__PURE__ */ jsx(Dropzone.Drag, {})
    ] }),
    /* @__PURE__ */ jsx("input", { ref: inputRef, accept: accept == null ? void 0 : accept.join(","), multiple, type: "file", name: "attachment-input", id: "attachment-input", onChange: handleOnChange, hidden: !0 })
  ] }) });
};
Dropzone.File = DropzoneFile$1;
Dropzone.Import = DropzoneImport$1;
Dropzone.Drag = DropzoneDrag$1;
const Dropzone$1 = Dropzone, Grid = ({
  children,
  className,
  ...restProps
}) => {
  const classes = clsx("grid", className);
  return /* @__PURE__ */ jsx("div", { className: classes, ...restProps, children });
}, Column = ({
  sm,
  md,
  lg,
  xl,
  children,
  className,
  as,
  ...restProps
}) => {
  const Component2 = as || "div", classes = clsx({
    [`g-col-${sm}`]: sm,
    [md ? `g-col-md-${md}` : ""]: md,
    [lg ? `g-col-lg-${lg}` : ""]: lg,
    [xl ? `g-col-xl-${xl}` : ""]: xl
  }, className);
  return /* @__PURE__ */ jsx(Component2, { className: classes, ...restProps, children });
};
Grid.Col = Column;
const ImagePicker = /* @__PURE__ */ forwardRef(({
  label,
  addButtonLabel = "Add image",
  deleteButtonLabel = "Delete image",
  src,
  className,
  app,
  onUploadImage,
  onDeleteImage
}, ref) => {
  const [preview, setPreview] = useState(src || ""), {
    inputRef,
    files,
    deleteFile,
    handleOnChange,
    handleDragging,
    handleDragLeave,
    handleDrop
  } = useDropzone$1();
  useEffect(() => {
    if (files.length > 0) {
      deleteFile(files[0]), setPreview("");
      const file = files == null ? void 0 : files[0];
      if (!file)
        return;
      setPreview(URL.createObjectURL(file)), onUploadImage(file);
    }
  }, [files]);
  const handleClick = () => {
    var _a;
    (_a = inputRef.current) == null || _a.click();
  }, handleClean = () => {
    inputRef.current && (inputRef.current.value = ""), deleteFile(files[0]), setPreview(""), onDeleteImage();
  }, classes = clsx("image-input", className);
  return /* @__PURE__ */ jsxs(FormControl$1, { id: "image-input", className: classes, onDragEnter: handleDragging, onDragOver: handleDragging, onDragLeave: handleDragLeave, onDrop: handleDrop, ref, children: [
    /* @__PURE__ */ jsxs("div", { className: "image-input-actions gap-8", children: [
      /* @__PURE__ */ jsx(IconButton$1, { "aria-label": addButtonLabel, color: "tertiary", icon: /* @__PURE__ */ jsx(Edit, {}), onClick: handleClick, type: "button", variant: "ghost" }),
      /* @__PURE__ */ jsx(IconButton$1, { "aria-label": deleteButtonLabel, color: "danger", disabled: !preview, icon: /* @__PURE__ */ jsx(Delete, { width: "20", height: "20" }), onClick: handleClean, type: "button", variant: "ghost" })
    ] }),
    /* @__PURE__ */ jsxs(FormControl$1.Label, { children: [
      /* @__PURE__ */ jsx("span", { className: "visually-hidden", children: label }),
      /* @__PURE__ */ jsx(Input$1, { accept: "image/jpeg, image/png", hidden: !0, onChange: handleOnChange, ref: inputRef, size: "sm", type: "file" }),
      preview ? /* @__PURE__ */ jsx(Avatar, { alt: "", src: preview, size: "xl" }) : /* @__PURE__ */ jsx(AppIcon$1, { app, iconFit: "ratio", size: "160", variant: "rounded" })
    ] })
  ] });
}), ImagePicker$1 = ImagePicker, List = ({
  items,
  data,
  renderNode,
  onSelectedItems
}) => {
  const {
    selectedItems,
    allItemsSelected,
    isIndeterminate,
    handleOnSelectAllItems,
    handleOnSelectItem
  } = useCheckable(data), isDesktopDevice = useMediaQuery("only screen and (min-width: 1024px)");
  return useEffect(() => {
    selectedItems && (onSelectedItems == null || onSelectedItems(selectedItems));
  }, [onSelectedItems, selectedItems]), /* @__PURE__ */ jsxs(Fragment, { children: [
    items && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("div", { className: clsx("d-flex align-items-center gap-8", {
        "px-12": items
      }), children: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsxs("div", { className: "d-flex align-items-center gap-8", children: [
          /* @__PURE__ */ jsx(Checkbox$1, { checked: allItemsSelected, indeterminate: isIndeterminate, onChange: () => handleOnSelectAllItems(allItemsSelected) }),
          /* @__PURE__ */ jsxs("span", { children: [
            "(",
            selectedItems.length,
            ")"
          ] })
        ] }),
        /* @__PURE__ */ jsx(Toolbar, { items, isBlock: !0, align: "left", variant: "no-shadow", className: clsx("gap-4 py-4", {
          "px-0 ms-auto": !isDesktopDevice
        }) })
      ] }) }),
      /* @__PURE__ */ jsx("div", { className: "border-top" })
    ] }),
    /* @__PURE__ */ jsx("div", { className: "mt-8", children: data == null ? void 0 : data.map((node) => {
      const checkbox = /* @__PURE__ */ jsx(Checkbox$1, { checked: selectedItems.includes(node._id), onChange: () => handleOnSelectItem(node._id) }), checked = selectedItems.includes(node._id);
      return /* @__PURE__ */ jsx(Fragment$1, { children: renderNode(node, checkbox, checked) }, node._id);
    }) })
  ] });
}, LoadingScreen = /* @__PURE__ */ forwardRef(({
  position = !0,
  caption
}, ref) => {
  const [imagePath] = usePaths(), image = `${imagePath}/loading/screen-loading.gif`, containerClasses = clsx("top-0 end-0 start-0 bottom-0 d-grid justify-content-center align-content-center align-items-center z-2000", {
    "position-fixed": !position,
    "position-static": position
  }), captionClasses = clsx("text-center pt-12", {
    "text-white": !position
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("div", { ref, className: containerClasses, children: [
      /* @__PURE__ */ jsx("div", { className: "bg-white rounded-circle mx-auto w-25", children: /* @__PURE__ */ jsx("img", { src: image, alt: "loading" }) }),
      caption && /* @__PURE__ */ jsx("div", { className: captionClasses, children: caption })
    ] }),
    !position && /* @__PURE__ */ jsx("div", { className: "modal-backdrop fade show" })
  ] });
}), LoadingScreen$1 = LoadingScreen, Logo = /* @__PURE__ */ forwardRef(({
  src,
  is1d,
  translate = "Retour accueil"
}, ref) => {
  const classes = clsx("navbar-brand d-none d-md-block");
  return /* @__PURE__ */ jsx("a", { ref, className: classes, href: "/timeline/timeline", "aria-label": translate, children: /* @__PURE__ */ jsx("img", { className: "logo", src, alt: `logo ${is1d ? "ONE" : "NEO"}`, width: "300", height: "52" }) });
}), Logo$1 = Logo, useMenu = () => {
  const menuRef = useRef(null), menuItems = useRef(/* @__PURE__ */ new Set()).current, [currentIndex, setCurrentIndex] = useState(0), previousIndex = usePrevious(currentIndex) ?? 0;
  useEffect(() => {
    var _a, _b;
    if (currentIndex !== previousIndex) {
      const items = Array.from(menuItems), currentNode = (_a = items[currentIndex]) == null ? void 0 : _a.firstChild, previousNode = (_b = items[previousIndex]) == null ? void 0 : _b.firstChild;
      previousNode == null || previousNode.setAttribute("tabindex", "-1"), currentNode == null || currentNode.setAttribute("tabindex", "0"), currentNode == null || currentNode.focus({
        preventScroll: !0
      });
    }
  }, [currentIndex, previousIndex, menuItems]);
  const first = () => setCurrentIndex(0), last = () => setCurrentIndex(menuItems.size - 1), next = () => {
    const index = currentIndex === menuItems.size - 1 ? 0 : currentIndex + 1;
    setCurrentIndex(index);
  }, previous = () => {
    const index = currentIndex === 0 ? menuItems.size - 1 : currentIndex - 1;
    setCurrentIndex(index);
  }, onKeyDown = (event) => {
    switch (event.stopPropagation(), event.code) {
      case "ArrowUp":
        event.preventDefault(), previous();
        break;
      case "ArrowDown":
        event.preventDefault(), next();
        break;
    }
    switch (event.code) {
      case "End":
        event.preventDefault(), last();
        break;
      case "Home":
        event.preventDefault(), first();
        break;
    }
  }, childProps = useMemo(() => ({
    "data-menubar-menuitem": "",
    role: "menuitem"
  }), []);
  return {
    menuRef,
    menuItems,
    childProps,
    onKeyDown
  };
}, MenuContext = /* @__PURE__ */ createContext(null);
function useMenuContext() {
  const context = useContext(MenuContext);
  if (!context)
    throw new Error("Cannot be rendered outside the Menu component");
  return context;
}
const MenuButton = (props) => {
  const {
    selected,
    leftIcon,
    rightIcon,
    onClick,
    children
  } = props, {
    childProps
  } = useMenuContext();
  return /* @__PURE__ */ jsx(Button, { variant: "ghost", color: "tertiary", className: clsx("stack w-100", {
    selected
  }), leftIcon, rightIcon, onClick, ...childProps, children });
}, MenuItem = ({
  children
}) => {
  const itemRef = useRef(null), id = useId(), {
    menuItems
  } = useMenuContext();
  return useEffect(() => {
    const itemNode = itemRef.current;
    return itemNode && menuItems.add(itemNode), () => {
      itemNode && menuItems.delete(itemNode);
    };
  }, [menuItems]), /* @__PURE__ */ jsx("li", { ref: itemRef, id, role: "none", "data-menubar-listitem": !0, children });
}, Menu = ({
  label,
  children
}) => {
  const {
    menuRef,
    childProps,
    menuItems,
    onKeyDown
  } = useMenu(), values = useMemo(() => ({
    menuRef,
    menuItems,
    childProps
  }), [childProps, menuItems, menuRef]);
  return /* @__PURE__ */ jsx(MenuContext.Provider, { value: values, children: /* @__PURE__ */ jsx("nav", { "aria-label": label, className: "menu", children: /* @__PURE__ */ jsx("ul", { ref: menuRef, role: "menubar", "aria-label": label, onKeyDown, "data-menubar-list": !0, className: "list-unstyled d-flex flex-column gap-4", children }) }) });
};
Menu.Item = MenuItem;
Menu.Button = MenuButton;
const PopoverHeader = ({
  children,
  className
}) => {
  const classes = clsx("popover-header", className);
  return /* @__PURE__ */ jsx("div", { className: classes, children });
}, PopoverBody = ({
  children,
  className
}) => {
  const classes = clsx("popover-body", className);
  return /* @__PURE__ */ jsx("div", { className: classes, children });
}, PopoverFooter = ({
  children,
  className
}) => {
  const classes = clsx("popover-footer p-8", className);
  return /* @__PURE__ */ jsx("div", { className: classes, children });
}, Popover = /* @__PURE__ */ forwardRef(({
  children,
  className,
  id,
  isVisible,
  ...restProps
}, ref) => {
  const classes = clsx("popover d-block position-absolute top-100 start-50 translate-middle-x", className);
  return useTransition(isVisible, {
    from: {
      opacity: 0
    },
    enter: {
      opacity: 1
    },
    leave: {
      opacity: 0
    },
    config: {
      duration: 0
    }
  })((style, isVisible2) => isVisible2 && /* @__PURE__ */ jsx(animated.div, { ref, "aria-labelledby": id, className: classes, role: "tooltip", style, ...restProps, children }));
}), SearchBar = ({
  isVariant = !1,
  size: size2 = "md",
  placeholder = "search",
  className,
  disabled,
  onChange,
  onClick,
  ...restProps
}) => {
  const {
    t
  } = useTranslation(), searchbar = clsx(className, {
    "input-group": !isVariant,
    "position-relative": isVariant
  }), input = clsx({
    "border-end-0": !isVariant,
    "ps-48": isVariant
  }), handleClick = () => {
    onClick == null || onClick();
  };
  return /* @__PURE__ */ jsxs(FormControl$1, { id: "search-bar", className: searchbar, children: [
    isVariant && /* @__PURE__ */ jsx("div", { className: "position-absolute z-1 top-50 start-0 translate-middle-y border-0 ps-12 bg-transparent", children: /* @__PURE__ */ jsx(Search, {}) }),
    /* @__PURE__ */ jsx(FormControl$1.Input, { type: "search", placeholder: t(placeholder), size: size2, noValidationIcon: !0, className: input, onChange, disabled, ...restProps }),
    !isVariant && /* @__PURE__ */ jsx(SearchButton$1, { type: "submit", "aria-label": t("search"), icon: /* @__PURE__ */ jsx(Search, {}), className: "border-start-0", onClick: handleClick })
  ] });
}, SearchBar$1 = SearchBar, TableTbody = (props) => {
  const {
    children,
    ...restProps
  } = props;
  return /* @__PURE__ */ jsx("tbody", { ...restProps, children });
}, TableTd = (props) => {
  const {
    children,
    ...restProps
  } = props;
  return /* @__PURE__ */ jsx("td", { ...restProps, children });
}, TableTh = (props) => {
  const {
    children,
    ...restProps
  } = props;
  return /* @__PURE__ */ jsx("th", { ...restProps, children });
}, TableThead = (props) => {
  const {
    children,
    ...restProps
  } = props;
  return /* @__PURE__ */ jsx("thead", { ...restProps, children });
}, TableTr = (props) => {
  const {
    children,
    ...restProps
  } = props;
  return /* @__PURE__ */ jsx("tr", { ...restProps, children });
}, Root = /* @__PURE__ */ forwardRef(({
  children
}, ref) => /* @__PURE__ */ jsx("div", { className: "table-responsive", children: /* @__PURE__ */ jsx("table", { ref, className: "table align-middle mb-0", children }) })), Table = /* @__PURE__ */ Object.assign(Root, {
  Thead: TableThead,
  Th: TableTh,
  Tbody: TableTbody,
  Tr: TableTr,
  Td: TableTd
}), Table$1 = Table, TextArea = /* @__PURE__ */ forwardRef(({
  noValidationIcon,
  placeholder,
  size: size2 = "md",
  height = "md",
  className,
  ...restProps
}, ref) => {
  const {
    id,
    isRequired,
    isReadOnly,
    status
  } = useFormControl(), classes = clsx({
    "form-control": !isReadOnly,
    "form-control-lg": size2 === "lg",
    "form-control-sm": size2 === "sm",
    "textarea-height-lg": height === "lg",
    "textarea-height-md": height === "md",
    "textarea-height-sm": height === "sm",
    "is-invalid": status === "invalid",
    "is-valid": status === "valid",
    "form-control-plaintext": isReadOnly,
    "no-validation-icon": noValidationIcon
  }, className);
  return /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx("textarea", { ref, id, className: classes, placeholder, required: isRequired, readOnly: isReadOnly, ...restProps }) });
}), TextArea$1 = TextArea, Toolbar = /* @__PURE__ */ forwardRef(({
  items,
  variant = "default",
  align = "space",
  isBlock = !1,
  ariaControls,
  className
}, ref) => {
  const [firstFocusableItemIndex, setFirstFocusableItemIndex] = useState(0), [a11yNavigationItems, setA11yNavigationItems] = useState([]), [firstA11yNavigationItem, setFirstA11yNavigationItem] = useState(), [lastA11yNavigationItem, setA11yNavigationLastItem] = useState(), divToolbarRef = useRef(), classes = clsx("toolbar z-1000 bg-white", className, {
    default: variant === "default",
    "no-shadow": variant === "no-shadow",
    "d-flex": isBlock,
    "d-inline-flex": !isBlock,
    "overflow-x-auto": isBlock,
    "justify-content-start": align === "left",
    "justify-content-between": align === "space",
    "justify-content-center": align === "center",
    "justify-content-end": align === "right"
  });
  useEffect(() => {
    var _a;
    const buttons = (_a = divToolbarRef.current) == null ? void 0 : _a.querySelectorAll("button"), enabledItems = [];
    let isfirstItemSet = !1;
    buttons == null || buttons.forEach((item) => {
      item.disabled || (isfirstItemSet || (setFirstA11yNavigationItem(item), isfirstItemSet = !0), setA11yNavigationLastItem(item), enabledItems.push(item));
    }), setA11yNavigationItems(enabledItems), setFirstFocusableItemIndex(items.findIndex((item) => (item.type === "button" || item.type === "icon") && !item.props.disabled));
  }, [items]);
  const handleFocus = (event) => {
    event.target.classList.add("focus");
  }, handleBlur = (event) => {
    event.target.classList.remove("focus");
  }, handleKeyDown = (event) => {
    var _a, _b;
    const index = a11yNavigationItems.indexOf(event.currentTarget);
    switch (event.code) {
      case "ArrowLeft":
        event.currentTarget === firstA11yNavigationItem ? lastA11yNavigationItem == null || lastA11yNavigationItem.focus() : (_a = a11yNavigationItems[index - 1]) == null || _a.focus();
        break;
      case "ArrowRight":
        event.currentTarget === lastA11yNavigationItem ? firstA11yNavigationItem == null || firstA11yNavigationItem.focus() : (_b = a11yNavigationItems[index + 1]) == null || _b.focus();
        break;
    }
  }, renderTooltipMessage = (item) => {
    var _a;
    return typeof item.tooltip == "string" ? item.tooltip : (_a = item.tooltip) == null ? void 0 : _a.message;
  }, renderTooltipPosition = (item) => {
    var _a;
    return typeof item.tooltip != "string" ? (_a = item.tooltip) == null ? void 0 : _a.position : "top";
  };
  return /* @__PURE__ */ jsx("div", { ref: mergeRefs(ref, divToolbarRef), className: classes, role: "toolbar", "aria-label": "Text Formatting", "aria-controls": ariaControls, onFocus: handleFocus, onBlur: handleBlur, children: items.map((item, index) => {
    if (item.visibility === "hide")
      return null;
    switch (item.type) {
      case "divider":
        return /* @__PURE__ */ jsx("div", { className: "toolbar-divider" }, item.name ?? index);
      case "button":
        return /* @__PURE__ */ jsx(Tooltip$1, { message: renderTooltipMessage(item), placement: renderTooltipPosition(item), children: /* @__PURE__ */ createElement(Button, { ...item.props, key: item.name ?? index, color: item.props.color ? item.props.color : "tertiary", variant: "ghost", tabIndex: index === firstFocusableItemIndex ? 0 : -1, onKeyDown: handleKeyDown }) }, item.name ?? index);
      case "icon":
        return /* @__PURE__ */ jsx(Tooltip$1, { message: renderTooltipMessage(item), placement: renderTooltipPosition(item), children: /* @__PURE__ */ createElement(IconButton$1, { ...item.props, key: item.name ?? index, color: item.props.color ? item.props.color : "tertiary", variant: item.props.variant ? item.props.variant : "ghost", tabIndex: index === firstFocusableItemIndex ? 0 : -1, onKeyDown: handleKeyDown }) }, item.name ?? index);
      case "dropdown":
        return /* @__PURE__ */ createElement(Dropdown$1, { ...item.props, key: item.name ?? index, extraTriggerKeyDownHandler: handleKeyDown, overflow: item.overflow });
      case "primary":
        return /* @__PURE__ */ jsx(Tooltip$1, { message: renderTooltipMessage(item), placement: renderTooltipPosition(item), children: /* @__PURE__ */ jsx(Button, { ...item.props, variant: "filled", color: "primary", tabIndex: index === firstFocusableItemIndex ? 0 : -1, onKeyDown: handleKeyDown }) }, item.name ?? index);
    }
    return null;
  }) });
});
function findNodeById(data, id) {
  if (Array.isArray(data))
    for (const node of data) {
      const result = findNodeById(node, id);
      if (result)
        return result;
    }
  else {
    if (data.id === id)
      return data;
    if (data.children)
      for (const child of data.children) {
        const result = findNodeById(child, id);
        if (result)
          return result;
      }
  }
}
function findPathById(tree, nodeId) {
  let path = [];
  function traverse(node, currentPath) {
    if (node.id === nodeId)
      return path = currentPath.concat(node.id), !0;
    if (node.children) {
      for (const child of node.children)
        if (traverse(child, currentPath.concat(node.id)))
          return !0;
    }
    return !1;
  }
  function startTraverse(nodes) {
    if (Array.isArray(nodes)) {
      for (const node of nodes)
        if (traverse(node, []))
          break;
    } else
      traverse(nodes, []);
  }
  return startTraverse(tree), path;
}
const useTree = ({
  data,
  externalSelectedNodeId,
  draggedNode,
  shouldExpandAllNodes,
  onTreeItemUnfold,
  onTreeItemFold,
  onTreeItemClick
}) => {
  const [internalSelectedNodeId, setInternalSelectedNodeId] = useState(void 0), [expandedNodes, setExpandedNodes] = useState(/* @__PURE__ */ new Set()), siblingsNodes = useRef(/* @__PURE__ */ new Set()), [draggedNodeId, setDraggedNodeId] = useState(void 0), selectedNodeId = internalSelectedNodeId ?? externalSelectedNodeId;
  function addNodesWithSiblingHavingChildren(data2) {
    var _a;
    Array.isArray(data2) ? data2.forEach((node) => {
      const resultSet = new Set(siblingsNodes.current);
      data2.filter(({
        id
      }) => id !== node.id).some((sibling) => sibling.children && sibling.children.length > 0) && resultSet.add(node.id), node.children && node.children.length > 0 && node.children.forEach((child) => {
        var _a2;
        const childSiblings = (_a2 = node.children) == null ? void 0 : _a2.filter(({
          id
        }) => id !== child.id);
        (childSiblings == null ? void 0 : childSiblings.some((sibling) => sibling.children && sibling.children.length > 0)) && resultSet.add(child.id), addNodesWithSiblingHavingChildren(child);
      });
    }) : (_a = data2.children) == null || _a.forEach((child) => {
      var _a2;
      const resultSet = new Set(siblingsNodes.current), siblings = (_a2 = data2.children) == null ? void 0 : _a2.filter((c) => c.id !== child.id);
      (siblings == null ? void 0 : siblings.some((sibling) => sibling.children && sibling.children.length > 0)) && (resultSet.add(child.id), siblingsNodes.current = resultSet), addNodesWithSiblingHavingChildren(child);
    });
  }
  const expandAllNodes = (shouldExpandAllNodes2) => {
    const initExpandedNodes = new Set("");
    data && Array.isArray(data) && shouldExpandAllNodes2 && (data.forEach((node) => initExpandedNodes.add(node.id)), setExpandedNodes(initExpandedNodes));
  };
  useEffect(() => {
    data && addNodesWithSiblingHavingChildren(data);
  }, [data]), useEffect(() => {
    draggedNode != null && draggedNode.isOver && draggedNode.isTreeview ? (draggedNode.overId && handleItemDrag(draggedNode.overId), setDraggedNodeId(draggedNode.overId)) : setDraggedNodeId(void 0);
  }, [draggedNode]), useEffect(() => {
    shouldExpandAllNodes && expandAllNodes(shouldExpandAllNodes);
  }, [data, shouldExpandAllNodes]), useEffect(() => {
    externalSelectedNodeId && !shouldExpandAllNodes ? (handleExternalSelectedNodeId(externalSelectedNodeId), setInternalSelectedNodeId(externalSelectedNodeId)) : setInternalSelectedNodeId(void 0);
  }, [externalSelectedNodeId]);
  const handleExternalSelectedNodeId = (nodeId) => {
    if (!findNodeById(data, selectedNodeId)) {
      setInternalSelectedNodeId(void 0);
      return;
    }
    if (externalSelectedNodeId === "default") {
      expandedNodes.forEach((node) => onTreeItemUnfold == null ? void 0 : onTreeItemUnfold(node));
      return;
    }
    handleExpandNode(nodeId);
  }, handleExpandNode = (nodeId) => {
    const updatedExpandedNodes = new Set(expandedNodes), parents = findPathById(data, nodeId), arrayOrder = Array.from(updatedExpandedNodes);
    parents.forEach((parent) => {
      const index = arrayOrder.indexOf(parent);
      index > -1 && arrayOrder.splice(index, 1), arrayOrder.push(parent);
    }), updatedExpandedNodes.clear(), arrayOrder.forEach((node) => updatedExpandedNodes.add(node)), updatedExpandedNodes.forEach((node) => onTreeItemUnfold == null ? void 0 : onTreeItemUnfold(node)), setExpandedNodes(updatedExpandedNodes);
  }, handleCollapseNode = (nodeId) => {
    const updatedExpandedNodes = new Set(expandedNodes);
    updatedExpandedNodes.delete(nodeId), updatedExpandedNodes.forEach((node) => onTreeItemFold == null ? void 0 : onTreeItemFold(node)), setExpandedNodes(updatedExpandedNodes);
  }, handleToggleNode = (nodeId) => {
    expandedNodes.has(nodeId) ? handleCollapseNode(nodeId) : handleExpandNode(nodeId);
  }, handleSelectedItem = (nodeId) => {
    selectedNodeId !== nodeId && setInternalSelectedNodeId(nodeId);
  }, handleItemClick = (nodeId) => {
    handleSelectedItem(nodeId), handleExpandNode(nodeId), onTreeItemClick == null || onTreeItemClick(nodeId);
  }, handleFoldUnfold = (nodeId) => handleToggleNode(nodeId), handleItemDrag = (nodeId) => {
    findNodeById(data, externalSelectedNodeId) && handleCollapseNode(nodeId);
  };
  return {
    selectedNodeId,
    expandedNodes,
    siblingsNodes,
    draggedNodeId,
    handleItemClick,
    handleFoldUnfold,
    collapseAllNodes: () => {
      setExpandedNodes(/* @__PURE__ */ new Set());
    }
  };
}, useTreeSortable = ({
  nodes,
  onSortable,
  collapseAllNodes
}) => {
  const [items, setItems] = useState(() => nodes), [activeId, setActiveId] = useState(null), [overId, setOverId] = useState(null), [offsetLeft, setOffsetLeft] = useState(0), [currentPosition, setCurrentPosition] = useState(null);
  useEffect(() => {
    setItems(nodes);
  }, [nodes]);
  const activationConstraint = {
    delay: 200,
    tolerance: 5
  }, indicator = !1, indentationWidth = 64, flattenedTree = useMemo(
    () => flattenTree(items, null),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [items]
  ), activeItem = activeId ? flattenedTree.find(({
    id
  }) => id === activeId) : null, projected = activeId && overId ? getProjection(flattenedTree, activeId, overId, offsetLeft, indentationWidth) : null;
  function handleDragStart(event) {
    const {
      active
    } = event, {
      activeNode
    } = getActiveAndOverNodes(flattenedTree, active.id);
    activeNode.parentId || collapseAllNodes(), setActiveId(active.id), setOverId(active.id);
    const activeItem2 = flattenedTree.find(({
      id
    }) => id === activeId);
    activeItem2 && setCurrentPosition({
      parentId: activeItem2.parentId,
      overId: activeId
    });
  }
  function handleDragMove({
    delta
  }) {
    setOffsetLeft(delta.x);
  }
  function handleDragOver(event) {
    const {
      over
    } = event;
    setOverId(over == null ? void 0 : over.id);
  }
  function handleDragEnd(event) {
    const {
      active,
      over
    } = event, {
      activeNode,
      activeNodeIndex,
      overNode,
      overNodeIndex
    } = getActiveAndOverNodes(flattenedTree, active.id, over == null ? void 0 : over.id), newParentId = determineNewParentId(active, over, activeNode, overNode, projected), indicesToUpdate = getIndicesToUpdate(activeNode, activeNodeIndex, flattenedTree, projected);
    updateParentIds(flattenedTree, indicesToUpdate, newParentId);
    const updatedFlattenedTree = arrayMove(flattenedTree, activeNodeIndex, overNodeIndex), updatedTree = buildTree(updatedFlattenedTree), {
      updateArray
    } = generateUpdateData(updatedFlattenedTree, updatedTree);
    setItems(updatedTree), setActiveId(null), setOverId(null), onSortable(updateArray);
  }
  const sortedIds = useMemo(() => flattenedTree.map(({
    id
  }) => id), [flattenedTree]);
  function getMovementAnnouncement(eventName, activeId2, overId2) {
    if (overId2 && projected) {
      if (eventName !== "onDragEnd") {
        if (currentPosition && projected.parentId === currentPosition.parentId && overId2 === currentPosition.overId)
          return;
        setCurrentPosition({
          parentId: projected.parentId,
          overId: overId2
        });
      }
      const clonedItems = JSON.parse(JSON.stringify(flattenTree(items, null, 0))), overIndex = clonedItems.findIndex(({
        id
      }) => id === overId2), activeIndex = clonedItems.findIndex(({
        id
      }) => id === activeId2), sortedItems = arrayMove(clonedItems, activeIndex, overIndex), previousItem = sortedItems[overIndex - 1];
      let announcement;
      const movedVerb = eventName === "onDragEnd" ? "dropped" : "moved", nestedVerb = eventName === "onDragEnd" ? "dropped" : "nested";
      if (previousItem)
        if (projected.depth > previousItem.depth)
          announcement = `${activeId2} was ${nestedVerb} under ${previousItem.id}.`;
        else {
          let previousSibling = previousItem;
          for (; previousSibling && projected.depth < previousSibling.depth; ) {
            const parentId = previousSibling.parentId;
            previousSibling = sortedItems.find(({
              id
            }) => id === parentId);
          }
          previousSibling && (announcement = `${activeId2} was ${movedVerb} after ${previousSibling.id}.`);
        }
      else {
        const nextItem = sortedItems[overIndex + 1];
        nextItem ? announcement = `${activeId2} was ${movedVerb} before ${nextItem.id}.` : announcement = `${activeId2} was ${movedVerb} as the only item in the list.`;
      }
      return announcement;
    }
  }
  const announcements = {
    onDragStart({
      active
    }) {
      return `Picked up ${active.id}.`;
    },
    onDragMove({
      active,
      over
    }) {
      return getMovementAnnouncement("onDragMove", active.id, over == null ? void 0 : over.id);
    },
    onDragOver({
      active,
      over
    }) {
      return getMovementAnnouncement("onDragOver", active.id, over == null ? void 0 : over.id);
    },
    onDragEnd({
      active,
      over
    }) {
      return getMovementAnnouncement("onDragEnd", active.id, over == null ? void 0 : over.id);
    },
    onDragCancel({
      active
    }) {
      return `Moving was cancelled. ${active.id} was dropped in its original position.`;
    }
  }, dropAnimationConfig = {
    keyframes({
      transform
    }) {
      return [{
        opacity: 1,
        transform: CSS.Transform.toString(transform.initial)
      }, {
        opacity: 0,
        transform: CSS.Transform.toString({
          ...transform.final,
          x: transform.final.x + 5,
          y: transform.final.y + 5
        })
      }];
    },
    easing: "ease-out",
    sideEffects({
      active
    }) {
      active.node.animate([{
        opacity: 0
      }, {
        opacity: 1
      }], {
        duration: defaultDropAnimation.duration,
        easing: defaultDropAnimation.easing
      });
    }
  }, adjustTranslate = ({
    transform
  }) => ({
    ...transform,
    y: transform.y - 25
  }), measuring = {
    droppable: {
      strategy: MeasuringStrategy.Always
    }
  }, sensors = useSensors(useSensor(PointerSensor, {
    activationConstraint
  }), useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates
  }));
  return {
    handleDragStart,
    handleDragMove,
    handleDragOver,
    handleDragEnd,
    adjustTranslate,
    sortedIds,
    indicator,
    activationConstraint,
    projected,
    announcements,
    activeId,
    indentationWidth,
    activeItem,
    dropAnimationConfig,
    measuring,
    sensors,
    items,
    flattenedTree
  };
}, SortableTree = ({
  nodes,
  selectedNodeId: externalSelectedNodeId,
  showIcon = !1,
  shouldExpandAllNodes = !1,
  renderNode,
  isDisabled = () => !1,
  onTreeItemClick,
  onSortable
}) => {
  const {
    selectedNodeId,
    expandedNodes,
    handleItemClick,
    handleFoldUnfold,
    collapseAllNodes
  } = useTree({
    data: nodes,
    externalSelectedNodeId,
    shouldExpandAllNodes,
    onTreeItemClick
  }), {
    handleDragEnd,
    handleDragMove,
    handleDragOver,
    handleDragStart,
    adjustTranslate,
    sortedIds,
    indicator,
    projected,
    announcements,
    activeId,
    indentationWidth,
    activeItem,
    dropAnimationConfig,
    measuring,
    sensors,
    items
  } = useTreeSortable({
    nodes,
    onSortable,
    collapseAllNodes
  });
  return /* @__PURE__ */ jsx("div", { className: "treeview", children: /* @__PURE__ */ jsx("ul", { role: "tree", className: "m-0 p-0", children: /* @__PURE__ */ jsxs(DndContext, { accessibility: {
    announcements
  }, sensors, measuring, onDragStart: handleDragStart, onDragEnd: handleDragEnd, onDragOver: handleDragOver, onDragMove: handleDragMove, children: [
    /* @__PURE__ */ jsx(SortableContext, { items: sortedIds, strategy: verticalListSortingStrategy, children: Array.isArray(items) && items.map((node) => /* @__PURE__ */ jsx(TreeNode$2, { node, showIcon, expandedNodes, selectedNodeId, renderNode, disabled: isDisabled(node.id), onTreeItemClick: handleItemClick, onToggleNode: handleFoldUnfold, depth: node.id === activeId && projected ? projected.depth : 0, indentationWidth, projected }, node.id)) }),
    /* @__PURE__ */ createPortal(/* @__PURE__ */ jsx(DragOverlay, { dropAnimation: dropAnimationConfig, modifiers: indicator ? [adjustTranslate] : void 0, children: activeId && activeItem ? /* @__PURE__ */ jsx(DragOverlayItem, { activeItem }) : null }), document.body)
  ] }) }) });
}, TreeNode$2 = /* @__PURE__ */ forwardRef(({
  node,
  selectedNodeId,
  showIcon = !1,
  expandedNodes,
  focused,
  disabled,
  indentationWidth,
  depth,
  isChild,
  projected,
  renderNode,
  onTreeItemClick,
  onToggleNode
}, ref) => {
  var _a;
  const {
    t
  } = useTranslation(), selected = selectedNodeId === node.id, expanded = expandedNodes.has(node.id), animateLayoutChanges = ({
    isSorting,
    wasDragging
  }) => !(isSorting || wasDragging), {
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = useSortable({
    id: node.id,
    disabled,
    animateLayoutChanges
  }), style = {
    transform: CSS.Translate.toString(transform),
    transition
  }, treeItemClasses = {
    action: clsx("action-container d-flex align-items-center gap-8 px-2", {
      "drag-focus": focused,
      "border border-secondary rounded rounded-2 shadow bg-white": isDragging
    }),
    arrow: clsx({
      invisible: !Array.isArray(node.children) || node.children.length === 0
    }),
    button: clsx("flex-fill d-flex align-items-center text-truncate gap-8", {
      "py-8": depth === 0,
      "py-4": depth === 1
    })
  }, handleItemKeyDown = (event) => {
    (event.code === "Enter" || event.code === "Space") && (event.preventDefault(), event.stopPropagation(), onTreeItemClick == null || onTreeItemClick(node.id));
  }, handleItemToggleKeyDown = (event) => {
    (event.code === "Enter" || event.code === "Space") && (event.preventDefault(), event.stopPropagation(), onToggleNode == null || onToggleNode(node.id));
  }, spaceGestion = () => isDragging ? isChild ? depth === 1 ? `${indentationWidth * depth}px` : "0px" : `${indentationWidth * depth}px` : null;
  return /* @__PURE__ */ jsx("li", { ref: setNodeRef, id: `treeitem-${node.id}`, role: "treeitem", "aria-selected": selected, "aria-expanded": expanded, style: {
    ...style,
    marginLeft: spaceGestion()
  }, ...listeners, children: /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsxs("div", { className: treeItemClasses.action, children: [
      /* @__PURE__ */ jsx("div", { className: treeItemClasses.arrow, tabIndex: 0, role: "button", onClick: () => onToggleNode == null ? void 0 : onToggleNode(node.id), onKeyDown: handleItemToggleKeyDown, "aria-label": t("foldUnfold"), children: /* @__PURE__ */ jsx(RafterRight, { width: 16, style: {
        transform: expanded ? "rotate(90deg)" : ""
      } }) }),
      node.children && showIcon ? /* @__PURE__ */ jsx(Folder, { title: "folder", width: 20, height: 20 }) : null,
      /* @__PURE__ */ jsx("div", { tabIndex: 0, role: "button", className: treeItemClasses.button, onClick: () => onTreeItemClick(node.id), onKeyDown: handleItemKeyDown, children: renderNode ? renderNode({
        node,
        hasChildren: Array.isArray(node.children) && !!node.children.length,
        isChild
      }) : /* @__PURE__ */ jsx("div", { className: "text-truncate", children: node.name }) })
    ] }),
    expanded && node.children && !!node.children.length && /* @__PURE__ */ jsx("ul", { role: "group", children: (_a = node.children) == null ? void 0 : _a.map((node2) => /* @__PURE__ */ jsx(TreeNode$2, { ref, node: node2, showIcon, selectedNodeId, expandedNodes, onTreeItemClick, onToggleNode, renderNode, indentationWidth, depth: node2.id === (projected == null ? void 0 : projected.activeId) && projected ? projected.depth : 0, isChild: !0, projected }, node2.id)) })
  ] }) }, node.id);
}), DragOverlayItem = /* @__PURE__ */ forwardRef(({
  activeItem,
  ...props
}, ref) => /* @__PURE__ */ jsx("div", { ref, ...props, className: "opacity-0", style: {
  cursor: "grabbing"
}, children: /* @__PURE__ */ jsx("div", { className: clsx("action-container align-items-center gap-8 px-2"), style: {
  backgroundColor: "white",
  border: "1px solid black",
  width: "100px"
}, children: /* @__PURE__ */ jsx("div", { className: clsx("flex-fill d-flex align-items-center text-truncate gap-8 py-8"), children: /* @__PURE__ */ jsx("span", { className: "text-truncate", children: activeItem == null ? void 0 : activeItem.name }) }) }) })), SortableTree$1 = SortableTree, Tree = ({
  nodes,
  selectedNodeId: externalSelectedNodeId,
  showIcon = !1,
  shouldExpandAllNodes = !1,
  draggedNode,
  renderNode,
  onTreeItemFold,
  onTreeItemUnfold,
  onTreeItemClick
}) => {
  const {
    selectedNodeId,
    expandedNodes,
    siblingsNodes,
    handleItemClick,
    handleFoldUnfold
  } = useTree({
    data: nodes,
    externalSelectedNodeId,
    draggedNode,
    shouldExpandAllNodes,
    onTreeItemClick,
    onTreeItemFold,
    onTreeItemUnfold
  });
  return /* @__PURE__ */ jsx("div", { className: "treeview", children: /* @__PURE__ */ jsx("ul", { role: "tree", className: "m-0 p-0", children: Array.isArray(nodes) ? nodes.map((node) => /* @__PURE__ */ jsx(TreeNode$1, { node, showIcon, selectedNodeId, expandedNodes, siblingsNodes, onTreeItemClick: handleItemClick, onToggleNode: handleFoldUnfold, renderNode }, node.id)) : /* @__PURE__ */ jsx(TreeNode$1, { node: nodes, selectedNodeId, expandedNodes, siblingsNodes, showIcon, onTreeItemClick: handleItemClick, onToggleNode: handleFoldUnfold }) }) });
}, TreeNode$1 = /* @__PURE__ */ forwardRef(({
  node,
  selectedNodeId,
  showIcon = !1,
  expandedNodes,
  focused,
  isChild,
  renderNode,
  onTreeItemClick,
  onToggleNode,
  ...restProps
}, ref) => {
  var _a;
  const {
    t
  } = useTranslation(), selected = selectedNodeId === node.id, expanded = expandedNodes.has(node.id), treeItemClasses = {
    action: clsx("action-container d-flex align-items-center gap-8 px-2", {
      "drag-focus": focused,
      "py-4": !node.section
    }),
    arrow: clsx({
      "py-4": !node.section,
      "py-8": node.section,
      invisible: !Array.isArray(node.children) || node.children.length === 0
    }),
    button: clsx("flex-fill d-flex align-items-center text-truncate gap-8", {
      "py-8": node.section
    })
  }, handleItemKeyDown = (event) => {
    (event.code === "Enter" || event.code === "Space") && (event.preventDefault(), event.stopPropagation(), onTreeItemClick == null || onTreeItemClick(node.id));
  }, handleItemToggleKeyDown = (event) => {
    (event.code === "Enter" || event.code === "Space") && (event.preventDefault(), event.stopPropagation(), onToggleNode == null || onToggleNode(node.id));
  };
  return /* @__PURE__ */ createElement("li", { ...restProps, ref, key: node.id, id: `treeitem-${node.id}`, role: "treeitem", "aria-selected": selected, "aria-expanded": expanded }, /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsxs("div", { className: treeItemClasses.action, children: [
      node.children && node.children.length > 0 ? /* @__PURE__ */ jsx("div", { className: treeItemClasses.arrow, tabIndex: 0, role: "button", onClick: () => onToggleNode == null ? void 0 : onToggleNode(node.id), onKeyDown: handleItemToggleKeyDown, "aria-label": t("foldUnfold"), children: /* @__PURE__ */ jsx(RafterRight, { width: 16, style: {
        transform: expanded ? "rotate(90deg)" : ""
      } }) }) : /* @__PURE__ */ jsx("div", { className: "py-8 invisible" }),
      node.children && showIcon ? /* @__PURE__ */ jsx(Folder, { title: "folder", width: 20, height: 20 }) : null,
      /* @__PURE__ */ jsx("div", { tabIndex: 0, role: "button", className: treeItemClasses.button, onClick: () => onTreeItemClick(node.id), onKeyDown: handleItemKeyDown, children: renderNode ? renderNode({
        node,
        hasChildren: Array.isArray(node.children) && !!node.children.length,
        isChild
      }) : /* @__PURE__ */ jsx("div", { className: "text-truncate", children: node.name }) })
    ] }),
    expanded && node.children && !!node.children.length && /* @__PURE__ */ jsx("ul", { role: "group", children: (_a = node.children) == null ? void 0 : _a.map((node2) => /* @__PURE__ */ createElement(TreeNode$1, { ...restProps, ref, node: node2, key: node2.id, showIcon, selectedNodeId, expandedNodes, onTreeItemClick, onToggleNode, renderNode, isChild: !0 })) })
  ] }));
}), Tree$1 = Tree, DndTree = /* @__PURE__ */ forwardRef(({
  nodes,
  selectedNodeId: externalSelectedNodeId,
  showIcon = !1,
  shouldExpandAllNodes = !1,
  draggedNode,
  onTreeItemClick,
  onTreeItemFold,
  onTreeItemUnfold,
  renderNode
}, ref) => {
  const {
    selectedNodeId,
    expandedNodes,
    draggedNodeId,
    handleItemClick,
    handleFoldUnfold
  } = useTree({
    data: nodes,
    externalSelectedNodeId,
    draggedNode,
    shouldExpandAllNodes,
    onTreeItemClick,
    onTreeItemFold,
    onTreeItemUnfold
  });
  return /* @__PURE__ */ jsx("div", { className: "treeview", ref, children: /* @__PURE__ */ jsx("ul", { role: "tree", className: "m-0 p-0", children: Array.isArray(nodes) && nodes.map((node) => /* @__PURE__ */ jsx(DndTreeNode, { node, showIcon, draggedNodeId, expandedNodes, selectedNodeId, onTreeItemClick: handleItemClick, onToggleNode: handleFoldUnfold, renderNode }, node.id)) }) });
}), DndTreeNode = /* @__PURE__ */ forwardRef(({
  node,
  selectedNodeId,
  showIcon = !1,
  expandedNodes,
  renderNode,
  onTreeItemClick,
  onToggleNode,
  draggedNodeId,
  ...restProps
}, ref) => {
  const {
    setNodeRef
  } = useDroppable({
    id: useId(),
    data: {
      id: node.id,
      name: node.name,
      isTreeview: !0,
      accepts: ["folder", "resource"]
    }
  }), focused = draggedNodeId === node.id;
  return /* @__PURE__ */ jsx(TreeNode$1, { ref: mergeRefs(ref, setNodeRef), node, showIcon, selectedNodeId, expandedNodes, onTreeItemClick, onToggleNode, renderNode, focused, ...restProps }, node.id);
}), DndTree$1 = DndTree, TreeNode = ({
  node,
  showIcon,
  selectedNodeId,
  expandedNodes,
  siblingsNodes,
  draggedNodeId,
  handleItemClick,
  handleToggleNode,
  handleItemAction
}) => {
  const expanded = expandedNodes.has(node.id), sibling = siblingsNodes == null ? void 0 : siblingsNodes.current.has(node.id), selected = selectedNodeId === node.id, focused = draggedNodeId === node.id, treeItemClasses = {
    action: clsx("action-container d-flex align-items-center gap-8 px-2", {
      "drag-focus": focused,
      "py-4": !node.section
    }),
    arrow: clsx({
      "py-4": !node.section,
      "py-8": node.section,
      invisible: !Array.isArray(node.children) || node.children.length === 0
    }),
    button: clsx("flex-fill d-flex align-items-center text-truncate gap-8", {
      "py-8": node.section
    })
  }, iconSize = node.section ? 16 : 12, {
    t
  } = useTranslation(), {
    setNodeRef
  } = useDroppable({
    id: useId(),
    data: {
      id: node.id,
      name: node.name,
      isTreeview: !0,
      accepts: ["folder", "resource"]
    }
  }), handleOnItemClick = (nodeId) => handleItemClick == null ? void 0 : handleItemClick(nodeId), handleOnToggleNode = (nodeId) => handleToggleNode == null ? void 0 : handleToggleNode(nodeId), handleOnCreateChildrenPage = (nodeId) => handleItemAction == null ? void 0 : handleItemAction(nodeId), handleItemKeyDown = (event) => {
    (event.code === "Enter" || event.code === "Space") && (event.preventDefault(), event.stopPropagation(), handleItemClick == null || handleItemClick(node.id));
  }, handleItemToggleKeyDown = (event) => {
    (event.code === "Enter" || event.code === "Space") && (event.preventDefault(), event.stopPropagation(), handleToggleNode == null || handleToggleNode(node.id));
  }, renderRafterIcon = (expanded2) => /* @__PURE__ */ jsx(expanded2 ? RafterDown : RafterRight, { title: t("foldUnfold"), width: iconSize, height: iconSize }), shouldRenderRafterIcon = () => {
    var _a;
    const hasNoSiblings = !((_a = siblingsNodes == null ? void 0 : siblingsNodes.current) != null && _a.has(node.id)), hasChildren2 = Array.isArray(node.children) && node.children.length > 0;
    return sibling || hasNoSiblings && hasChildren2;
  };
  return /* @__PURE__ */ jsx("li", { ref: setNodeRef, id: `treeitem-${node.id}`, role: "treeitem", "aria-selected": selected && selected, "aria-expanded": expanded && expanded, children: /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsxs("div", { className: treeItemClasses.action, children: [
      /* @__PURE__ */ jsx("div", { className: treeItemClasses.arrow, tabIndex: 0, role: "button", onClick: () => handleOnToggleNode(node.id), onKeyDown: handleItemToggleKeyDown, "aria-label": t("foldUnfold"), children: shouldRenderRafterIcon() && renderRafterIcon(expanded) }),
      /* @__PURE__ */ jsxs("div", { tabIndex: 0, role: "button", className: treeItemClasses.button, onClick: () => handleOnItemClick(node.id), onKeyDown: handleItemKeyDown, children: [
        node.section && showIcon && /* @__PURE__ */ jsx(Folder, { title: t("folder"), width: 20, height: 20 }),
        /* @__PURE__ */ jsx("span", { className: "text-truncate", children: node.name })
      ] }),
      node.section && handleItemAction && /* @__PURE__ */ jsx("button", { className: "tree-btn mx-8", onClick: () => handleOnCreateChildrenPage(node.id), children: /* @__PURE__ */ jsx(Plus, { height: 16, width: 16 }) })
    ] }),
    Array.isArray(node.children) && !!node.children.length && expanded && /* @__PURE__ */ jsx("ul", { role: "group", children: node.children.map((child) => /* @__PURE__ */ jsx(TreeNode, { node: child, selectedNodeId, expandedNodes, siblingsNodes, draggedNodeId, handleItemClick, handleToggleNode }, child.id)) })
  ] }) }, node.id);
}, useTreeView = ({
  data,
  ref,
  externalSelectedNodeId,
  draggedNode,
  allExpandedNodes,
  onTreeItemUnfold,
  onTreeItemFold,
  onTreeItemClick
}) => {
  const [internalSelectedNodeId, setInternalSelectedNodeId] = useState(void 0), [expandedNodes, setExpandedNodes] = useState(/* @__PURE__ */ new Set()), siblingsNodes = useRef(/* @__PURE__ */ new Set()), [draggedNodeId, setDraggedNodeId] = useState(void 0), selectedNodeId = internalSelectedNodeId ?? externalSelectedNodeId;
  function addNodesWithSiblingHavingChildren(data2) {
    var _a;
    Array.isArray(data2) ? data2.forEach((node) => {
      const resultSet = new Set(siblingsNodes.current);
      data2.filter(({
        id
      }) => id !== node.id).some((sibling) => sibling.children && sibling.children.length > 0) && resultSet.add(node.id), node.children && node.children.length > 0 && node.children.forEach((child) => {
        var _a2;
        const childSiblings = (_a2 = node.children) == null ? void 0 : _a2.filter(({
          id
        }) => id !== child.id);
        (childSiblings == null ? void 0 : childSiblings.some((sibling) => sibling.children && sibling.children.length > 0)) && resultSet.add(child.id), addNodesWithSiblingHavingChildren(child);
      });
    }) : (_a = data2.children) == null || _a.forEach((child) => {
      var _a2;
      const resultSet = new Set(siblingsNodes.current), siblings = (_a2 = data2.children) == null ? void 0 : _a2.filter((c) => c.id !== child.id);
      (siblings == null ? void 0 : siblings.some((sibling) => sibling.children && sibling.children.length > 0)) && (resultSet.add(child.id), siblingsNodes.current = resultSet), addNodesWithSiblingHavingChildren(child);
    });
  }
  const expandedAllNodes = (allExpandedNodes2) => {
    const initExpandedNodes = new Set("");
    data && Array.isArray(data) && allExpandedNodes2 && (data.forEach((node) => {
      initExpandedNodes.add(node.id);
    }), setExpandedNodes(initExpandedNodes));
  };
  useEffect(() => {
    data && addNodesWithSiblingHavingChildren(data);
  }, [data]), useEffect(() => {
    draggedNode != null && draggedNode.isOver && draggedNode.isTreeview ? (draggedNode.overId && handleItemDrag(draggedNode.overId), setDraggedNodeId(draggedNode.overId)) : setDraggedNodeId(void 0);
  }, [draggedNode]);
  const handlers = useMemo(
    () => ({
      unselectAll() {
        setInternalSelectedNodeId(void 0);
      },
      select(nodeId) {
        handleItemClick(nodeId);
      },
      allExpandedNodes() {
        expandedAllNodes(allExpandedNodes);
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  useImperativeHandle(ref, () => handlers, [handlers]), useEffect(() => {
    expandedAllNodes(allExpandedNodes);
  }, []), useEffect(() => {
    externalSelectedNodeId && !allExpandedNodes ? (handleExternalSelectedNodeId(externalSelectedNodeId), setInternalSelectedNodeId(externalSelectedNodeId)) : setInternalSelectedNodeId(void 0);
  }, [externalSelectedNodeId]);
  const handleExternalSelectedNodeId = (nodeId) => {
    if (!findNodeById$1(data, selectedNodeId)) {
      setInternalSelectedNodeId(void 0);
      return;
    }
    if (externalSelectedNodeId === "default") {
      expandedNodes.forEach((node) => onTreeItemUnfold == null ? void 0 : onTreeItemUnfold(node));
      return;
    }
    handleExpandNode(nodeId);
  }, handleExpandNode = (nodeId) => {
    const updatedExpandedNodes = new Set(expandedNodes), parents = findPathById$1(data, nodeId), arrayOrder = Array.from(updatedExpandedNodes);
    parents.forEach((parent) => {
      const index = arrayOrder.indexOf(parent);
      index > -1 && arrayOrder.splice(index, 1), arrayOrder.push(parent);
    }), updatedExpandedNodes.clear(), arrayOrder.forEach((node) => updatedExpandedNodes.add(node)), updatedExpandedNodes.forEach((node) => onTreeItemUnfold == null ? void 0 : onTreeItemUnfold(node)), setExpandedNodes(updatedExpandedNodes);
  }, handleCollapseNode = (nodeId) => {
    const updatedExpandedNodes = new Set(expandedNodes);
    updatedExpandedNodes.delete(nodeId), updatedExpandedNodes.forEach((node) => onTreeItemFold == null ? void 0 : onTreeItemFold(node)), setExpandedNodes(updatedExpandedNodes);
  }, handleToggleNode = (nodeId) => {
    expandedNodes.has(nodeId) ? handleCollapseNode(nodeId) : handleExpandNode(nodeId);
  }, handleSelectedItem = (nodeId) => {
    selectedNodeId !== nodeId && setInternalSelectedNodeId(nodeId);
  }, handleItemClick = (nodeId) => {
    handleSelectedItem(nodeId), handleExpandNode(nodeId), onTreeItemClick == null || onTreeItemClick(nodeId);
  }, handleFoldUnfold = (nodeId) => {
    handleToggleNode(nodeId);
  }, handleItemDrag = (nodeId) => {
    findNodeById$1(data, externalSelectedNodeId) && handleExpandNode(nodeId);
  };
  return {
    selectedNodeId,
    expandedNodes,
    siblingsNodes,
    draggedNodeId,
    handleItemClick,
    handleFoldUnfold
  };
}, TreeView = /* @__PURE__ */ forwardRef((props, ref) => {
  const {
    data,
    onTreeItemClick,
    onTreeItemUnfold,
    onTreeItemFold,
    onTreeItemAction,
    draggedNode,
    showIcon = !0,
    allExpandedNodes = !1,
    selectedNodeId: externalSelectedNodeId
  } = props, {
    selectedNodeId,
    expandedNodes,
    siblingsNodes,
    draggedNodeId,
    handleItemClick,
    handleFoldUnfold
  } = useTreeView({
    data,
    ref,
    externalSelectedNodeId,
    draggedNode,
    allExpandedNodes,
    onTreeItemClick,
    onTreeItemFold,
    onTreeItemUnfold
  });
  return /* @__PURE__ */ jsx("div", { className: "treeview", children: /* @__PURE__ */ jsx("ul", { role: "tree", className: "m-0 p-0", children: Array.isArray(data) ? data.map((node) => /* @__PURE__ */ jsx(TreeNode, { node, showIcon, selectedNodeId, expandedNodes, siblingsNodes, draggedNodeId, handleItemClick, handleToggleNode: handleFoldUnfold, handleItemAction: onTreeItemAction }, node.id)) : /* @__PURE__ */ jsx(TreeNode, { node: data, selectedNodeId, expandedNodes, siblingsNodes, showIcon, draggedNodeId, handleItemClick, handleToggleNode: handleFoldUnfold }) }) });
}), TreeView$1 = TreeView, VisuallyHidden = /* @__PURE__ */ forwardRef(({
  children
}, ref) => /* @__PURE__ */ jsx("span", { className: "visually-hidden", ref, children })), VisuallyHidden$1 = VisuallyHidden;
function useAvatar(userId, userProfile) {
  const {
    t
  } = useTranslation(), badge = useMemo(() => {
    const profile = (userProfile == null ? void 0 : userProfile.toLowerCase()) ?? "guest";
    return ["teacher", "student", "relative", "personnel"].includes(profile) ? /* @__PURE__ */ jsx(Badge, { variant: {
      type: "profile",
      profile
    }, children: t(profile) }) : null;
  }, [userProfile, t]);
  function getAvatarURL(userId2) {
    return odeServices.directory().getAvatarUrl(userId2, "user");
  }
  function getUserbookURL(userId2) {
    return odeServices.directory().getDirectoryUrl(userId2, "user");
  }
  return {
    badge,
    avatarURL: getAvatarURL(userId),
    userbookURL: getUserbookURL(userId)
  };
}
function useBookmark() {
  var _a;
  const {
    sessionQuery
  } = useOdeClient(), set = /* @__PURE__ */ new Set();
  return (_a = sessionQuery == null ? void 0 : sessionQuery.data) == null ? void 0 : _a.bookmarkedApps.filter((el) => {
    const duplicate = set.has(el.displayName);
    return set.add(el.displayName), !duplicate;
  });
}
function useHasWorkflow(workflow) {
  const mock = useMockedData(), [state, setState] = useState();
  return useEffect(() => {
    (async () => {
      let response;
      if (mock != null && mock.hasWorkflow)
        if (typeof workflow == "string")
          response = await mock.hasWorkflow(workflow);
        else
          throw "not.implemented.yet)";
      else
        typeof workflow == "string" ? response = await odeServices.rights().sessionHasWorkflowRight(workflow) : response = await odeServices.rights().sessionHasWorkflowRights(workflow);
      setState(response);
    })();
  }, [workflow, mock]), state;
}
const useConversation = () => {
  const zimbraWorkflow = useHasWorkflow("fr.openent.zimbra.controllers.ZimbraController|view"), zimbraPreauth = useHasWorkflow("fr.openent.zimbra.controllers.ZimbraController|preauth"), [messages, setMessages] = useState(0), [msgLink, setMsgLink] = useState(""), queryParams = {
    unread: !0,
    _: (/* @__PURE__ */ new Date()).getTime()
  }, refreshMails = async () => {
    const url = zimbraWorkflow ? "/zimbra/count/INBOX" : "/conversation/count/INBOX";
    try {
      const {
        count
      } = await odeServices.http().get(url, {
        queryParams
      });
      setMessages(count ?? 0);
    } catch (error) {
      console.error(error), setMessages(0);
    }
  }, goToMessagerie = async () => {
    const defaultLink = "/zimbra/zimbra";
    try {
      const {
        preference
      } = await odeServices.http().get("/userbook/preference/zimbra"), isExpertMode = preference ? JSON.parse(preference).modeExpert : !1;
      setMsgLink(isExpertMode && zimbraPreauth ? "/zimbra/preauth" : window.location.origin + defaultLink);
    } catch (error) {
      console.error(error), setMsgLink(window.location.origin + defaultLink);
    }
  };
  return useEffect(() => {
    refreshMails();
  }, []), useEffect(() => {
    goToMessagerie();
  }, []), {
    messages,
    msgLink,
    zimbraWorkflow
  };
}, useConversation$1 = useConversation;
function useHeader({
  user,
  avatar
}) {
  const {
    appCode
  } = useOdeClient(), {
    t
  } = useTranslation(), {
    theme
  } = useOdeTheme(), title = t(appCode), [isCollapsed, setIsCollapsed] = useState(!0), [appsRef, isAppsHovered] = useHover(), popoverAppsId = useId(), popoverSearchId = useId(), userAvatar = avatar, userName = user == null ? void 0 : user.username, welcomeUser = t("welcome", {
    username: user == null ? void 0 : user.firstName
  }), bookmarkedApps = useBookmark(), communityWorkflow = useHasWorkflow("net.atos.entng.community.controllers.CommunityController|view"), conversationWorflow = useHasWorkflow("org.entcore.conversation.controllers.ConversationController|view"), searchWorkflow = useHasWorkflow("fr.openent.searchengine.controllers.SearchEngineController|view"), toggleCollapsedNav = useCallback(() => {
    setIsCollapsed(!isCollapsed);
  }, [isCollapsed]), handleLogout = async () => {
    await odeServices.session().logout(), window.location.href = (theme == null ? void 0 : theme.logoutCallback) ?? "/auth/login";
  };
  return useMemo(() => ({
    title,
    bookmarkedApps,
    appsRef,
    isAppsHovered,
    popoverAppsId,
    popoverSearchId,
    userAvatar,
    userName,
    welcomeUser,
    communityWorkflow,
    conversationWorflow,
    searchWorkflow,
    isCollapsed,
    toggleCollapsedNav,
    handleLogout
  }), [appsRef, bookmarkedApps, communityWorkflow, conversationWorflow, isAppsHovered, isCollapsed, popoverAppsId, popoverSearchId, searchWorkflow, title, toggleCollapsedNav, userAvatar, userName, welcomeUser]);
}
const useHttpErrorToast = (options) => {
  const message = useRef(), toast2 = useToast(), {
    t
  } = useTranslation();
  return useEffect(() => {
    const subscription = odeServices.notify().events().subscribe(LAYER_NAME.TRANSPORT, (event) => {
      var _a, _b;
      message.current = t(((_b = (_a = event == null ? void 0 : event.data) == null ? void 0 : _a.payload) == null ? void 0 : _b.error) || event.data.response.statusText), toast2.error(/* @__PURE__ */ React.createElement("div", {
        children: [message.current]
      }), options);
    });
    return () => subscription.revoke();
  }, [t, toast2]), message.current;
}, useHttpErrorToast$1 = useHttpErrorToast;
function useIsAdml() {
  const [isAdml, setIsAdml] = useState(!1);
  useEffect(() => {
    initIsAdml();
  }, []);
  const initIsAdml = useCallback(async () => {
    const isAdmlRes = await odeServices.session().isAdml();
    setIsAdml(isAdmlRes);
  }, []);
  return {
    isAdml
  };
}
const useLibraryUrl = () => {
  var _a;
  const {
    user,
    appCode
  } = useOdeClient(), appName = libraryMaps[appCode], libraryApp = user == null ? void 0 : user.apps.find((app) => app.isExternal && app.address.includes("library"));
  if (!libraryApp)
    return null;
  const libraryUrlSplit = (_a = libraryApp.address) == null ? void 0 : _a.split("?");
  if (!libraryUrlSplit || libraryUrlSplit.length < 2)
    return null;
  let libraryHost = libraryUrlSplit[0];
  libraryHost.endsWith("/") || (libraryHost = `${libraryHost}/`);
  const platformURLParam = libraryUrlSplit == null ? void 0 : libraryUrlSplit[1], searchParams = `application%5B0%5D=${appName}&page=1&sort_field=views&sort_order=desc`;
  return `${libraryHost}search/?${platformURLParam}&${searchParams}`;
}, useLibraryUrl$1 = useLibraryUrl, useWorkspaceFile = () => ({
  createOrUpdate: async ({
    alt,
    uri,
    blob,
    legend,
    parentId,
    application,
    visibility
  }) => {
    const regex = /\/workspace\/document\/([0-9a-fA-F-]+)/, matches = (uri ?? "").match(regex);
    if (matches && matches.length === 2) {
      const uuid = matches[1], existingDocuments = await odeServices.workspace().searchDocuments({
        filter: "all",
        id: uuid,
        limit: 1
      }), name = existingDocuments.length ? existingDocuments[0].name : void 0;
      await odeServices.workspace().updateFile(uuid, blob, {
        alt,
        legend,
        name
      });
      const updatedFile = (await odeServices.workspace().searchDocuments({
        filter: "all",
        id: uuid,
        limit: 1
      }))[0];
      return {
        file: updatedFile,
        src: `/workspace/${updatedFile.public ? "pub/" : ""}document/${uuid}`
      };
    } else {
      const res = await odeServices.workspace().saveFile(blob, {
        application,
        parentId,
        visibility
      });
      return `/workspace/${res.public ? "pub/" : ""}document/${res._id}`;
    }
  },
  // get,
  create: async (file, params) => await odeServices.workspace().saveFile(file, params),
  // put,
  remove: async (file) => !file || Array.isArray(file) && file.length === 0 ? Promise.resolve() : await odeServices.workspace().deleteFile(Array.isArray(file) ? file : [file])
}), useWorkspaceFile$1 = useWorkspaceFile, useMediaLibrary = () => {
  const mediaLibraryRef = useRef(null), [libraryMedia, setLibraryMedia] = useState(), {
    remove
  } = useWorkspaceFile$1();
  return {
    ref: mediaLibraryRef,
    libraryMedia,
    setLibraryMedia,
    onCancel: async (uploads) => {
      var _a, _b;
      (_a = mediaLibraryRef.current) != null && _a.type && uploads && uploads.length > 0 && await remove(uploads), (_b = mediaLibraryRef.current) == null || _b.hide();
    },
    onSuccess: (result) => {
      var _a, _b, _c, _d;
      let updatedMedia;
      switch ((_a = mediaLibraryRef.current) == null ? void 0 : _a.type) {
        case "video": {
          if (typeof result == "object")
            updatedMedia = result[0];
          else {
            const element = new DOMParser().parseFromString(result, "text/html").body.firstChild, href = element == null ? void 0 : element.getAttribute("src");
            (_b = mediaLibraryRef.current) == null || _b.hide(), updatedMedia = href;
          }
          break;
        }
        case "embedder": {
          const element = new DOMParser().parseFromString(result, "text/html").body.firstChild, href = element == null ? void 0 : element.getAttribute("src");
          (_c = mediaLibraryRef.current) == null || _c.hide(), updatedMedia = href;
          break;
        }
        case "audio": {
          result.length === void 0 ? updatedMedia = result : updatedMedia = result[0];
          break;
        }
        case "hyperlink": {
          updatedMedia = result;
          break;
        }
        case "image": {
          updatedMedia = `/workspace/document/${result[0]._id}`;
          break;
        }
        default:
          updatedMedia = result[0];
      }
      (_d = mediaLibraryRef.current) == null || _d.hide(), setLibraryMedia(updatedMedia);
    },
    onTabChange: async (_tab, uploads) => {
      var _a;
      (_a = mediaLibraryRef.current) != null && _a.type && uploads && uploads.length > 0 && await remove(uploads);
    }
  };
}, useMediaLibrary$1 = useMediaLibrary, useResourceSearch = (appCode) => {
  const [resourceApplications, setResourceApplications] = useState([]);
  useEffect(() => {
    (async () => (await SnipletsService.initialize(odeServices, appCode), await SnipletsService.registerBehaviours(appCode), setResourceApplications(SnipletsService.resourceProducingApps)))();
  }, []);
  const loadResources = useCallback(async (filters) => {
    const [resourceType] = filters.types;
    return await odeServices.behaviour(appCode, resourceType).loadResources(filters);
  }, [appCode]);
  return {
    resourceApplications,
    loadResources
  };
}, useTrashedResource = (id) => {
  const {
    appCode
  } = useOdeClient(), {
    user
  } = useUser(), [trashed, setTrashed] = useState(!1);
  useEffect(() => {
    (async () => {
      var _a, _b;
      const explorerData = await odeServices.http().get(`/explorer/resources?application=${appCode}&resource_type=${appCode}&asset_id[]=${id}`), resource = (_a = explorerData == null ? void 0 : explorerData.resources) == null ? void 0 : _a.find((resource2) => resource2.assetId === id);
      (resource != null && resource.trashed || (_b = resource == null ? void 0 : resource.trashedBy) != null && _b.includes(user == null ? void 0 : user.userId)) && setTrashed(!0);
    })();
  }, []), useEffect(() => {
    if (trashed)
      throw new Response("", {
        status: 404,
        statusText: "Not Found"
      });
  }, [trashed]);
}, useTrashedResource$1 = useTrashedResource, useUpload = (visibility, application = "media-library") => {
  const [status, setStatus] = useState({}), {
    browser,
    device
  } = useBrowserInfo(navigator.userAgent), {
    create
  } = useWorkspaceFile$1(), getUploadStatus = useCallback((upload) => status[getOrGenerateBlobId(upload)], [status]), setUploadStatus = (blob, status2) => {
    setStatus((prevStatus) => {
      const key = getOrGenerateBlobId(blob);
      return {
        ...prevStatus,
        [key]: status2
      };
    });
  }, clearUploadStatus = (blob) => {
    setStatus((prevStatus) => {
      const key = getOrGenerateBlobId(blob), {
        [key]: unused,
        ...rest
      } = prevStatus;
      return rest;
    });
  };
  async function uploadFile(file, metadata) {
    setUploadStatus(file, "loading");
    try {
      let resource;
      return application === "media-library" && file.type.includes("video") ? resource = await uploadVideo(file, {
        filename: file.name,
        ...metadata
      }) : resource = await create(file, {
        application,
        visibility
      }), setUploadStatus(file, "success"), resource;
    } catch {
      return setUploadStatus(file, "error"), null;
    }
  }
  async function uploadBlob(blob, metadata) {
    setUploadStatus(blob, "loading");
    try {
      let resource;
      if (blob.type.includes("video"))
        resource = await uploadVideo(blob, metadata);
      else
        throw new Error(ERROR_CODE.NOT_SUPPORTED);
      return setUploadStatus(blob, "success"), resource;
    } catch {
      return setUploadStatus(blob, "error"), null;
    }
  }
  const uploadVideo = async (blob, metadata) => {
    const params = {
      data: {
        device: device.type,
        browser: {
          name: browser.name,
          version: browser.version
        },
        url: window.location.hostname,
        file: blob,
        filename: (metadata == null ? void 0 : metadata.filename) ?? "filename",
        weight: blob.size
      },
      appCode: application,
      captation: !(blob instanceof File),
      duration: (metadata == null ? void 0 : metadata.duration) ?? 0
    }, uploadResponse = await odeServices.video().upload(params);
    if (uploadResponse.state === "succeed")
      return {
        _id: uploadResponse.videoworkspaceid,
        file: uploadResponse.videoid,
        name: params.data.filename,
        eType: "file",
        eParent: "",
        children: [],
        created: /* @__PURE__ */ new Date(),
        _shared: [],
        _isShared: !1,
        owner: {
          userId: "",
          displayName: ""
        }
      };
    throw uploadResponse.state === "error" ? new Error(uploadResponse.code || "Error while uploading video") : new Error("Video encoding is still running");
  };
  function uploadAlternateFile(original, replacement, metadata) {
    return getOrGenerateBlobId(replacement, getOrGenerateBlobId(original)), uploadFile(replacement, metadata);
  }
  return {
    getUploadStatus,
    setUploadStatus,
    clearUploadStatus,
    uploadFile,
    uploadAlternateFile,
    uploadBlob
  };
}, useUpload$1 = useUpload, useUploadFiles = ({
  handleOnChange,
  visibility,
  application
}) => {
  const [uploadedFiles, setUploadedFiles] = useState([]), [editingImage, setEditingImage] = useState(void 0), {
    files,
    deleteFile,
    replaceFileAt
  } = useDropzoneContext(), {
    remove,
    createOrUpdate
  } = useWorkspaceFile$1(), {
    getUploadStatus,
    setUploadStatus,
    clearUploadStatus,
    uploadFile,
    uploadAlternateFile
  } = useUpload$1(visibility, application), tryUploading = useCallback((files2) => {
    files2.forEach(async (file, index) => {
      if (file == null)
        return;
      let resource;
      if (file.type.startsWith("image"))
        try {
          const replacement = await ImageResizer.resizeImageFile(file);
          resource = await uploadAlternateFile(file, replacement), replaceFileAt(index, replacement);
        } catch (err) {
          console.error(err);
        }
      resource || (resource = await uploadFile(file)), resource && setUploadedFiles((prevFiles) => [...prevFiles, resource]);
    });
  }, [uploadAlternateFile, uploadFile, replaceFileAt]);
  useEffect(() => {
    let numUploads = 0;
    const newFiles = files.map((file) => {
      if (numUploads >= 5)
        return null;
      const status = getUploadStatus(file);
      return status === "loading" && numUploads++, status ? null : file;
    });
    newFiles.forEach((file) => file && setUploadStatus(file, "idle")), tryUploading(newFiles);
  }, [files, uploadedFiles, getUploadStatus, setUploadStatus, tryUploading]), useEffect(() => {
    const sortedUploadedFiles = sortUploadedFiles(files, uploadedFiles);
    handleOnChange(sortedUploadedFiles);
  }, [uploadedFiles]);
  const sortUploadedFiles = (filesArray, uploadedFilesArray) => {
    const orderMap = filesArray.reduce((acc, item, index) => (acc[item.name] = index, acc), {});
    return uploadedFilesArray.sort((a, b) => orderMap[a.name] - orderMap[b.name]);
  };
  async function removeFile(file) {
    const resource = uploadedFiles.find((uploadedFile) => uploadedFile.name === file.name);
    resource && (await remove(resource), clearUploadStatus(file), setUploadedFiles((prevFiles) => prevFiles.filter((prevFile) => prevFile.name !== (resource == null ? void 0 : resource.name)))), deleteFile(file);
  }
  async function updateImage2({
    blob,
    legend,
    altText: alt
  }) {
    if (editingImage)
      try {
        const res = await createOrUpdate({
          blob,
          legend,
          alt,
          uri: getUrl(editingImage)
        });
        res && typeof res == "object" && setUploadedFiles((prevFiles) => prevFiles.map((prevFile) => prevFile._id === res.file._id ? {
          ...res.file,
          title: legend,
          alt
        } : prevFile));
      } finally {
        setEditingImage(void 0);
      }
  }
  const getUrl = (resource, timestamp) => {
    const url = `/workspace/${resource != null && resource.public ? "pub/" : ""}document/${resource == null ? void 0 : resource._id}`;
    return resource ? timestamp ? addTimestampToImageUrl(url) : url : "";
  };
  return {
    /** List of files added from device */
    files,
    getUploadStatus,
    clearUploadStatus,
    uploadedFiles,
    editingImage,
    setEditingImage,
    getUrl,
    updateImage: updateImage2,
    uploadFile,
    removeFile
  };
}, useUploadFiles$1 = useUploadFiles;
function useUser() {
  const {
    user,
    userDescription
  } = useOdeClient(), {
    theme
  } = useOdeTheme();
  function avatarUrl() {
    let avatar = userDescription == null ? void 0 : userDescription.picture;
    return (!avatar || avatar === "no-avatar.jpg" || avatar === "no-avatar.svg") && (avatar = `${theme == null ? void 0 : theme.basePath}/img/illustrations/no-avatar.svg`), avatar;
  }
  return {
    user,
    avatar: avatarUrl(),
    userDescription
  };
}
function useWorkspaceSearch(rootId, rootName, filter, format) {
  const mock = useMockedData(), canListDocs = useHasWorkflow("org.entcore.workspace.controllers.WorkspaceController|listDocuments"), canListFolders = useHasWorkflow("org.entcore.workspace.controllers.WorkspaceController|listFolders");
  function treeReducer(state, action) {
    switch (action.type) {
      case "update": {
        const node = findNodeById$1(state, action.folderId);
        return node && (node.children = action.subfolders.map((f2) => ({
          id: f2._id || "",
          name: f2.name
        })), node.files = action.files), {
          ...state
        };
      }
      default:
        throw Error("[useWorkspaceSearch] Unknown action type: " + action.type);
    }
  }
  const [root, dispatch] = useReducer(treeReducer, {
    id: rootId,
    name: rootName,
    section: !0
  }), loadContent = useCallback(async (folderId) => {
    var _a;
    if (canListDocs && canListFolders) {
      const realWorkspaceId = folderId === rootId ? "" : folderId, payload = mock != null && mock.listWorkspaceDocuments ? await ((_a = mock == null ? void 0 : mock.listWorkspaceDocuments) == null ? void 0 : _a.call(mock).then((results) => results.map((result) => {
        const ret = {
          ...result,
          _id: "" + Math.round(Math.random() * 9999)
        };
        return ret.name = result.eType == "folder" ? "folder id=" + ret._id : "file id=" + ret._id, ret;
      }))) : await odeServices.workspace().listDocuments(filter, realWorkspaceId), subfolders = [], files = [];
      payload.filter((f2) => {
        if (!format || f2.eType === "folder")
          return !0;
        const role = DocumentHelper.getRole(f2);
        return typeof format == "string" ? format === role : Array.isArray(format) ? format.findIndex((format2) => format2 === role) >= 0 : !1;
      }).forEach((doc) => {
        doc.eType === "folder" ? subfolders.push(doc) : files.push(doc);
      }), dispatch({
        folderId,
        subfolders,
        files,
        type: "update"
      });
    }
  }, [canListDocs, canListFolders, rootId, mock, filter, format]);
  return {
    root,
    loadContent
  };
}
function useXitiTrackPageLoad() {
  const [xitiStatus, setXitiStatus] = useState("pending"), {
    currentApp
  } = useOdeClient();
  useEffect(() => {
    trackPageLoad();
  }, []);
  const trackPageLoad = async () => {
    if (!currentApp) {
      setXitiStatus("[Xiti] Error, currentApp is not defined.");
      return;
    }
    try {
      await odeServices.analytics().trackPageLoad(window.location.pathname, currentApp), console.info(`[Xiti] Success tracking page ${window.location.pathname}`), setXitiStatus(`[Xiti] Success tracking page ${window.location.pathname}`);
    } catch (e2) {
      console.error("[Xiti] Error Tracking Page Load", e2), setXitiStatus(`[Xiti] Error Tracking Page Load: ${e2}`);
    }
  };
  return {
    xitiStatus
  };
}
function useZendeskGuide() {
  const {
    currentLanguage
  } = useOdeClient(), {
    userDescription
  } = useUser(), {
    isAdml
  } = useIsAdml(), {
    theme
  } = useOdeTheme(), isMobileView = window.innerWidth <= 768, hasSupportWorkflow = useHasWorkflow("net.atos.entng.support.controllers.DisplayController|view"), [locationPathname, setLocationPathname] = useState(""), [dataModule, setDataModule] = useState(void 0), setZendeskGuideLabels = () => {
    const modulePathnameSplit = locationPathname.split("/");
    let moduleLabel = "", labels = "";
    if (dataModule != null && dataModule.labels && Object.keys(dataModule == null ? void 0 : dataModule.labels).length > 0 && modulePathnameSplit.length > 1) {
      for (let i = 1; i < modulePathnameSplit.length; i++)
        modulePathnameSplit[i].length > 0 && modulePathnameSplit[i].match(/\d/) == null && (moduleLabel.length === 0 ? moduleLabel = modulePathnameSplit[i] : moduleLabel = moduleLabel + "/" + modulePathnameSplit[i]);
      dataModule != null && dataModule.labels && Object.prototype.hasOwnProperty.call(dataModule == null ? void 0 : dataModule.labels, moduleLabel) ? labels = dataModule == null ? void 0 : dataModule.labels[moduleLabel] : dataModule != null && dataModule.default && String(dataModule.default).length > 0 && (labels = dataModule == null ? void 0 : dataModule.default);
    } else
      dataModule != null && dataModule.default && String(dataModule == null ? void 0 : dataModule.default).length > 0 && (labels = dataModule == null ? void 0 : dataModule.default);
    if (modulePathnameSplit.includes("collaborativewall") && modulePathnameSplit.includes("id") && isMobileView && window.zE("webWidget", "hide"), labels.includes("${adml}") && (isAdml ? labels = labels.replace("${adml}", "adml") : labels = labels.replace("/${adml}", "")), labels.includes("${profile}")) {
      const userProfile = userDescription == null ? void 0 : userDescription.profiles;
      labels = labels.replace("${profile}", userProfile[0].toLowerCase());
    }
    labels.includes("${theme") && (theme != null && theme.is1d ? labels = labels.replace("${theme}", "1D") : labels = labels.replace("${theme}", "2D")), window.zE("webWidget", "helpCenter:setSuggestions", {
      labels: [labels]
    });
  };
  return useEffect(() => {
    window.location.pathname !== locationPathname && setLocationPathname(window.location.pathname), !(dataModule === void 0 || Object.keys(dataModule).length === 0) && setZendeskGuideLabels();
  }, [window.location.pathname, dataModule]), useEffect(() => {
    document.getElementById("ze-snippet") || hasSupportWorkflow === void 0 || (async () => {
      const zendeskGuideConfig = await odeServices.http().get("/zendeskGuide/config");
      if (zendeskGuideConfig && zendeskGuideConfig.key && zendeskGuideConfig.key !== "") {
        const scriptZendesk = document.createElement("script");
        scriptZendesk.id = "ze-snippet", scriptZendesk.src = `https://static.zdassets.com/ekr/snippet.js?key=${zendeskGuideConfig.key}`, document.body.appendChild(scriptZendesk).onload = () => {
          currentLanguage === "es" ? window.zE(function() {
            window.zE.setLocale("es-419");
          }) : window.zE(function() {
            window.zE.setLocale("fr");
          }), Object.keys(zendeskGuideConfig.module).length > 0 && setDataModule(zendeskGuideConfig.module), window.zE("webWidget", "show"), window.zE("webWidget", "updateSettings", {
            webWidget: {
              color: {
                theme: zendeskGuideConfig.color || "#ffc400"
              },
              zIndex: 3,
              launcher: {
                mobile: {
                  labelVisible: !0
                }
              },
              contactForm: {
                suppress: !hasSupportWorkflow
              },
              helpCenter: {
                messageButton: {
                  "*": "Assistance ENT",
                  "es-419": "Asistencia ENT"
                }
              }
            }
          }), window.addEventListener("scroll", () => {
            window.zE("webWidget", "updateSettings", {
              webWidget: {
                launcher: {
                  mobile: {
                    labelVisible: window.scrollY <= 5
                  }
                }
              }
            });
          }), window.zE("webWidget:on", "open", function() {
            hasSupportWorkflow && window.zE("webWidget", "updateSettings", {
              webWidget: {
                contactForm: {
                  suppress: !1
                }
              }
            });
          }), window.zE("webWidget:on", "userEvent", function(ref) {
            const category = ref.category, action = ref.action, properties = ref.properties;
            action === "Contact Form Shown" && category === "Zendesk Web Widget" && properties && properties.name === "contact-form" && hasSupportWorkflow && (window.zE("webWidget", "updateSettings", {
              webWidget: {
                contactForm: {
                  suppress: !0
                }
              }
            }), window.zE("webWidget", "close"), window.open("/support", "_blank"));
          });
        };
      }
    })();
  }, [hasSupportWorkflow]), null;
}
function useCantoo() {
  const hasWorkflow = useHasWorkflow("org.entcore.portal.controllers.PortalController|optionalFeatureCantoo");
  return useEffect(() => {
    hasWorkflow && !document.getElementById("cantoo-edifice-script") && (async () => {
      const cantooResponse = await odeServices.http().get("/optionalFeature/cantoo");
      if (cantooResponse && cantooResponse.scriptPath) {
        const script = document.createElement("script");
        script.id = "cantoo-edifice-script", script.src = cantooResponse.scriptPath, script.async = !0, document.body.appendChild(script);
      }
    })();
  }, [hasWorkflow]), null;
}
function ToastError({
  formData,
  errorMessage
}) {
  const {
    t
  } = useTranslation(), regexInput = (value) => value == null ? void 0 : value.match(/^\s/);
  return errorMessage === "CONTENT_TOO_LARGE" ? /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("h3", { className: "pt-24", children: t("bpr.form.publication.response.error.title") }),
    /* @__PURE__ */ jsx("p", { className: "pt-24 pb-24", children: /* @__PURE__ */ jsx("strong", { children: t("bpr.form.publication.response.error.content_too_large") }) })
  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("h3", { className: "pt-24", children: t("bpr.form.publication.response.error.title") }),
    /* @__PURE__ */ jsx("p", { className: "pt-24 pb-24", children: /* @__PURE__ */ jsx("strong", { children: t("bpr.form.publication.response.error.content") }) }),
    /* @__PURE__ */ jsxs("ul", { children: [
      regexInput(formData == null ? void 0 : formData.title) && /* @__PURE__ */ jsx("li", { className: "pt-2 pb-2", children: /* @__PURE__ */ jsx("strong", { children: t("bpr.form.publication.response.empty.title") }) }),
      regexInput(formData == null ? void 0 : formData.description) && /* @__PURE__ */ jsx("li", { className: "pt-2 pb-2", children: /* @__PURE__ */ jsx("strong", { children: t("bpr.form.publication.response.empty.description") }) })
    ] })
  ] });
}
function ToastSuccess({
  result
}) {
  const {
    t
  } = useTranslation();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("h3", { className: "pt-24", children: t("bpr.form.publication.response.success.title") }),
    /* @__PURE__ */ jsx("p", { className: "pt-24", children: t("bpr.form.publication.response.success.content.1") }),
    /* @__PURE__ */ jsx("p", { className: "pt-24", children: t("bpr.form.publication.response.success.content.2") }),
    result.details.front_url && /* @__PURE__ */ jsx("p", { className: "pt-24 pb-24", children: /* @__PURE__ */ jsx("a", { className: "button right-magnet", href: result.details.front_url, target: "_blank", rel: "noreferrer", children: t("bpr.form.publication.response.success.button") }) })
  ] });
}
function usePublishModal({
  onSuccess,
  resource
}) {
  const {
    user,
    appCode
  } = useOdeClient(), toast2 = useToast(), [cover, setCover] = useState((resource == null ? void 0 : resource.thumbnail) || "");
  useEffect(() => {
    setCover(resource == null ? void 0 : resource.thumbnail);
  }, [resource]);
  const {
    control,
    register,
    watch,
    setValue,
    handleSubmit,
    formState: {
      errors,
      isSubmitting,
      isDirty,
      isValid
    }
  } = useForm({
    mode: "onChange"
  }), [selectedActivities, setSelectedActivities] = useState([]), [selectedSubjectAreas, setSelectedSubjectAreas] = useState([]), selectOption = (value, selectedOptions, setSelectedOptions) => {
    let checked = [...selectedOptions];
    const findIndex = checked.findIndex((item) => item === value);
    selectedOptions.includes(value) ? checked = selectedOptions.filter((_, index) => index !== findIndex) : checked = [...selectedOptions, value], setSelectedOptions(checked);
  };
  return {
    control,
    cover,
    formState: {
      errors,
      isSubmitting,
      isDirty,
      isValid
    },
    handleDeleteImage: () => setCover(""),
    handlePublish: async (formData) => {
      const userId = user ? user == null ? void 0 : user.userId : "";
      try {
        let coverBlob = new Blob();
        typeof cover == "string" ? coverBlob = await odeServices.http().get(cover, {
          responseType: "blob"
        }) : cover ? coverBlob = await odeServices.http().get(URL.createObjectURL(cover), {
          responseType: "blob"
        }) : resource != null && resource.thumbnail && (coverBlob = await odeServices.http().get(resource == null ? void 0 : resource.thumbnail, {
          responseType: "blob"
        }));
        const teacherAvatar = await odeServices.http().get(`/userbook/avatar/${userId}?thumbnail=48x48`, {
          responseType: "blob"
        }), resAttachmentSchool = await odeServices.http().get(`/directory/user/${userId}/attachment-school`, {
          responseType: "json"
        }), application = libraryMaps[appCode], parameters = {
          activityType: selectedActivities,
          age: [formData.ageMin, formData.ageMax],
          application,
          cover: coverBlob,
          description: formData.description,
          keyWords: formData.keyWords,
          language: formData.language,
          licence: "CC-BY",
          resourceId: resource == null ? void 0 : resource.assetId,
          resourceEntId: resource == null ? void 0 : resource.assetId,
          subjectArea: selectedSubjectAreas,
          teacherAvatar,
          title: formData.title,
          userId,
          userStructureName: resAttachmentSchool.name || (user == null ? void 0 : user.structureNames[0])
        }, result = await odeServices.resource(appCode).publish(parameters);
        result.success ? toast2.success(/* @__PURE__ */ jsx(ToastSuccess, { result }), {
          duration: 1e4
        }) : result.message === "CONTENT_TOO_LARGE" ? toast2.error(/* @__PURE__ */ jsx(ToastError, { errorMessage: result.message })) : toast2.error(/* @__PURE__ */ jsx(ToastError, { formData })), onSuccess == null || onSuccess();
      } catch (error) {
        console.error(error), toast2.error(/* @__PURE__ */ jsx(ToastError, { formData }));
      }
    },
    handleSubmit,
    handleUploadImage: (file) => setCover(file),
    register,
    selectActivities: (value) => {
      selectOption(value, selectedActivities, setSelectedActivities);
    },
    selectedActivities,
    selectedSubjectAreas,
    selectSubjects: (value) => {
      selectOption(value, selectedSubjectAreas, setSelectedSubjectAreas);
    },
    setValue,
    watch
  };
}
const useResource = (application, id) => {
  const [resource, setResource] = useState(null);
  return useEffect(() => {
    if (id === "") {
      console.warn("resourceId must be an assetId and not an empty string");
      return;
    }
    (async () => {
      try {
        const response = await odeServices.resource(application).searchResource({
          application,
          id
        });
        setResource(response);
      } catch (error) {
        console.error(error);
      }
    })();
  }, []), resource;
}, useResource$1 = useResource, ImagePickerWorkspace = ({
  addButtonLabel = "Add image",
  deleteButtonLabel = "Delete image",
  src,
  className,
  mediaLibraryRef,
  libraryMedia,
  app,
  onUploadImage,
  onDeleteImage
}) => {
  const [preview, setPreview] = useState(src || "");
  useEffect(() => {
    libraryMedia && (setPreview(libraryMedia), onUploadImage(libraryMedia));
  }, [libraryMedia]);
  const handleClick = () => {
    var _a;
    (_a = mediaLibraryRef.current) == null || _a.show("image");
  }, handleClean = () => {
    setPreview(""), onDeleteImage();
  }, classes = clsx("image-input", className);
  return /* @__PURE__ */ jsxs("div", { id: "image-input", className: classes, children: [
    /* @__PURE__ */ jsxs("div", { className: "image-input-actions gap-8", children: [
      /* @__PURE__ */ jsx(IconButton$1, { "aria-label": addButtonLabel, color: "tertiary", icon: /* @__PURE__ */ jsx(Edit, {}), onClick: handleClick, type: "button", variant: "ghost" }),
      /* @__PURE__ */ jsx(IconButton$1, { "aria-label": deleteButtonLabel, color: "danger", disabled: !preview, icon: /* @__PURE__ */ jsx(Delete, { width: "20", height: "20" }), onClick: handleClean, type: "button", variant: "ghost" })
    ] }),
    preview ? /* @__PURE__ */ jsx(Avatar, { alt: "", src: preview, size: "xl" }) : /* @__PURE__ */ jsx(AppIcon$1, { app, iconFit: "ratio", size: "160", variant: "rounded" })
  ] });
}, ImagePickerWorkspace$1 = ImagePickerWorkspace, AudioRecorderTimer = ({
  recordState,
  playState,
  recordTime,
  audioTime,
  maxDuration
}) => /* @__PURE__ */ jsxs("div", { className: "audio-recorder-time my-16 mx-auto", children: [
  playState === "IDLE" && /* @__PURE__ */ jsxs("div", { className: "d-flex align-items-center", children: [
    recordState === "PAUSED" ? /* @__PURE__ */ jsx(Pause, { width: 12, height: 12, className: "me-8 text-danger" }) : /* @__PURE__ */ jsx(Record, { width: 12, height: 12, className: "me-8 text-danger" }),
    convertMsToMS(recordState !== "IDLE" ? recordTime : 0) + " / " + convertMsToMS(maxDuration)
  ] }),
  playState !== "IDLE" && /* @__PURE__ */ jsxs("div", { className: "d-flex align-items-center mx-auto", children: [
    /* @__PURE__ */ jsx(Mic, { width: 12, height: 12, className: "me-8" }),
    convertMsToMS(audioTime * 1e3),
    " /",
    convertMsToMS(recordTime)
  ] })
] }), AudioRecorderTimer$1 = AudioRecorderTimer;
function useAudioRecorder(onSaveSuccess, onUpdateRecord, hideSaveAction = !1, visibility = "protected", application = "media-library") {
  var _a;
  function audioReducer(state, action) {
    return {
      ...state,
      ...action.updatedState
    };
  }
  const [{
    recordState,
    playState,
    micStream,
    micStreamAudioSourceNode,
    audioWorkletNode,
    audioContext,
    encoderWorker,
    maxDuration,
    recordTime,
    isEncoding
  }, dispatch] = useReducer(audioReducer, {
    recordState: "IDLE",
    isEncoding: !1,
    playState: "IDLE",
    recordTime: 0,
    maxDuration: 180
    // max duration in s (3 minutes by default)
  }), audioNameRef = useRef(null), audioRef = useRef(null), leftChannelRef = useRef(), rightChannelRef = useRef(), {
    t
  } = useTranslation(), {
    create
  } = useWorkspaceFile$1(), BUFFER_SIZE = 128, DEFAULT_SAMPLE_RATE = 48e3;
  useEffect(() => {
    const encoderWorker2 = new Worker("/infra/public/js/audioEncoder.js");
    return dispatch({
      type: "update",
      updatedState: {
        encoderWorker: encoderWorker2
      }
    }), encoderWorker2.postMessage(["init", (audioContext == null ? void 0 : audioContext.sampleRate) || DEFAULT_SAMPLE_RATE]), () => {
      closeAudioStream(), encoderWorker2.terminate();
    };
  }, []);
  const handleAudioWorkletNodeMessage = (event) => {
    var _a2, _b;
    const leftChannel = event.data.inputs[0][0];
    let rightChannel = event.data.inputs[0][1];
    (!rightChannel || rightChannel.filter((data) => data !== void 0).length === 0) && (rightChannel = leftChannel), (_a2 = leftChannelRef.current) == null || _a2.push(leftChannel), (_b = rightChannelRef.current) == null || _b.push(rightChannel);
  }, closeAudioStream = useCallback(() => {
    micStream == null || micStream.getTracks().forEach((track) => track.stop()), micStreamAudioSourceNode == null || micStreamAudioSourceNode.disconnect(), audioWorkletNode == null || audioWorkletNode.port.removeEventListener("message", handleAudioWorkletNodeMessage), audioWorkletNode == null || audioWorkletNode.port.close(), audioWorkletNode == null || audioWorkletNode.disconnect(), audioContext == null || audioContext.close();
  }, [audioContext, audioWorkletNode, micStream, micStreamAudioSourceNode]), initRecording = async () => {
    const micStream2 = await navigator.mediaDevices.getUserMedia({
      audio: !0
    }), audioContext2 = new AudioContext({
      sampleRate: DEFAULT_SAMPLE_RATE
    }), micStreamAudioSourceNode2 = audioContext2.createMediaStreamSource(micStream2);
    try {
      await audioContext2.audioWorklet.addModule("/infra/public/js/audio-recorder-processor.js");
    } catch (err) {
      console.error(err);
    }
    const audioWorkletNode2 = new AudioWorkletNode(audioContext2, "audio-recorder-processor");
    audioWorkletNode2.port.addEventListener("message", handleAudioWorkletNodeMessage), dispatch({
      type: "update",
      updatedState: {
        micStream: micStream2,
        micStreamAudioSourceNode: micStreamAudioSourceNode2,
        audioContext: audioContext2,
        recordTime: 0,
        audioWorkletNode: audioWorkletNode2,
        recordState: "RECORDING",
        playState: "IDLE"
      }
    }), rightChannelRef.current = [], leftChannelRef.current = [], audioWorkletNode2.port.start(), micStreamAudioSourceNode2.connect(audioWorkletNode2), audioWorkletNode2.connect(audioContext2.destination);
  }, handleRecord = useCallback(async () => {
    audioRef.current && (audioRef.current.currentTime = 0, audioRef.current.pause()), recordState === "PAUSED" ? (dispatch({
      type: "update",
      updatedState: {
        recordState: "RECORDING",
        playState: "IDLE"
      }
    }), audioContext == null || audioContext.resume(), onUpdateRecord == null || onUpdateRecord(void 0)) : initRecording();
  }, [recordState, audioContext, audioRef]), handleRecordPause = useCallback(() => {
    dispatch({
      type: "update",
      updatedState: {
        recordState: "PAUSED",
        playState: "IDLE",
        isEncoding: !0
      }
    }), audioContext == null || audioContext.suspend(), encoderWorker && leftChannelRef.current && rightChannelRef.current && (encoderWorker.postMessage(["wav", rightChannelRef.current, leftChannelRef.current, rightChannelRef.current.length * BUFFER_SIZE]), encoderWorker.onmessage = (event) => {
      const audioUrl = window.URL.createObjectURL(event.data);
      dispatch({
        type: "update",
        updatedState: {
          isEncoding: !1
        }
      }), audioRef.current && (audioRef.current.src = audioUrl), onUpdateRecord && onUpdateRecord(audioUrl);
    });
  }, [audioContext, encoderWorker, onUpdateRecord]), handlePlay = useCallback(() => {
    var _a2;
    dispatch({
      type: "update",
      updatedState: {
        playState: "PLAYING"
      }
    }), ((_a2 = audioRef == null ? void 0 : audioRef.current) != null && _a2.currentTime || audioRef.current) && audioRef.current.play();
  }, [audioRef]), handlePlayPause = useCallback(() => {
    var _a2;
    (_a2 = audioRef == null ? void 0 : audioRef.current) == null || _a2.pause(), dispatch({
      type: "update",
      updatedState: {
        playState: "PAUSED"
      }
    });
  }, [audioRef]), handleReset = useCallback(() => {
    closeAudioStream(), dispatch({
      type: "update",
      updatedState: {
        playState: "IDLE",
        recordState: "IDLE"
      }
    }), rightChannelRef.current = [], leftChannelRef.current = [], onUpdateRecord && onUpdateRecord(void 0);
  }, [closeAudioStream, onUpdateRecord]), handleSave = useCallback(async () => {
    var _a2;
    const audioName = (_a2 = audioNameRef.current) == null ? void 0 : _a2.value;
    if (!audioName) {
      console.error("Audio name is required");
      return;
    }
    return audioRef.current && (audioRef.current.pause(), audioRef.current.currentTime = 0), dispatch({
      type: "update",
      updatedState: {
        recordState: "SAVING",
        playState: "IDLE"
      }
    }), new Promise((resolve, reject) => {
      try {
        encoderWorker && leftChannelRef.current && rightChannelRef.current && (encoderWorker.postMessage(["mp3", rightChannelRef.current, leftChannelRef.current, rightChannelRef.current.length * BUFFER_SIZE]), encoderWorker.onmessage = async (event) => {
          if (event.data instanceof Blob) {
            const file = new File([event.data], audioName, {
              type: "audio/mp3"
            }), resourceAudio = await create(file, {
              application,
              visibility
            });
            resourceAudio && onSaveSuccess && onSaveSuccess(resourceAudio), dispatch({
              type: "update",
              updatedState: {
                recordState: "SAVED"
              }
            }), resolve(resourceAudio);
          }
        });
      } catch (error) {
        dispatch({
          type: "update",
          updatedState: {
            playState: "IDLE",
            recordState: "IDLE"
          }
        }), console.error("Error while saving", error), reject();
      }
    });
  }, [recordState, onSaveSuccess, closeAudioStream]), handlePlayStop = useCallback(() => {
    audioRef != null && audioRef.current && (audioRef.current.pause(), audioRef.current.currentTime = 0), dispatch({
      type: "update",
      updatedState: {
        playState: "IDLE"
      }
    });
  }, [audioRef]), handlePlayEnded = useCallback(() => {
    dispatch({
      type: "update",
      updatedState: {
        playState: "PAUSED"
      }
    }), audioRef.current && (audioRef.current.currentTime = 0);
  }, [audioRef]);
  useEffect(() => {
    if (recordState === "RECORDING" && audioContext) {
      const timer = window.setInterval(
        // Compute exact elapsed time by diffing the start time.
        () => {
          dispatch({
            type: "update",
            updatedState: {
              recordTime: audioContext.currentTime
            }
          }), audioContext.currentTime >= maxDuration && (handleRecordPause(), window.clearInterval(timer));
        },
        100
      );
      return () => window.clearInterval(timer);
    }
  }, [audioContext, handleRecordPause, maxDuration, recordState]);
  const recordText = t(recordState === "IDLE" ? "bbm.audio.record.start" : "bbm.audio.record.resume"), toolbarItems = [{
    type: "icon",
    name: "record",
    visibility: recordState === "RECORDING" ? "hide" : "show",
    props: {
      icon: /* @__PURE__ */ jsx(Record, {}),
      color: "danger",
      disabled: recordState !== "IDLE" && recordState !== "PAUSED" || recordTime >= maxDuration,
      onClick: handleRecord,
      "aria-label": recordText
    },
    tooltip: recordText
  }, {
    type: "icon",
    name: "recordPause",
    visibility: recordState === "RECORDING" ? "show" : "hide",
    props: {
      icon: /* @__PURE__ */ jsx(RecordPause, {}),
      color: "danger",
      disabled: recordState !== "RECORDING",
      onClick: handleRecordPause,
      "aria-label": t("bbm.audio.record.pause")
    },
    tooltip: t("bbm.audio.record.pause")
  }, {
    type: "divider"
  }, {
    type: "icon",
    name: "encoding",
    visibility: isEncoding ? "show" : "hide",
    props: {
      icon: /* @__PURE__ */ jsx(Loader, { style: {
        animation: "loading 1s infinite"
      } }),
      disabled: !0
    }
  }, {
    type: "icon",
    name: "play",
    visibility: isEncoding || playState === "PLAYING" ? "hide" : "show",
    props: {
      icon: /* @__PURE__ */ jsx(PlayFilled, {}),
      disabled: recordState !== "RECORDED" && recordState !== "PAUSED" && recordState !== "SAVED",
      onClick: handlePlay,
      "aria-label": t("bbm.audio.play.start")
    },
    tooltip: t("bbm.audio.play.start")
  }, {
    type: "icon",
    name: "playPause",
    visibility: !isEncoding && playState === "PLAYING" ? "show" : "hide",
    props: {
      icon: /* @__PURE__ */ jsx(Pause, {}),
      onClick: handlePlayPause,
      "aria-label": t("bbm.audio.play.pause")
    },
    tooltip: t("bbm.audio.play.pause")
  }, {
    type: "icon",
    name: "stop",
    props: {
      icon: /* @__PURE__ */ jsx(Restart, {}),
      disabled: playState !== "PLAYING" && playState !== "PAUSED",
      onClick: handlePlayStop,
      "aria-label": t("bbm.audio.play.stop")
    },
    tooltip: t("bbm.audio.play.stop")
  }, {
    type: "divider"
  }, {
    type: "icon",
    name: "reset",
    props: {
      icon: /* @__PURE__ */ jsx(Refresh, {}),
      disabled: recordState !== "RECORDED" && recordState !== "PAUSED" && playState !== "PLAYING" && playState !== "PAUSED",
      onClick: handleReset,
      "aria-label": t("bbm.audio.record.reset")
    },
    tooltip: t("bbm.audio.record.reset")
  }, {
    type: "icon",
    name: "save",
    visibility: hideSaveAction ? "hide" : "show",
    props: {
      icon: /* @__PURE__ */ jsx(Save, {}),
      disabled: recordState !== "RECORDED" && recordState !== "PAUSED" && playState !== "PLAYING" && playState !== "PAUSED" || recordState === "SAVED" || !((_a = audioNameRef.current) != null && _a.value),
      onClick: handleSave,
      "aria-label": t("bbm.audio.record.save")
    },
    tooltip: t("bbm.audio.record.save")
  }];
  return {
    recordState,
    playState,
    audioContext,
    recordTime: recordTime * 1e3,
    maxDuration: maxDuration * 1e3,
    audioRef,
    audioNameRef,
    toolbarItems,
    handlePlayEnded,
    handleSave
  };
}
const AudioRecorder = /* @__PURE__ */ forwardRef(({
  onSaveSuccess,
  onRecordUpdated,
  hideSaveAction = !1,
  visibility = "protected"
}, ref) => {
  const {
    recordState,
    playState,
    recordTime,
    audioRef,
    audioNameRef,
    toolbarItems,
    maxDuration,
    handlePlayEnded,
    handleSave
  } = useAudioRecorder(onSaveSuccess, onRecordUpdated, hideSaveAction, visibility, "media-library"), {
    t
  } = useTranslation();
  useImperativeHandle(ref, () => ({
    save: handleSave
  }));
  const [audioTime, setAudioTime] = useState(0), classColor = clsx({
    "text-danger": recordState === "RECORDING",
    "text-success": playState === "PLAYING"
  }), handleTimeUpdate = (event) => {
    setAudioTime(event.target.currentTime);
  };
  return /* @__PURE__ */ jsxs("div", { className: "audio-recorder m-auto d-flex flex-column", children: [
    /* @__PURE__ */ jsx(FormControl$1, { id: "recordName", className: "mb-32", isRequired: !0, isReadOnly: recordState === "SAVED" || recordState === "SAVING", children: /* @__PURE__ */ jsx(Input$1, { type: "text", size: "sm", placeholder: t("bbm.audio.recorder.name"), ref: audioNameRef, defaultValue: t("bbm.audio.recorder.defaultName") + (/* @__PURE__ */ new Date()).toLocaleDateString() }) }),
    /* @__PURE__ */ jsx("div", { className: "audio-recorder-icon mx-auto", children: /* @__PURE__ */ jsx(Mic, { width: 64, height: 64, className: classColor }) }),
    /* @__PURE__ */ jsx(AudioRecorderTimer$1, { recordState, playState, recordTime, audioTime, maxDuration }),
    /* @__PURE__ */ jsx("audio", { ref: audioRef, onEnded: handlePlayEnded, onTimeUpdate: handleTimeUpdate, children: /* @__PURE__ */ jsx("track", { default: !0, kind: "captions", srcLang: "fr", src: "" }) }),
    /* @__PURE__ */ jsx(Toolbar, { items: toolbarItems })
  ] });
}), AudioRecorder$1 = AudioRecorder, Embed = ({
  onSuccess
}) => {
  const {
    t
  } = useTranslation(), [htmlContent, setHTMLContent] = useState();
  function handleContentChange(event) {
    const HTMLContent = event.target.value;
    setHTMLContent(HTMLContent), HTMLContent != null && HTMLContent.length ? onSuccess(HTMLContent) : onSuccess();
  }
  return /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column flex-fill", children: [
    /* @__PURE__ */ jsx("div", { className: "mb-32", children: t("bbm.embed.description") }),
    /* @__PURE__ */ jsxs("div", { className: "mb-8 d-flex", children: [
      /* @__PURE__ */ jsx(Code, { className: "me-8" }),
      t("bbm.embed.title")
    ] }),
    /* @__PURE__ */ jsx(FormControl$1, { id: "iframeContent", children: /* @__PURE__ */ jsx(TextArea$1, { size: "md", height: "sm", placeholder: t("bbm.embed.placeholder"), onChange: handleContentChange }) }),
    !!(htmlContent != null && htmlContent.length) && /* @__PURE__ */ jsx("div", { className: "embed-preview mt-12", dangerouslySetInnerHTML: {
      __html: htmlContent
    } }),
    !(htmlContent != null && htmlContent.length) && /* @__PURE__ */ jsx("div", { className: "embed-preview mt-12 d-flex align-items-center justify-content-center bg-gray-300 text-black-50 rounded-3", children: /* @__PURE__ */ jsx("strong", { children: t("bbm.embed.preview") }) })
  ] });
}, Embed$1 = Embed, ImageEditorToolbar = ({
  historyCount,
  handle
}) => {
  const {
    t
  } = useTranslation(), [action, setAction] = useState(void 0), handleAndSave = (action2) => {
    setAction(action2), handle(action2);
  }, ImageEditorItems = [{
    type: "button",
    name: "undo",
    props: {
      color: "tertiary",
      leftIcon: /* @__PURE__ */ jsx(Undo, {}),
      "aria-label": t("cancel"),
      children: t("cancel"),
      onClick: () => handleAndSave("UNDO"),
      disabled: historyCount === 0
    },
    tooltip: t("cancel")
  }, {
    type: "divider",
    name: "div-1"
  }, {
    type: "button",
    name: "reset",
    props: {
      color: "tertiary",
      leftIcon: /* @__PURE__ */ jsx(Reset, {}),
      "aria-label": t("rotate"),
      children: t("rotate"),
      onClick: () => handleAndSave("ROTATE")
    },
    tooltip: t("rotate")
  }, {
    type: "button",
    name: "crop",
    props: {
      color: "tertiary",
      leftIcon: /* @__PURE__ */ jsx(Crop, {}),
      "aria-label": t("crop"),
      children: t("crop"),
      className: action === "CROP" ? "is-selected" : "",
      onClick: () => handleAndSave("CROP")
    },
    tooltip: t("crop")
  }, {
    type: "button",
    name: "blur",
    props: {
      color: "tertiary",
      leftIcon: /* @__PURE__ */ jsx(Blur, {}),
      "aria-label": t("blur"),
      children: t("blur"),
      className: action === "BLUR" ? "is-selected" : "",
      onClick: () => handleAndSave("BLUR")
    },
    tooltip: t("blur")
  }];
  return /* @__PURE__ */ jsx(Toolbar, { variant: "no-shadow", align: "left", isBlock: !0, items: ImageEditorItems });
}, ImageEditorToolbar$1 = ImageEditorToolbar, MIN_HEIGHT = 100, MIN_WIDTH = 100, MODAL_VERTICAL_PADDING = 450, MODAL_HORIZONTAL_PADDING = 64, DEFAULT_QUALITY = 0.5, DEFAULT_SPRITE_NAME = "image";
function updateImageFromBlob(application, {
  spriteName,
  imgDatasource,
  settings
}) {
  const imageUrl = URL.createObjectURL(imgDatasource), image = new Image();
  return image.src = imageUrl, new Promise((resolve) => {
    image.onload = async () => {
      await updateImage(application, {
        spriteName,
        imgDatasource: image,
        settings
      });
      const newSprite = application == null ? void 0 : application.stage.getChildByName(spriteName, !0);
      resolve(newSprite);
    };
  });
}
async function updateImage(application, {
  spriteName,
  imgDatasource,
  settings
}) {
  if (application === void 0 || application.stage === null)
    return;
  const previous = application.stage.getChildByName(spriteName, !0);
  previous == null || previous.removeFromParent();
  const texture = imgDatasource instanceof HTMLImageElement ? PIXI.Texture.from(imgDatasource) : imgDatasource instanceof PIXI.Sprite ? imgDatasource : await PIXI.Texture.fromURL(imgDatasource), sprite = texture instanceof PIXI.Sprite ? texture : PIXI.Sprite.from(texture, {});
  if (sprite.interactive = !0, sprite.name = spriteName, settings) {
    const {
      sprite: {
        anchor,
        position,
        scale,
        size: spriteSize,
        rotation
      },
      stage: {
        size: stageSize
      }
    } = settings, isRotated = rotation % Math.PI !== 0;
    sprite.anchor.x = anchor.x, sprite.anchor.y = anchor.y, sprite.position.x = position.x, sprite.position.y = position.y, sprite.scale.x = scale.x, sprite.scale.y = scale.y, sprite.width = isRotated ? spriteSize.height : spriteSize.width, sprite.height = isRotated ? spriteSize.width : spriteSize.height, application.stage.height = stageSize.height, application.stage.width = stageSize.width, application.renderer.resize(stageSize.width, stageSize.height), application.stage.addChild(sprite);
  } else
    application.stage.addChild(sprite), application.renderer.resize(sprite.width, sprite.height);
  autoResize(application, sprite);
}
function autoResize(application, sprite) {
  var _a;
  const parent = application.view.parentNode, maxMobileWidth = window.innerWidth - MODAL_HORIZONTAL_PADDING, parentWidth = Math.max((parent == null ? void 0 : parent.offsetWidth) ?? 0, MIN_WIDTH), newSize = constraintSize({
    width: sprite.width,
    height: sprite.height
  }, {
    width: {
      max: Math.min(parentWidth, maxMobileWidth),
      min: MIN_WIDTH
    },
    height: {
      min: MIN_HEIGHT,
      max: window.innerHeight - MODAL_VERTICAL_PADDING
    }
  }), {
    height: newHeight,
    width: newWidth
  } = newSize;
  (_a = application.view) != null && _a.style && (application.view.style.width = `${newWidth}px`, application.view.style.height = `${newHeight}px`);
}
function constraintSize(size2, constraints) {
  const {
    height,
    width
  } = size2, ratio = width / height, {
    height: constraintHeight,
    width: constraintWidth
  } = constraints;
  let newWidth = constraintWidth.max, newHeight = constraintWidth.max / ratio;
  return width > constraintWidth.max && (newWidth = constraintWidth.max, newHeight = newWidth / ratio), newHeight > constraintHeight.max && (newHeight = constraintHeight.max, newWidth = newHeight * ratio), newWidth < constraintWidth.min && (newWidth = constraintWidth.min, newHeight = newWidth / ratio), newHeight < constraintHeight.min && (newHeight = constraintHeight.min, newWidth = newHeight * ratio), {
    width: newWidth,
    height: newHeight
  };
}
function saveAsBlob(application) {
  return new Promise((resolve, reject) => {
    var _a;
    (_a = application == null ? void 0 : application.view) != null && _a.toBlob ? application.view.toBlob((blob) => {
      blob ? resolve(blob) : reject("EXTRACT_FAILED");
    }, "image/jpeg", DEFAULT_QUALITY) : reject("EXTRACT_FAILED");
  });
}
function saveAsDataURL(application) {
  var _a, _b;
  return (_b = (_a = application.view).toDataURL) == null ? void 0 : _b.call(_a);
}
function getApplicationScale(application) {
  return application.view.getBoundingClientRect ? application.view.getBoundingClientRect().width / application.view.width : 1;
}
function toBlob(application) {
  return new Promise((resolve, reject) => {
    var _a, _b;
    (_b = (_a = application.view).toBlob) == null || _b.call(_a, (blob) => {
      blob ? resolve(blob) : reject("EXTRACT_FAIL");
    }, "image/png", 1);
  });
}
function createImageSettings({
  application,
  sprite
}) {
  return {
    sprite: {
      rotation: sprite.rotation,
      size: {
        width: sprite.width,
        height: sprite.height
      },
      position: {
        x: sprite.position.x,
        y: sprite.position.y
      },
      scale: {
        x: sprite.scale.x,
        y: sprite.scale.y
      },
      anchor: {
        x: sprite.anchor.x,
        y: sprite.anchor.y
      }
    },
    stage: {
      size: {
        width: application.stage.width,
        height: application.stage.height
      },
      scale: {
        x: application.stage.scale.x,
        y: application.stage.scale.y
      }
    }
  };
}
function resizeStage({
  application,
  sprite,
  newHeight,
  newWidth
}) {
  sprite.anchor.x = 0.5, sprite.anchor.y = 0.5, sprite.position = new PIXI.Point(newWidth / 2, newHeight / 2), application.stage.height = newHeight, application.stage.width = newWidth, application.renderer.resize(newWidth, newHeight);
}
const DEFAULT_MAX_HISTORY = 20, useHistoryTool = ({
  maxSize = DEFAULT_MAX_HISTORY,
  application,
  spriteName,
  onRestore
}) => {
  const [history, setHistory] = useState([]);
  useEffect(() => {
    setHistory([]);
  }, [application]);
  const restore = async () => {
    const imgData = history.pop();
    imgData && (onRestore(await imgData.backup, imgData), setHistory(history.filter((current) => current !== imgData)));
  }, listSize = (arr) => (arr.length > maxSize && arr.splice(0, arr.length - maxSize), arr), historize = async (callback) => {
    {
      if (!application)
        return;
      const sprite = application.stage.getChildByName(spriteName, !0);
      if (sprite == null)
        return;
      const promise = toBlob(application), state = {
        backup: promise,
        sprite: {
          rotation: sprite.rotation,
          size: {
            width: sprite.width,
            height: sprite.height
          },
          position: {
            x: sprite.position.x,
            y: sprite.position.y
          },
          scale: {
            x: sprite.scale.x,
            y: sprite.scale.y
          },
          anchor: {
            x: sprite.anchor.x,
            y: sprite.anchor.y
          }
        },
        stage: {
          size: {
            width: application.stage.width,
            height: application.stage.height
          },
          scale: {
            x: application.stage.scale.x,
            y: application.stage.scale.y
          }
        }
      };
      return setHistory([...listSize(history), state]), await promise, callback.call(callback);
    }
  };
  return {
    historyCount: history.length,
    restore,
    historize
  };
}, useHistoryTool$1 = useHistoryTool;
function aggregate(delay, map, callback) {
  let timerId;
  const pending = [];
  return function(arg) {
    pending.push(map(arg)), !timerId && (timerId = setTimeout(() => {
      const copy = [...pending];
      pending.splice(0, pending.length), callback(copy), timerId = void 0;
    }, delay));
  };
}
const BRUSH_SIZE = 20, DEBOUNCE = 50, CURSOR_NAME = "BRUSH_CURSOR";
function drawBrush(points, scale) {
  const container = new PIXI.Graphics();
  for (const point of points)
    point && (container.beginFill(16777215, 1), container.drawCircle(point.x, point.y, BRUSH_SIZE / scale), container.lineStyle(0), container.endFill());
  return container;
}
function drawBlurListener(application, {
  spriteName
}) {
  return aggregate(DEBOUNCE, (event) => application.stage.toLocal(event.global), (points) => {
    const child = application.stage.getChildByName(spriteName), scale = getApplicationScale(application);
    if (child == null)
      return;
    const newSprite = new PIXI.Sprite(child.texture);
    newSprite.filters = [
      new PIXI.BlurFilter(
        8,
        // PIXI Default value for strength of the blur effect
        4,
        // Quality of the blur effect depending on the scale (4 is the PIXI default value)
        Math.min(scale, 1)
      )
      // Resolution of the blur effect depending on the scale
    ], newSprite.width = child.width, newSprite.height = child.height, newSprite.scale = new PIXI.Point(1, 1), newSprite.anchor = child.anchor, newSprite.mask = drawBrush(points, scale), child.addChild(newSprite);
  });
}
function drawCursor(application) {
  removeCursor(application);
  const scale = getApplicationScale(application), circle = new PIXI.Graphics();
  return circle.lineStyle(Math.max(1, 1 / scale), 16711680), circle.drawCircle(0, 0, BRUSH_SIZE / scale), circle.endFill(), circle.name = CURSOR_NAME, application.stage.addChild(circle), circle;
}
function removeCursor(application) {
  const child = application.stage.getChildByName(CURSOR_NAME);
  child && child.removeFromParent();
}
function moveCursorListener(application) {
  return (event) => {
    if (!application)
      return;
    const point = application.stage.toLocal(event.global), child = application.stage.getChildByName(CURSOR_NAME, !0);
    child && (child.position.x = point.x, child.position.y = point.y);
  };
}
function start$2(application, {
  spriteName
}) {
  application.stage.interactive = !0;
  const cursor = drawCursor(application), cursorListener = moveCursorListener(application);
  application.stage.on("pointermove", cursorListener);
  const blurListener = drawBlurListener(application, {
    spriteName
  });
  application.stage.on("pointerdown", () => {
    application.stage.on("pointermove", blurListener);
  });
  const stopListening = () => {
    var _a;
    (_a = application == null ? void 0 : application.stage) == null || _a.off("pointermove", blurListener);
  };
  globalThis.addEventListener("pointerup", stopListening), cursor.once("destroyed", () => {
    globalThis.removeEventListener("pointerup", stopListening);
  });
}
function stop$2(application) {
  removeCursor(application), application.stage.off("pointerdown"), application.stage.off("pointermove");
}
const CORNERS = ["TOP_LEFT", "TOP_RIGHT", "BOTTOM_LEFT", "BOTTOM_RIGHT"], PADDING = 0, POINT_RADIUS$1 = 20, CROP_BACKGROUND_NAME = "CROP_BACKGROUND_NAME", CROP_MASK_NAME = "CROP_MASK_NAME";
function getCornerName$1(corner) {
  return "CROP_CORNER_" + corner;
}
function drawBackground(application, {
  spriteName
}) {
  removeBackground(application);
  const sprite = application.stage.getChildByName(spriteName);
  if (sprite == null)
    return;
  const spriteBounds = sprite.getBounds(), stageTexture = application.renderer.generateTexture(application.stage).clone(), clonedStage = new PIXI.Sprite(stageTexture);
  clonedStage.height = spriteBounds.height, clonedStage.width = spriteBounds.width, clonedStage.position = new PIXI.Point(0, 0);
  const background = new PIXI.Graphics();
  background.beginFill(16777215, 0.5), background.drawRect(0, 0, spriteBounds.width, spriteBounds.height), background.endFill(), background.name = CROP_BACKGROUND_NAME, background.position = new PIXI.Point(spriteBounds.x, spriteBounds.y);
  const rectMask = new PIXI.Graphics();
  rectMask.beginFill(0, 1), rectMask.drawRect(0, 0, spriteBounds.width - 2 * PADDING, spriteBounds.height - 2 * PADDING), rectMask.endFill(), rectMask.position = new PIXI.Point(PADDING, PADDING), rectMask.name = CROP_MASK_NAME, clonedStage.mask = rectMask, application.stage.addChild(background), background.addChild(rectMask), background.addChild(clonedStage);
}
function removeBackground(application) {
  const child = application.stage.getChildByName(CROP_BACKGROUND_NAME, !0);
  child == null || child.removeFromParent();
}
function computeCornerPosition$1(cornerType, bounds) {
  switch (cornerType) {
    case "TOP_LEFT":
      return {
        x: bounds.x,
        y: bounds.y,
        start: 0,
        end: Math.PI / 2
      };
    case "TOP_RIGHT":
      return {
        x: bounds.x + bounds.width,
        y: bounds.y,
        start: Math.PI / 2,
        end: Math.PI
      };
    case "BOTTOM_LEFT":
      return {
        x: bounds.x,
        y: bounds.y + bounds.height,
        start: 3 * Math.PI / 2,
        end: 2 * Math.PI
      };
    case "BOTTOM_RIGHT":
      return {
        x: bounds.x + bounds.width,
        y: bounds.y + bounds.height,
        start: Math.PI,
        end: 3 * Math.PI / 2
      };
  }
}
function refreshCorners(application) {
  const mask = application.stage.getChildByName(CROP_MASK_NAME, !0);
  mask != null && CORNERS.forEach((cornerType) => {
    const corner = application.stage.getChildByName(getCornerName$1(cornerType), !0);
    if (corner == null)
      return;
    const position = computeCornerPosition$1(cornerType, {
      height: mask.height,
      width: mask.width,
      x: mask.x,
      y: mask.y
    });
    corner.position = new PIXI.Point(position.x, position.y);
  });
}
function drawCorner$1(application, cornerType, {
  spriteName
}) {
  const previous = application.stage.getChildByName(getCornerName$1(cornerType), !0), scale = getApplicationScale(application);
  previous == null || previous.removeFromParent();
  const background = application.stage.getChildByName(CROP_BACKGROUND_NAME, !0), mask = application.stage.getChildByName(CROP_MASK_NAME, !0), sprite = application.stage.getChildByName(spriteName);
  if (sprite == null || background === null || background === void 0 || mask === void 0 || mask === null)
    return;
  const position = computeCornerPosition$1(cornerType, {
    height: mask.height,
    width: mask.width,
    x: mask.x,
    y: mask.y
  }), corner = new PIXI.Graphics();
  corner.beginFill(4960213, 1), corner.arc(0, 0, POINT_RADIUS$1 / scale, position.start, position.end), corner.lineTo(0, 0), corner.endFill(), corner.position = new PIXI.Point(position.x, position.y), corner.name = getCornerName$1(cornerType), corner.interactive = !0;
  let enable = !1;
  application.stage.on("pointermove", (event) => {
    if (enable === !1)
      return;
    const localPosition = background.toLocal(event.global);
    corner.position.x = localPosition.x, corner.position.y = localPosition.y, moveMask(application, cornerType, localPosition);
  });
  const handlePointerDown = () => {
    enable = !0;
  };
  corner.on("pointerdown", handlePointerDown);
  const handlePointerUp = () => {
    enable = !1;
  };
  globalThis.addEventListener("pointerup", handlePointerUp), corner.once("destroyed", () => {
    corner.off("pointerdown"), globalThis.removeEventListener("pointerup", handlePointerUp);
  }), background.addChild(corner);
}
function moveMask(application, cornerType, position) {
  const mask = application.stage.getChildByName(CROP_MASK_NAME, !0);
  if (mask == null)
    return;
  const right = mask.position.x + mask.width, bottom = mask.position.y + mask.height;
  switch (cornerType) {
    case "TOP_LEFT": {
      mask.position.x = position.x, mask.position.y = position.y, mask.width = right - position.x, mask.height = bottom - position.y;
      break;
    }
    case "TOP_RIGHT": {
      mask.position.y = position.y, mask.width = position.x - mask.position.x, mask.height = bottom - position.y;
      break;
    }
    case "BOTTOM_LEFT": {
      mask.position.x = position.x, mask.width = right - position.x, mask.height = position.y - mask.position.y;
      break;
    }
    case "BOTTOM_RIGHT": {
      mask.width = position.x - mask.position.x, mask.height = position.y - mask.position.y;
      break;
    }
  }
  refreshCorners(application);
}
function start$1(application, {
  spriteName
}) {
  stop$1(application), application.stage.interactive = !0, application.stage.interactiveChildren = !0, drawBackground(application, {
    spriteName
  }), drawCorner$1(application, "BOTTOM_LEFT", {
    spriteName
  }), drawCorner$1(application, "BOTTOM_RIGHT", {
    spriteName
  }), drawCorner$1(application, "TOP_LEFT", {
    spriteName
  }), drawCorner$1(application, "TOP_RIGHT", {
    spriteName
  });
}
function stop$1(application) {
  removeBackground(application), application.stage.off("pointermove"), application.render();
}
function save$1(application) {
  const mask = application.stage.getChildByName(CROP_MASK_NAME, !0);
  if (mask == null)
    return;
  stop$1(application);
  const stageTexture = application.renderer.generateTexture(application.stage).clone(), clonedStage = new PIXI.Sprite(stageTexture), maskBounds = mask.getBounds(), bounds = new PIXI.Rectangle(Math.floor(maskBounds.x), Math.floor(maskBounds.y), Math.floor(maskBounds.width), Math.floor(maskBounds.height)), cropped = new PIXI.Texture(clonedStage.texture.baseTexture, bounds);
  return new PIXI.Sprite(cropped);
}
const POINT_RADIUS = 20, CONTROL_NAME = "CONTROL_NAME";
function getCornerName(index) {
  return "RESIZE_CORNER_" + index;
}
function computeCornerPosition(position, sprite) {
  const left = sprite.x, top = sprite.y;
  switch (position) {
    case "TOP_LEFT":
      return {
        x: left,
        y: top,
        start: 0,
        end: Math.PI / 2
      };
    case "TOP_RIGHT":
      return {
        x: left + sprite.width,
        y: top,
        start: Math.PI / 2,
        end: Math.PI
      };
    case "BOTTOM_LEFT":
      return {
        x: left,
        y: top + sprite.height,
        start: 3 * Math.PI / 2,
        end: 2 * Math.PI
      };
    case "BOTTOM_RIGHT":
      return {
        x: left + sprite.width,
        y: top + sprite.height,
        start: Math.PI,
        end: 3 * Math.PI / 2
      };
  }
}
function resizeContainer(application, {
  container,
  cornerType,
  position,
  spriteName
}) {
  const sprite = application.stage.getChildByName(spriteName, !0);
  if (sprite == null)
    return;
  const isRotated = sprite.rotation % Math.PI !== 0, spriteWidth = isRotated ? sprite.height : sprite.width, spriteHeight = isRotated ? sprite.width : sprite.height;
  switch (cornerType) {
    case "TOP_LEFT": {
      container.position = new PIXI.Point(position.x, position.y), container.width = spriteWidth - 2 * position.x, container.height = spriteHeight - 2 * position.y;
      break;
    }
    case "TOP_RIGHT": {
      const newX = spriteWidth - position.x;
      container.position = new PIXI.Point(newX, position.y), container.width = spriteWidth - 2 * newX, container.height = spriteHeight - 2 * position.y;
      break;
    }
    case "BOTTOM_LEFT": {
      const newY = spriteHeight - position.y;
      container.position = new PIXI.Point(position.x, newY), container.width = spriteWidth - 2 * position.x, container.height = spriteHeight - 2 * newY;
      break;
    }
    case "BOTTOM_RIGHT": {
      const newY = spriteHeight - position.y, newX = spriteWidth - position.x;
      container.position = new PIXI.Point(newX, newY), container.width = spriteWidth - 2 * newX, container.height = spriteHeight - 2 * newY;
      break;
    }
  }
}
function removeCorner(application, cornerType) {
  const previous = application.stage.getChildByName(getCornerName(cornerType), !0);
  previous == null || previous.removeFromParent();
}
function drawCorner(application, cornerType, {
  spriteName
}) {
  removeCorner(application, cornerType);
  const sprite = application.stage.getChildByName(spriteName, !0), container = application.stage.getChildByName(CONTROL_NAME, !0);
  if (sprite == null || container === null || container === void 0)
    return;
  const position = computeCornerPosition(cornerType, container), corner = new PIXI.Graphics();
  corner.beginFill(4960213, 1), corner.arc(0, 0, POINT_RADIUS, position.start, position.end), corner.lineTo(0, 0), corner.endFill(), corner.position = new PIXI.Point(position.x, position.y), corner.name = getCornerName(cornerType), corner.interactive = !0;
  let enable = !1;
  application.stage.on("pointermove", (event) => {
    if (enable === !1)
      return;
    const localPosition = application.stage.toLocal(event.global);
    resizeContainer(application, {
      cornerType,
      position: localPosition,
      container,
      spriteName
    });
  });
  const handlePointerUp = () => {
    enable = !1;
  };
  globalThis.addEventListener("pointerup", handlePointerUp), corner.once("destroyed", () => {
    corner.off("pointerdown"), globalThis.removeEventListener("pointerup", handlePointerUp);
  });
  const handlePointerDown = () => {
    enable = !0;
  };
  corner.on("pointerdown", handlePointerDown), container.addChild(corner);
}
function drawContainer(application, spriteName) {
  removeContainer(application);
  const sprite = application.stage.getChildByName(spriteName, !0);
  if (sprite == null)
    return;
  const stageTexture = application.renderer.generateTexture(application.stage), clonedStage = new PIXI.Sprite(stageTexture);
  application.stage.children.forEach((child) => {
    child.alpha = 0;
  });
  const container = new PIXI.Graphics();
  container.drawRect(0, 0, sprite.width, sprite.height), container.name = CONTROL_NAME, container.interactive = !0, container.interactiveChildren = !0, application.stage.interactive = !0, application.stage.interactiveChildren = !0, application.stage.addChild(container), container.addChild(clonedStage);
}
function removeContainer(application) {
  const container = application.stage.getChildByName(CONTROL_NAME, !0);
  container == null || container.removeFromParent(), application.stage.children.forEach((child) => {
    child.alpha = 1;
  });
}
function drawControl(application, spriteName) {
  drawContainer(application, spriteName), drawCorner(application, "BOTTOM_LEFT", {
    spriteName
  }), drawCorner(application, "BOTTOM_RIGHT", {
    spriteName
  }), drawCorner(application, "TOP_LEFT", {
    spriteName
  }), drawCorner(application, "TOP_RIGHT", {
    spriteName
  });
}
function removeControl(application) {
  removeContainer(application), removeCorner(application, "BOTTOM_LEFT"), removeCorner(application, "BOTTOM_RIGHT"), removeCorner(application, "TOP_LEFT"), removeCorner(application, "TOP_RIGHT"), application.stage.off("pointermove");
}
function start(application, spriteName) {
  drawControl(application, spriteName);
}
function stop(application) {
  removeControl(application), application.stage.off("pointermove"), application.render();
}
function save(application) {
  var _a;
  const container = (_a = application == null ? void 0 : application.stage) == null ? void 0 : _a.getChildByName(CONTROL_NAME, !0), size2 = container ? {
    height: container.height,
    width: container.width
  } : void 0;
  if (removeControl(application), size2) {
    const stageTexture = application.renderer.generateTexture(application.stage).clone(), clonedStage = new PIXI.Sprite(stageTexture);
    return clonedStage.width = size2.width, clonedStage.height = size2.height, clonedStage;
  } else
    return;
}
async function rotate(application, spriteName) {
  const sprite = application == null ? void 0 : application.stage.getChildByName(spriteName, !0);
  if (application && sprite) {
    if (!application)
      return;
    const blobBefore = await toBlob(application), mergedSprite = await updateImageFromBlob(application, {
      imgDatasource: blobBefore,
      spriteName,
      settings: createImageSettings({
        application,
        sprite
      })
    });
    if (!mergedSprite)
      return;
    let backupOldMaxHeight, backupOldVisibility;
    const canvas = application.view;
    canvas.style && (backupOldMaxHeight = canvas.style.maxHeight ?? "", backupOldVisibility = canvas.style.visibility ?? "", canvas.style.maxHeight = `${canvas.clientHeight}px`, canvas.style.visibility = "hidden"), mergedSprite.rotation += Math.PI / 2, resizeStage({
      application,
      sprite: mergedSprite,
      newHeight: mergedSprite.width,
      newWidth: mergedSprite.height
    }), application.render();
    const blobAfter = await toBlob(application);
    backupOldMaxHeight !== void 0 && (canvas.style.maxHeight = backupOldMaxHeight), backupOldVisibility !== void 0 && (canvas.style.visibility = backupOldVisibility), await updateImageFromBlob(application, {
      imgDatasource: blobAfter,
      spriteName
    });
  }
}
function useImageEffects({
  application,
  spriteName,
  onSave
}) {
  return {
    rotate: async () => {
      application && await rotate(application, spriteName);
    },
    startCrop: () => {
      application && start$1(application, {
        spriteName
      });
    },
    stopCrop: (save2) => {
      if (application) {
        if (save2) {
          const result = save$1(application);
          result && onSave(result);
        }
        stop$1(application);
      }
    },
    startBlur: () => {
      application && start$2(application, {
        spriteName
      });
    },
    stopBlur: () => {
      application && stop$2(application);
    },
    startResize: () => {
      application && start(application, spriteName);
    },
    stopResize: (save$12) => {
      if (application) {
        if (save$12) {
          const result = save(application);
          result && onSave(result);
        }
        stop(application);
      }
    }
  };
}
function useImageEditor({
  imageSrc,
  spriteName = DEFAULT_SPRITE_NAME
}) {
  const [application, setApplication] = useState(void 0), [loading, setLoading] = useState(!0), {
    rotate: rotate2,
    startBlur,
    startCrop,
    startResize,
    stopBlur,
    stopCrop,
    stopResize
  } = useImageEffects({
    spriteName,
    application,
    onSave(sprite) {
      application && updateImage(application, {
        imgDatasource: sprite,
        spriteName
      });
    }
  }), toBlob2 = () => application ? saveAsBlob(application) : Promise.resolve(void 0), toDataURL = () => {
    if (application)
      return saveAsDataURL(application);
  }, {
    restore,
    historize,
    historyCount
  } = useHistoryTool$1({
    application,
    spriteName,
    onRestore(imgDatasource, state) {
      application && updateImageFromBlob(application, {
        imgDatasource,
        spriteName,
        settings: state
      });
    }
  });
  return useEffect(() => {
    application && (setLoading(!0), updateImage(application, {
      spriteName,
      imgDatasource: imageSrc
    }).finally(() => setLoading(!1)));
  }, [application, imageSrc, spriteName]), {
    historyCount,
    setApplication,
    restore,
    stopCrop,
    stopBlur,
    stopResize,
    startResize: async () => {
      setLoading(!0), await historize(startResize), setLoading(!1);
    },
    startCrop: async () => {
      setLoading(!0), await historize(startCrop), setLoading(!1);
    },
    startBlur: async () => {
      setLoading(!0), await historize(startBlur), setLoading(!1);
    },
    rotate: async () => {
      setLoading(!0), await historize(rotate2), setLoading(!1);
    },
    toBlob: toBlob2,
    toDataURL,
    loading
  };
}
const ImageEditor = ({
  altText: altTextParam,
  legend: legendParam,
  image: imageSrc,
  isOpen,
  onCancel,
  onError,
  onSave
}) => {
  const {
    t
  } = useTranslation(), [currentOperation, setCurrentOperation] = useState(void 0), [isSaving, setSaving] = useState(!1), [altText, setAltText] = useState(altTextParam ?? ""), [legend, setLegend] = useState(legendParam ?? ""), [dirty, setDirty] = useState(!1), {
    toBlob: toBlob2,
    setApplication,
    startBlur,
    stopBlur,
    restore,
    rotate: rotate2,
    startCrop,
    stopCrop,
    startResize,
    stopResize,
    historyCount,
    loading
  } = useImageEditor({
    imageSrc
  }), stopAll = () => {
    stopBlur(), stopCrop(currentOperation === "CROP"), stopResize(currentOperation === "RESIZE");
  }, handleSave = async () => {
    try {
      setSaving(!0), stopAll();
      const blob = await toBlob2();
      blob && await onSave({
        blob,
        legend,
        altText
      });
    } catch (e2) {
      onError == null || onError(`${e2}`);
    } finally {
      setSaving(!1);
    }
  }, handleCancel = () => {
    onCancel();
  }, handleOperation = async (operation) => {
    switch (stopAll(), setCurrentOperation(operation), setDirty(!0), operation) {
      case "ROTATE": {
        await rotate2();
        break;
      }
      case "UNDO": {
        await restore();
        break;
      }
      case "CROP": {
        startCrop();
        break;
      }
      case "RESIZE": {
        await startResize();
        break;
      }
      case "BLUR": {
        await startBlur();
        break;
      }
    }
  };
  return /* @__PURE__ */ jsxs(Modal$1, { id: "image-editor", isOpen, onModalClose: handleCancel, size: "lg", children: [
    /* @__PURE__ */ jsx(Modal$1.Header, { onModalClose: handleCancel, children: /* @__PURE__ */ jsx("span", { className: "h2", children: t("imageeditor.title") }) }),
    /* @__PURE__ */ jsx(Modal$1.Body, { className: "d-flex flex-column align-items-center", children: /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column gap-12 w-100 flex-grow-1", children: [
      /* @__PURE__ */ jsx(ImageEditorToolbar$1, { handle: handleOperation, historyCount }),
      /* @__PURE__ */ jsxs("div", { className: "position-relative d-flex flex-column align-items-center justify-content-center flex-grow-1 w-100 image-editor", children: [
        /* @__PURE__ */ jsx(Stage, { onMount: (app) => setApplication(app), options: {
          preserveDrawingBuffer: !0,
          backgroundAlpha: 0,
          resolution: 1
        } }),
        !!loading && /* @__PURE__ */ jsx("div", { className: "position-absolute top-0 start-0 bottom-0 end-0 m-10 d-flex align-items-center justify-content-center bg-black opacity-25", children: /* @__PURE__ */ jsx(LoadingScreen$1, {}) })
      ] }),
      /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column flex-md-row m-10 gap-12 w-100", children: [
        /* @__PURE__ */ jsxs(FormControl$1, { id: "alt", className: "flex-grow-1", children: [
          /* @__PURE__ */ jsx(Label$1, { children: t("alttext") }),
          /* @__PURE__ */ jsx(Input$1, { value: altText, onChange: (e2) => {
            setDirty(!0), setAltText(e2.target.value);
          }, placeholder: t("alttext.help"), size: "md", type: "text" })
        ] }),
        /* @__PURE__ */ jsxs(FormControl$1, { id: "legend", className: "flex-grow-1", children: [
          /* @__PURE__ */ jsx(Label$1, { children: t("legend") }),
          /* @__PURE__ */ jsx(Input$1, { value: legend, onChange: (e2) => {
            setDirty(!0), setLegend(e2.target.value);
          }, placeholder: t("legend.help"), size: "md", type: "text" })
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxs(Modal$1.Footer, { children: [
      /* @__PURE__ */ jsx(Button, { color: "tertiary", onClick: handleCancel, type: "button", variant: "ghost", children: t("imageeditor.cancel") }),
      /* @__PURE__ */ jsx(Button, { color: "primary", onClick: handleSave, type: "button", variant: "filled", isLoading: isSaving, disabled: isSaving || !dirty, children: t("imageeditor.save") })
    ] })
  ] });
}, ImageEditor$1 = ImageEditor, LinkerCard = ({
  doc,
  isClickable = !0,
  isSelectable = !1,
  isSelected = !1,
  onClick,
  className
}) => {
  const {
    fromNow
  } = useDate(), {
    fromDate
  } = useMemo(() => ({
    fromDate: fromNow(doc.modifiedAt)
  }), [fromNow, doc]);
  return /* @__PURE__ */ jsx(Card$1, { className: clsx("card-linker shadow-none", className), isClickable, isSelectable, isSelected, onClick, children: /* @__PURE__ */ jsxs(Card$1.Body, { space: "8", children: [
    /* @__PURE__ */ jsx("div", { className: "card-image ps-8 pe-4", children: doc.thumbnail && doc.thumbnail.length > 0 ? /* @__PURE__ */ jsx(Image$1, { alt: "", height: 48, width: 48, src: doc.thumbnail, objectFit: "cover", className: "rounded h-full", style: {
      aspectRatio: 1 / 1
    } }) : /* @__PURE__ */ jsx(AppIcon$1, { app: doc.application, iconFit: "ratio", size: "48", variant: "rounded" }) }),
    /* @__PURE__ */ jsxs("div", { className: "w-75", children: [
      /* @__PURE__ */ jsx(Card$1.Text, { children: doc.name }),
      /* @__PURE__ */ jsx(Card$1.Text, { className: "text-black-50", children: doc == null ? void 0 : doc.creatorName })
    ] }),
    /* @__PURE__ */ jsx("div", { className: "d-none d-md-block text-black-50 ps-4 pe-8", children: /* @__PURE__ */ jsx(Card$1.Text, { children: fromDate }) }),
    doc.shared && /* @__PURE__ */ jsx("div", { className: "ps-4 pe-8", children: /* @__PURE__ */ jsx(Users, { width: "20", height: "20" }) })
  ] }) });
}, LinkerCard$1 = LinkerCard, InternalLinker = ({
  appCode,
  defaultAppCode,
  defaultResourceId,
  onChange,
  onSelect,
  multiple = !0,
  resourceList,
  applicationList,
  showApplicationSelector = !0
}) => {
  const {
    t
  } = useTranslation(), {
    theme
  } = useOdeTheme(), [imagePath] = usePaths(), {
    resourceApplications,
    loadResources
  } = useResourceSearch(appCode), [options, setOptions] = useState(), [selectedApplication, setSelectedApplication] = useState(), [searchTerms, setSearchTerms] = useState(), debounceSearch = useDebounce(searchTerms || "", 500), [resources, setResources] = useState([]), filterResources = useCallback((resource, search) => {
    var _a, _b, _c;
    if (!search)
      return !0;
    const searchParam = (search == null ? void 0 : search.toLowerCase()) || "";
    return ((_a = resource.name) == null ? void 0 : _a.toLowerCase().includes(searchParam)) || ((_b = resource.creatorName) == null ? void 0 : _b.toLowerCase().includes(searchParam)) || ((_c = resource.description) == null ? void 0 : _c.toLowerCase().includes(searchParam));
  }, []), sortResources = useCallback((resources2) => resources2.sort((a, b) => a.modifiedAt < b.modifiedAt ? 1 : -1), []), loadAndDisplayResources = useCallback((search) => {
    async function load() {
      if (resourceList) {
        const filteredResources = resourceList.filter((resource) => filterResources(resource, search));
        setResources(sortResources(filteredResources));
        return;
      } else if (selectedApplication)
        try {
          const resources2 = (await loadResources({
            application: selectedApplication.application,
            search,
            types: [selectedApplication.application],
            filters: {},
            pagination: {
              startIdx: 0,
              pageSize: 300
            }
            // ignored at the moment
          })).filter((resource) => filterResources(resource, search));
          setResources(sortResources(resources2));
          return;
        } catch {
        }
      setResources([]);
    }
    load();
  }, [loadResources, selectedApplication, filterResources, sortResources, resourceList]), [selectedDocuments, setSelectedDocuments] = useState([]), handleOptionClick = (option) => {
    onChange == null || onChange(option), setSelectedApplication(option);
  }, handleSearchChange = (event) => {
    const newText = event.target.value;
    setSearchTerms(newText.toString());
  }, handleSubmit = useCallback((event) => {
    loadAndDisplayResources(searchTerms), event.stopPropagation(), event.preventDefault();
  }, [loadAndDisplayResources, searchTerms]), getSelectedResourceIndex = useCallback((resourceId) => selectedDocuments.findIndex((selectedDocument) => selectedDocument.assetId === resourceId), [selectedDocuments]), selectResource = useCallback((resource) => {
    setSelectedDocuments(multiple ? (previousState) => [...previousState, resource] : [resource]);
  }, [setSelectedDocuments, multiple]), toggleResourceSelection = useCallback((resource) => {
    const index = getSelectedResourceIndex(resource.assetId);
    index < 0 ? selectResource(resource) : setSelectedDocuments(selectedDocuments.filter((_value, i) => i !== index));
  }, [getSelectedResourceIndex, selectResource, selectedDocuments]);
  return useEffect(() => {
    (async () => {
      if (applicationList) {
        setOptions(applicationList.sort((app1, app2) => app1.displayName.localeCompare(app2.displayName)));
        return;
      }
      const appPromises = resourceApplications.map((application) => odeServices.session().getWebApp(application)), webApps = await Promise.all(appPromises);
      setOptions(resourceApplications.map((application, index) => {
        var _a;
        return {
          application,
          displayName: t(((_a = webApps[index]) == null ? void 0 : _a.displayName) ?? application),
          icon: /* @__PURE__ */ jsx(AppIcon$1, { app: webApps[index], size: "24" })
        };
      }).sort((app1, app2) => app1.displayName.localeCompare(app2.displayName)));
    })();
  }, [resourceApplications, t, applicationList]), useEffect(() => {
    loadAndDisplayResources(debounceSearch);
  }, [loadAndDisplayResources, debounceSearch]), useEffect(() => {
    onSelect == null || onSelect(selectedDocuments);
  }, [selectedDocuments]), useEffect(() => {
    var _a;
    const safeDefaultAppCode = defaultAppCode ?? ((applicationList == null ? void 0 : applicationList.length) === 1 && ((_a = applicationList == null ? void 0 : applicationList[0]) == null ? void 0 : _a.application));
    if (safeDefaultAppCode) {
      const option = options == null ? void 0 : options.find((option2) => safeDefaultAppCode === option2.application);
      setSelectedApplication(option), loadAndDisplayResources("");
    }
  }, [options, defaultAppCode]), useEffect(() => {
    if (defaultResourceId && getSelectedResourceIndex(defaultResourceId) < 0) {
      const resource = resources == null ? void 0 : resources.find((resource2) => defaultResourceId === resource2.assetId);
      resource && selectResource(resource);
    }
  }, [resources]), /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column flex-fill overflow-hidden", children: [
    /* @__PURE__ */ jsxs("div", { className: "search d-flex bg-light rounded-top border border-bottom-0", children: [
      showApplicationSelector && /* @__PURE__ */ jsx("div", { className: "flex-shrink-1 px-8 py-12 border-end", children: /* @__PURE__ */ jsxs(Dropdown$1, { overflow: !0, children: [
        /* @__PURE__ */ jsx(Dropdown$1.Trigger, { icon: /* @__PURE__ */ jsx("div", { className: "pe-8", children: (selectedApplication == null ? void 0 : selectedApplication.icon) || /* @__PURE__ */ jsx(Applications, {}) }), label: t((selectedApplication == null ? void 0 : selectedApplication.displayName) || "bbm.linker.int.choose"), variant: "ghost", size: "md" }),
        /* @__PURE__ */ jsx(Dropdown$1.Menu, { children: options == null ? void 0 : options.map((option) => /* @__PURE__ */ jsx(Dropdown$1.Item, { icon: option.icon, onClick: () => handleOptionClick(option), children: option.displayName }, option.application)) })
      ] }) }),
      /* @__PURE__ */ jsx("div", { className: "flex-grow-1 align-self-center", children: /* @__PURE__ */ jsx("form", { className: "gap-16 d-flex w-100 align-items-center px-16 py-8", onSubmit: handleSubmit, children: /* @__PURE__ */ jsx(SearchBar$1, { isVariant: !0, placeholder: t("search"), size: "lg", className: "w-100", disabled: !selectedApplication, onChange: handleSearchChange }) }) })
    ] }),
    /* @__PURE__ */ jsxs("div", { className: "internal-linker flex-grow-1 w-100 rounded-bottom border gap-0 overflow-auto", children: [
      selectedApplication && resources && resources.length > 0 && /* @__PURE__ */ jsx("div", { children: resources.map((resource) => {
        const isSelected = selectedDocuments.findIndex((doc) => doc.assetId === resource.assetId) >= 0;
        return /* @__PURE__ */ jsx(LinkerCard$1, { doc: resource, isSelected, onClick: () => toggleResourceSelection(resource) }, resource.path);
      }) }),
      selectedApplication && resources && resources.length <= 0 && /* @__PURE__ */ jsx("div", { className: "d-flex justify-content-center mt-16", children: /* @__PURE__ */ jsx(EmptyScreen, { imageSrc: `${imagePath}/${theme == null ? void 0 : theme.bootstrapVersion}/illu-empty-search-${selectedApplication.application}.svg`, text: t("bbm.linker.int.notfound"), className: "mt-16" }) }),
      !selectedApplication && /* @__PURE__ */ jsx("div", { className: "d-flex justify-content-center mt-32", children: /* @__PURE__ */ jsx(EmptyScreen, { imageSrc: `${imagePath}/${theme == null ? void 0 : theme.bootstrapVersion}/illu-empty-search.svg`, text: t("bbm.linker.int.empty"), className: "mt-32" }) })
    ] })
  ] });
}, InternalLinker$1 = InternalLinker, ExternalLinker = ({
  link,
  onChange,
  multiNodeSelected = !1
}) => {
  const {
    t
  } = useTranslation(), [linkText, setLinkText] = useState((link == null ? void 0 : link.text) || ""), [linkURL, setLinkURL] = useState((link == null ? void 0 : link.url) || ""), [isBlankTarget, toggleBlankTarget] = useToggle(link ? link.target === "_blank" : !0);
  return useEffect(() => {
    multiNodeSelected && (link != null && link.text) && setLinkText(link.text.slice(0, 20) + "...");
  }, [multiNodeSelected, link]), useEffect(() => {
    if (!linkURL.length) {
      onChange == null || onChange();
      return;
    }
    const newLink = {
      url: linkURL,
      text: multiNodeSelected ? link == null ? void 0 : link.text : linkText || linkURL,
      target: isBlankTarget ? "_blank" : void 0
    };
    !StringUtils.isLocalURL(linkURL) && !StringUtils.startWithHttp(linkURL) && (newLink.url = "http://" + linkURL), onChange == null || onChange(newLink);
  }, [linkText, linkURL, isBlankTarget]), /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column flex-fill gap-24", children: [
    /* @__PURE__ */ jsxs(FormControl$1, { id: "linkText", isOptional: !0, children: [
      /* @__PURE__ */ jsx(Label$1, { children: t("bbm.linker.ext.text") }),
      /* @__PURE__ */ jsx(Input$1, { type: "text", placeholder: t("bbm.linker.ext.text.placeholder"), size: "md", disabled: multiNodeSelected, value: linkText, onChange: (e2) => setLinkText(e2.target.value) })
    ] }),
    /* @__PURE__ */ jsxs(FormControl$1, { id: "linkUrl", isRequired: !0, children: [
      /* @__PURE__ */ jsx(Label$1, { children: t("bbm.linker.ext.url") }),
      /* @__PURE__ */ jsx(Input$1, { type: "text", placeholder: t("bbm.linker.ext.url.placeholder"), size: "md", value: linkURL, onChange: (e2) => setLinkURL(e2.target.value) })
    ] }),
    /* @__PURE__ */ jsx(Checkbox$1, { label: t("bbm.linker.open.tab"), onChange: () => toggleBlankTarget(), checked: isBlankTarget })
  ] }) });
}, ExternalLinker$1 = ExternalLinker, MediaLibraryContext = /* @__PURE__ */ createContext(null);
function useMediaLibraryContext() {
  const context = useContext(MediaLibraryContext);
  if (!context)
    throw new Error("Innertabs compound components cannot be rendered outside the MediaLibrary component");
  return context;
}
const Audio = () => {
  const {
    setResult,
    setPreSuccess,
    visibility
  } = useMediaLibraryContext(), ref = useRef(null);
  return /* @__PURE__ */ jsx(AudioRecorder$1, { ref, onRecordUpdated: (recordURL) => {
    recordURL ? (setResult(recordURL), setPreSuccess(() => ref.current.save)) : setResult();
  }, onSaveSuccess: (audioRessource) => {
    audioRessource && setResult(audioRessource);
  }, hideSaveAction: !0, visibility });
}, ExternalLink = ({
  link,
  multiNodeSelected = !1
}) => {
  const {
    setResult
  } = useMediaLibraryContext();
  return /* @__PURE__ */ jsx(ExternalLinker$1, { link, onChange: (link2) => {
    setResult(link2);
  }, multiNodeSelected });
}, Iframe = () => {
  const {
    setResult
  } = useMediaLibraryContext();
  return /* @__PURE__ */ jsx(Embed$1, { onSuccess: (ressource) => {
    ressource = ressource == null ? void 0 : ressource.replace(/<p /g, "<div ").replace(/\/p>/g, "/div>"), setResult(ressource);
  } });
}, InternalLink = ({
  target,
  resourceId,
  appPrefix
}) => {
  const {
    t
  } = useTranslation(), {
    setResult,
    setResultCounter,
    appCode,
    multiple
  } = useMediaLibraryContext(), [isChecked, toggleChecked] = useToggle(target === "_blank"), [resources, setRessources] = useState([]), handleSelect = (resources2) => {
    setRessources(resources2);
  };
  return useEffect(() => {
    setResult({
      target: isChecked ? "_blank" : void 0,
      resources
    }), resources && resources.length ? setResultCounter(resources.length) : setResultCounter(void 0);
  }, [isChecked, resources]), /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column flex-fill gap-16 overflow-hidden", children: [
    /* @__PURE__ */ jsx(InternalLinker$1, { appCode, defaultAppCode: appPrefix, defaultResourceId: resourceId, onSelect: handleSelect, multiple }),
    /* @__PURE__ */ jsx(Checkbox$1, { className: "align-items-center", checked: isChecked, label: t("bbm.linker.open.tab"), onChange: toggleChecked })
  ] });
}, customSize = (bytes, decimalPoint) => {
  if (bytes == 0)
    return "0 octets";
  const k = 1e3, dm = decimalPoint || 2, sizes = ["octets", "Ko", "Mo", "Go"], i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
}, UploadFiles = ({
  onFilesChange,
  visibility = "protected"
}) => {
  const {
    files,
    uploadedFiles,
    getUploadStatus,
    uploadFile,
    removeFile,
    updateImage: updateImage2,
    editingImage,
    setEditingImage,
    getUrl
  } = useUploadFiles$1({
    handleOnChange: onFilesChange,
    application: "media-library",
    visibility
  }), fileBlobs = useRef(/* @__PURE__ */ new Map());
  useEffect(() => {
    const blobs = fileBlobs.current;
    return () => {
      blobs.forEach((url) => URL.revokeObjectURL(url)), blobs.clear();
    };
  }, []);
  const renderItem = (file) => {
    const src = file.type.startsWith("image") ? fileBlobs.current.get(file.name) : "";
    return fileBlobs.current.has(file.name) || fileBlobs.current.set(file.name, URL.createObjectURL(file)), {
      name: file.name,
      info: {
        type: file.type,
        weight: customSize(file.size || 0, 1)
      },
      src
    };
  }, handleRemoveFile = (file) => {
    const blobUrl = fileBlobs.current.get(file.name);
    blobUrl && (URL.revokeObjectURL(blobUrl), fileBlobs.current.delete(file.name)), removeFile(file);
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    files.map((file) => {
      const resource = uploadedFiles.find((uploadedFile) => uploadedFile.name === file.name);
      return /* @__PURE__ */ jsx(UploadCard$1, { status: getUploadStatus(file), item: renderItem(file), onEdit: () => setEditingImage(resource), onRetry: () => uploadFile(file), onDelete: () => handleRemoveFile(file) }, file.name);
    }),
    editingImage && /* @__PURE__ */ jsx(ImageEditor$1, { altText: editingImage.alt, legend: editingImage.title, image: getUrl(editingImage, !0), isOpen: !!editingImage, onCancel: () => setEditingImage(void 0), onSave: updateImage2, onError: console.error })
  ] });
}, UploadFiles$1 = UploadFiles, acceptedTypes = (type) => {
  const acceptedTypes2 = [];
  switch (type) {
    case "audio":
      acceptedTypes2.push("audio/*");
      break;
    case "video":
      acceptedTypes2.push("video/*");
      break;
    case "image":
      acceptedTypes2.push("image/png"), acceptedTypes2.push("image/jpeg"), acceptedTypes2.push("image/webp"), acceptedTypes2.push("image/gif"), acceptedTypes2.push("image/avif");
      break;
  }
  return acceptedTypes2;
}, Upload = () => {
  const {
    type,
    visibility,
    multiple,
    setResult,
    setResultCounter,
    setCancellable
  } = useMediaLibraryContext(), handleOnFilesChange = (uploadedFiles) => {
    uploadedFiles.length ? (setCancellable(uploadedFiles), setResultCounter(uploadedFiles.length), setResult(uploadedFiles)) : (setCancellable([]), setResultCounter(void 0), setResult(void 0));
  };
  return /* @__PURE__ */ jsx("div", { className: "py-8 flex-grow-1", children: /* @__PURE__ */ jsx(Dropzone$1, { multiple, accept: acceptedTypes(type ?? "embedder"), children: /* @__PURE__ */ jsx(UploadFiles$1, { onFilesChange: handleOnFilesChange, visibility }) }) });
}, VIDEO_HEIGHT = 9, VIDEO_WIDTH = 16, VideoRecorder = /* @__PURE__ */ forwardRef(({
  appCode,
  caption,
  onSuccess,
  onError,
  onRecordUpdated,
  hideSaveAction = !1
}, ref) => {
  const [maxDuration, setMaxDuration] = useState(18e4), [inputDevices, setInputDevices] = useState([]), [recording, setRecording] = useState(!1), [recorded, setRecorded] = useState(!1), [playing, setPlaying] = useState(!1), [saving, setSaving] = useState(!1), [saved, setSaved] = useState(!1), [mediaStreamConstraints, setMediaStreamConstraints] = useState({
    audio: !0,
    video: {
      facingMode: "environment",
      aspectRatio: VIDEO_WIDTH / VIDEO_HEIGHT
    }
  }), [stream, setStream] = useState(), [mimeType, setMimeType] = useState(""), [recordedChunks, setRecordedChunks] = useState([]), [recordedVideo, setRecordedVideo] = useState(), [recordedTime, setRecordedTime] = useState(0), [playedTime, setPlayedTime] = useState(0), videoRef = useRef(null), recorderRef = useRef(null), {
    uploadBlob
  } = useUpload$1(void 0, appCode), {
    device
  } = useBrowserInfo(navigator.userAgent);
  useImperativeHandle(ref, () => ({
    save: handleSave
  }));
  const {
    t
  } = useTranslation();
  useEffect(() => {
    initMaxDuration(), initInputDevices();
  }, []), useEffect(() => (stream || enableStream(mediaStreamConstraints), () => {
    stream && stream.getTracks().forEach((track) => track.stop());
  }), [stream]), useEffect(() => {
    if (recordedChunks.length && !recording && videoRef.current) {
      const finalVideo = new Blob(recordedChunks, {
        type: mimeType
      });
      if (setRecordedVideo(finalVideo), onRecordUpdated) {
        const videoUrl = window.URL.createObjectURL(finalVideo);
        onRecordUpdated(videoUrl);
      }
      videoRef.current.autoplay = !1, videoRef.current.srcObject = null, videoRef.current.src = window.URL.createObjectURL(finalVideo);
    }
  }, [recording, recordedChunks]), useEffect(() => {
    if (recording) {
      const startedAt = Date.now(), timer = window.setInterval(
        // Compute exact elapsed time by diffing the start time.
        () => setRecordedTime(Date.now() - startedAt),
        500
      );
      return () => {
        window.clearInterval(timer);
      };
    }
  }, [recording]), useEffect(() => {
    if (playing) {
      const timer = window.setInterval(() => setPlayedTime((prev) => prev + 500), 500);
      return () => {
        window.clearInterval(timer);
      };
    }
  }, [playing]);
  const initMaxDuration = async () => {
    const videoConfResponse = await odeServices.video().getVideoConf();
    setMaxDuration((videoConfResponse.maxDuration ?? 3) * 60 * 1e3);
  }, initInputDevices = async () => {
    const videoDevices = (await navigator.mediaDevices.enumerateDevices()).filter((device2) => device2.kind === "videoinput");
    switch (device.type) {
      case "mobile":
      case "tablet": {
        const backCamera = {
          deviceId: "environment",
          label: t("video.back.camera"),
          groupId: "",
          kind: "videoinput"
        }, frontCamera = {
          deviceId: "user",
          label: t("video.front.camera"),
          groupId: "",
          kind: "videoinput"
        };
        (videoDevices == null ? void 0 : videoDevices.length) > 1 ? setInputDevices([backCamera, frontCamera]) : setInputDevices([backCamera]);
        break;
      }
      default:
        setInputDevices(videoDevices);
        break;
    }
  }, enableStream = async (mediaStreamConstraints2) => {
    try {
      const mediaStream = await navigator.mediaDevices.getUserMedia(mediaStreamConstraints2);
      setStream(mediaStream), videoRef.current && (videoRef.current.src && (window.URL.revokeObjectURL(videoRef.current.src), videoRef.current.src = ""), videoRef.current.srcObject = mediaStream, videoRef.current.autoplay = !0, videoRef.current.volume = 1, videoRef.current.muted = !0);
    } catch (err) {
      console.error(err);
    }
  }, handleRecord = useCallback(() => {
    setRecording(!0), videoRef && videoRef.current && (videoRef.current.muted = !0);
    const mimeType2 = getBestSupportedMimeType();
    setMimeType(mimeType2), stream && (recorderRef.current = new MediaRecorder(stream, {
      mimeType: mimeType2
    }), recorderRef.current.ondataavailable = ({
      data
    }) => {
      data.size > 0 && setRecordedChunks((prev) => [...prev, data]);
    }, recorderRef.current.onerror = (event) => console.error(event), recorderRef.current.start(1e3));
  }, [stream]), handleStop = useCallback(() => {
    var _a;
    setRecording(!1), setRecorded(!0), ((_a = recorderRef.current) == null ? void 0 : _a.state) === "recording" && (recorderRef.current.requestData(), recorderRef.current.stop());
  }, [recorderRef]), handlePlayPause = useCallback(() => {
    var _a, _b;
    videoRef && videoRef.current && (videoRef.current.muted = !1), playing ? ((_b = videoRef == null ? void 0 : videoRef.current) == null || _b.pause(), setPlaying(!1)) : ((_a = videoRef == null ? void 0 : videoRef.current) == null || _a.play(), setPlaying(!0));
  }, [playing]), handleReset = () => {
    setRecorded(!1), setRecording(!1), setPlaying(!1), setSaved(!1), setRecordedTime(0), setRecordedChunks([]), setRecordedVideo(void 0), enableStream(mediaStreamConstraints), onRecordUpdated && onRecordUpdated();
  }, handleSave = async () => {
    var _a;
    if ((_a = videoRef == null ? void 0 : videoRef.current) == null || _a.pause(), setSaving(!0), !recordedVideo) {
      console.error("Error while saving video: recorded video is undefined.");
      return;
    }
    const resVideo = await uploadBlob(recordedVideo, {
      duration: recordedTime
    });
    if (resVideo != null)
      return onSuccess == null || onSuccess([resVideo]), setSaving(!1), setSaved(!0), [resVideo];
    onError("Error while uploading video"), setSaving(!1), setSaved(!0);
  }, handleEnded = () => {
    setPlaying(!1), setPlayedTime(0), videoRef.current && (videoRef.current.currentTime = 0);
  }, handleInputDeviceChange = (option) => {
    var _a;
    const selectedDevice = inputDevices.find((inputDevice) => inputDevice.label === option);
    let mediaStreamConstraints2 = {};
    selectedDevice != null && selectedDevice.deviceId ? ((selectedDevice == null ? void 0 : selectedDevice.deviceId) === "environment" || (selectedDevice == null ? void 0 : selectedDevice.deviceId) === "user" ? mediaStreamConstraints2 = {
      audio: !0,
      video: {
        aspectRatio: VIDEO_WIDTH / VIDEO_HEIGHT,
        facingMode: selectedDevice == null ? void 0 : selectedDevice.deviceId
      }
    } : mediaStreamConstraints2 = {
      audio: !0,
      video: {
        aspectRatio: VIDEO_WIDTH / VIDEO_HEIGHT,
        deviceId: selectedDevice.deviceId
      }
    }, setMediaStreamConstraints(mediaStreamConstraints2), stream && (((_a = recorderRef.current) == null ? void 0 : _a.state) === "recording" && (recorderRef.current.requestData(), recorderRef.current.stop()), stream.getTracks().forEach((track) => track.stop()), setStream(void 0)), enableStream(mediaStreamConstraints2)) : console.error("Selected input device id is null");
  };
  useEffect(() => {
    recordedTime >= maxDuration && handleStop();
  }, [recordedTime, handleStop]);
  const toolbarItems = [{
    type: "icon",
    name: "record",
    props: {
      icon: /* @__PURE__ */ jsx(Record, { color: recording || recorded ? "" : "red" }),
      color: "danger",
      disabled: recording || recorded || saving,
      onClick: handleRecord,
      "aria-label": t("bbm.video.record.start")
    },
    tooltip: t("bbm.video.record.start")
  }, {
    type: "icon",
    name: "stop",
    props: {
      icon: /* @__PURE__ */ jsx(RecordStop, {}),
      disabled: !recording || recorded || saving,
      onClick: handleStop,
      "aria-label": t("bbm.video.record.stop")
    },
    tooltip: t("bbm.video.record.stop")
  }, {
    type: "icon",
    name: "play",
    visibility: playing ? "hide" : "show",
    props: {
      icon: /* @__PURE__ */ jsx(PlayFilled, {}),
      disabled: !recorded || saving,
      onClick: handlePlayPause,
      "aria-label": t("bbm.video.play.start")
    },
    tooltip: t("bbm.video.play.start")
  }, {
    type: "icon",
    name: "pause",
    visibility: playing ? "show" : "hide",
    props: {
      icon: /* @__PURE__ */ jsx(Pause, {}),
      disabled: !recorded || saving,
      onClick: handlePlayPause,
      "aria-label": t("bbm.video.play.pause")
    },
    tooltip: t("bbm.video.play.pause")
  }, {
    type: "divider"
  }, {
    type: "icon",
    name: "reset",
    props: {
      icon: /* @__PURE__ */ jsx(Refresh, {}),
      disabled: !recorded || saving,
      onClick: handleReset,
      "aria-label": t("bbm.video.record.reset")
    },
    tooltip: t("bbm.video.record.reset")
  }, {
    type: "icon",
    name: "save",
    visibility: hideSaveAction ? "hide" : "show",
    props: {
      icon: /* @__PURE__ */ jsx(Save, {}),
      disabled: !recorded || saving || saved,
      onClick: handleSave,
      "aria-label": t("bbm.video.record.save")
    },
    tooltip: t("bbm.video.record.save")
  }];
  return /* @__PURE__ */ jsxs("div", { className: "video-recorder d-flex flex-fill flex-column align-items-center pb-8", children: [
    /* @__PURE__ */ jsx("div", { className: "video-recorder-caption d-none d-md-block", children: caption }),
    inputDevices.length > 1 && /* @__PURE__ */ jsx("div", { className: "video-recorder-devices mb-12", children: /* @__PURE__ */ jsxs(FormControl$1, { id: "selectInputDevice", children: [
      /* @__PURE__ */ jsx(Label$1, { className: "d-none d-md-block", children: t("bbm.video.record.select.devices.label") }),
      /* @__PURE__ */ jsx(Select$1, { placeholderOption: t("bbm.video.record.select.devices.placeholder"), options: inputDevices.map((videoInputDevice) => videoInputDevice.label), onValueChange: handleInputDeviceChange })
    ] }) }),
    /* @__PURE__ */ jsxs("div", { className: "video-recorder-video-container position-relative align-self-stretch", children: [
      /* @__PURE__ */ jsx("video", { ref: videoRef, playsInline: !0, autoPlay: !0, controls: !1, muted: !0, onEnded: handleEnded, className: "rounded", children: /* @__PURE__ */ jsx("track", { default: !0, kind: "captions", srcLang: "fr", src: "" }) }),
      (recording || recorded) && /* @__PURE__ */ jsxs("div", { className: "video-recorder-time d-flex align-items-center font-monospace fs-6 text-bg-dark rounded", children: [
        recording && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Record, { width: 12, height: 12, color: "red", className: "me-4" }),
          /* @__PURE__ */ jsxs("span", { children: [
            convertMsToMS(recordedTime),
            "/",
            convertMsToMS(maxDuration)
          ] })
        ] }),
        recorded && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(RecordVideo, { width: 14, height: 14, className: "me-4" }),
          /* @__PURE__ */ jsxs("span", { children: [
            convertMsToMS(playedTime),
            "/",
            convertMsToMS(recordedTime)
          ] })
        ] })
      ] }),
      stream && /* @__PURE__ */ jsx(Toolbar, { items: toolbarItems, className: "position-absolute bottom-0 start-50 bg-white" })
    ] }),
    saving && /* @__PURE__ */ jsx(LoadingScreen$1, { position: !1, caption: t("bbm.video.save.loader.caption") })
  ] });
}), VideoRecorder$1 = VideoRecorder, Video = () => {
  const {
    appCode,
    setResult,
    setPreSuccess
  } = useMediaLibraryContext(), {
    t
  } = useTranslation(), ref = useRef(null), handleRecordUpdated = (recordUrl) => {
    recordUrl ? (setResult(recordUrl), setPreSuccess(() => ref.current.save)) : setResult();
  }, handleError = (err) => {
    console.error(err);
  };
  return /* @__PURE__ */ jsx(VideoRecorder$1, { ref, appCode, caption: t("bbm.video.caption"), onRecordUpdated: handleRecordUpdated, onError: handleError, hideSaveAction: !0 });
}, VideoEmbed = ({
  switchType,
  onSuccess
}) => {
  const {
    t
  } = useTranslation(), [url, setUrl] = useState(), [embedVideo, setEmbedVideo] = useState(), [embedder, setEmbedder] = useState(void 0), [whiteListProvider, setWhiteListProvider] = useState(), debounceChangeUrl = useDebounce(url || "", 300), formControlId = useId(), [imagePath] = usePaths();
  useEffect(() => {
    initWhiteListProvider();
  }, []), useEffect(() => {
    if (whiteListProvider && debounceChangeUrl) {
      const embedderFound = odeServices.embedder().getProviderFromUrl(whiteListProvider, debounceChangeUrl);
      if (embedderFound) {
        setEmbedder(embedderFound);
        const embedVideo2 = odeServices.embedder().getEmbedCodeForProvider(embedderFound, debounceChangeUrl);
        setEmbedVideo(embedVideo2), onSuccess(embedVideo2);
      } else
        setEmbedder(void 0), onSuccess();
    }
  }, [debounceChangeUrl, whiteListProvider]);
  const initWhiteListProvider = async () => {
    const whiteListProviderResponse = await Promise.all([odeServices.embedder().getDefault(), odeServices.embedder().getCustom()]).then((results) => results.flat());
    setWhiteListProvider(whiteListProviderResponse);
  };
  function handleUrlChange(event) {
    const url2 = event.currentTarget.value;
    setUrl(url2), onSuccess(url2 != null && url2.length ? url2 : void 0);
  }
  function handleSwitchToEmbedderClick() {
    switchType == null || switchType("embedder");
  }
  const renderContent = () => debounceChangeUrl ? embedder ? /* @__PURE__ */ jsxs("div", { className: "mx-auto mt-16", children: [
    /* @__PURE__ */ jsxs("div", { className: "video-embed-provider d-flex align-items-center", children: [
      /* @__PURE__ */ jsx(Image$1, { src: embedder.logo, alt: "Logo " + embedder.displayName, className: "video-embed-provider-logo" }),
      embedder.displayName
    ] }),
    embedVideo && /* @__PURE__ */ jsx("div", { className: "video-embed-preview mt-12", dangerouslySetInnerHTML: {
      __html: embedVideo
    } })
  ] }) : /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column align-items-center m-16", children: [
    /* @__PURE__ */ jsx(EmptyScreen, { imageSrc: `${imagePath}/emptyscreen/illu-error.svg`, title: t("bbm.video.previewError.title"), text: t("bbm.video.previewError.text") }),
    switchType && /* @__PURE__ */ jsxs(Button, { variant: "ghost", color: "primary", onClick: handleSwitchToEmbedderClick, className: "align-items-start mt-16", children: [
      t("bbm.video.useEmbedCode"),
      " ",
      /* @__PURE__ */ jsx(ArrowRight, {})
    ] })
  ] }) : switchType && /* @__PURE__ */ jsx("div", { className: "d-flex my-16 align-items-start", children: /* @__PURE__ */ jsxs(Button, { variant: "ghost", color: "primary", onClick: handleSwitchToEmbedderClick, className: "align-items-start", children: [
    t("bbm.video.useEmbedCode"),
    " ",
    /* @__PURE__ */ jsx(ArrowRight, {})
  ] }) });
  return /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column flex-fill video-embed", children: [
    /* @__PURE__ */ jsxs("div", { className: "mb-8 d-flex", children: [
      /* @__PURE__ */ jsx(Globe, { className: "me-8" }),
      t("bbm.video.url.title")
    ] }),
    /* @__PURE__ */ jsx(FormControl$1, { id: formControlId, children: /* @__PURE__ */ jsx(Input$1, { size: "md", type: "text", placeholder: t("bbm.video.url.placeholder"), onChange: handleUrlChange }) }),
    /* @__PURE__ */ jsx(Fragment, { children: renderContent() })
  ] });
}, VideoEmbed$1 = VideoEmbed, VideoEmbedder = () => {
  const {
    switchType,
    setResult
  } = useMediaLibraryContext();
  return /* @__PURE__ */ jsx(VideoEmbed$1, { switchType, onSuccess: (ressource) => {
    setResult(ressource);
  } });
}, Workspace$1 = ({
  roles,
  onSelect,
  multiple = !0,
  className,
  defaultFolder,
  showPublicFolder
}) => {
  const {
    t
  } = useTranslation(), {
    root: ownerRoot,
    loadContent: loadOwnerDocs
  } = useWorkspaceSearch("root", t("workspace.tree.owner"), "owner", roles), {
    root: sharedRoot,
    loadContent: loadSharedDocs
  } = useWorkspaceSearch("root", t("workspace.tree.shared"), "shared", roles), {
    root: protectRoot,
    loadContent: loadProtectedDocs
  } = useWorkspaceSearch("root", t("workspace.tree.protected"), "protected", roles), {
    root: publicRoot,
    loadContent: loadPublicDocs
  } = useWorkspaceSearch("root", t("workspace.tree.public"), "public", roles), ownerRef = useRef(null), sharedRef = useRef(null), protectRef = useRef(null), publicRef = useRef(null), [currentFilter, setCurrentFilter] = useState(() => defaultFolder === "public" ? showPublicFolder ? defaultFolder : "protected" : defaultFolder === "protected" || defaultFolder === "shared" ? defaultFolder : "owner"), [currentNode, setCurrentNode] = useState(() => defaultFolder === "public" ? showPublicFolder ? publicRoot : protectRoot : defaultFolder === "protected" ? protectRoot : defaultFolder === "shared" ? sharedRoot : ownerRoot), [documents, setDocuments] = useState(), [searchTerm, setSearchTerm] = useState(null), [sortOrder, setSortOrder] = useState(["modified", "desc"]), [selectedDocuments, setSelectedDocuments] = useState([]), rootNodeFor = useCallback((filter) => {
    switch (filter) {
      case "owner":
        return {
          root: ownerRoot,
          othersRef: [sharedRef, protectRef, publicRef]
        };
      case "shared":
        return {
          root: sharedRoot,
          othersRef: [ownerRef, protectRef, publicRef]
        };
      case "protected":
        return {
          root: protectRoot,
          othersRef: [ownerRef, sharedRef, publicRef]
        };
      case "public":
        return {
          root: publicRoot,
          othersRef: [ownerRef, sharedRef, protectRef]
        };
      default:
        throw "no.root.node";
    }
  }, [ownerRoot, sharedRoot, protectRoot, publicRoot]), loadContent = useCallback(() => {
    switch (currentFilter) {
      case "owner":
        loadOwnerDocs(currentNode.id);
        break;
      case "shared":
        loadSharedDocs(currentNode.id);
        break;
      case "protected":
        loadProtectedDocs(currentNode.id);
        break;
      case "public":
        loadPublicDocs(currentNode.id);
        break;
      default:
        throw "no.way";
    }
  }, [currentFilter, currentNode.id, loadOwnerDocs, loadProtectedDocs, loadPublicDocs, loadSharedDocs]);
  function selectAndLoadContent(filter, nodeId) {
    setCurrentFilter(filter);
    const {
      root,
      othersRef
    } = rootNodeFor(filter), targetNode = findTreeNode(root, (node) => node.id === nodeId);
    targetNode && (setCurrentNode(targetNode), othersRef.forEach((otherRef) => {
      var _a;
      return (_a = otherRef.current) == null ? void 0 : _a.unselectAll();
    }));
  }
  useEffect(() => {
    var _a;
    let ref;
    switch (currentFilter) {
      case "owner":
        ref = ownerRef;
        break;
      case "shared":
        ref = sharedRef;
        break;
      case "protected":
        ref = protectRef;
        break;
      case "public":
        ref = publicRef;
        break;
      default:
        return;
    }
    (_a = ref == null ? void 0 : ref.current) == null || _a.select("root");
  }, [currentFilter]), useEffect(loadContent, [loadContent]), useEffect(() => {
    if (currentNode.files) {
      let list = [].concat(currentNode.files);
      searchTerm && (list = list.filter((f2) => f2.name.indexOf(searchTerm) >= 0));
      const sortFunction = sortOrder[0] === "name" ? sortOrder[1] === "asc" ? (a, b) => compare(a.name, b.name) : (a, b) => compare(b.name, a.name) : (a, b) => compare(b.modified, a.modified);
      setDocuments(() => list.sort(sortFunction));
    } else
      setDocuments(void 0);
  }, [currentNode, ownerRoot, protectRoot, sharedRoot, publicRoot, searchTerm, sortOrder]);
  const handleSearchChange = useCallback((e2) => {
    setSearchTerm(e2.target.value);
  }, [setSearchTerm]);
  function compare(a, b) {
    return a ? b ? a.localeCompare(b) : 1 : -1;
  }
  function getSortOrderLabel() {
    return sortOrder[0] === "name" ? sortOrder[1] === "asc" ? t("sort.order.alpha.asc") : t("sort.order.alpha.desc") : t("sort.order.modify.desc");
  }
  function handleSelectDoc(doc) {
    let currentDocuments = [...selectedDocuments];
    multiple ? currentDocuments.includes(doc) ? currentDocuments = currentDocuments.filter((selectedDocument) => selectedDocument._id !== doc._id) : currentDocuments = [...currentDocuments, doc] : currentDocuments = [doc], setSelectedDocuments(currentDocuments), onSelect(currentDocuments);
  }
  const workspace = clsx("workspace flex-grow-1 gap-0", className);
  return /* @__PURE__ */ jsxs(Grid, { className: workspace, children: [
    /* @__PURE__ */ jsx(Grid.Col, { sm: "12", md: "3", xl: "4", className: "workspace-folders p-12 pt-0 gap-12", children: /* @__PURE__ */ jsxs("div", { style: {
      position: "sticky",
      top: 0,
      paddingTop: "1.2rem"
    }, children: [
      /* @__PURE__ */ jsx(TreeView$1, { ref: ownerRef, data: ownerRoot, onTreeItemClick: (nodeId) => selectAndLoadContent("owner", nodeId), onTreeItemUnfold: (nodeId) => selectAndLoadContent("owner", nodeId) }),
      /* @__PURE__ */ jsx(TreeView$1, { ref: sharedRef, data: sharedRoot, onTreeItemClick: (nodeId) => selectAndLoadContent("shared", nodeId), onTreeItemUnfold: (nodeId) => selectAndLoadContent("shared", nodeId) }),
      /* @__PURE__ */ jsx(TreeView$1, { ref: protectRef, data: protectRoot, onTreeItemClick: (nodeId) => selectAndLoadContent("protected", nodeId), onTreeItemUnfold: (nodeId) => selectAndLoadContent("protected", nodeId) }),
      showPublicFolder && /* @__PURE__ */ jsx(TreeView$1, { ref: publicRef, data: publicRoot, onTreeItemClick: (nodeId) => selectAndLoadContent("public", nodeId), onTreeItemUnfold: (nodeId) => selectAndLoadContent("public", nodeId) })
    ] }) }),
    /* @__PURE__ */ jsx(Grid.Col, { sm: "12", md: "5", xl: "8", children: /* @__PURE__ */ jsxs(Grid, { className: "flex-grow-1 gap-0", children: [
      /* @__PURE__ */ jsxs(Grid.Col, { sm: "4", md: "8", xl: "12", children: [
        /* @__PURE__ */ jsx("div", { className: "workspace-search px-16 py-8 ", children: /* @__PURE__ */ jsx(SearchBar$1, { isVariant: !0, className: "gap-16", onChange: handleSearchChange }) }),
        /* @__PURE__ */ jsxs("div", { className: "d-flex align-items-center justify-content-end px-8 py-4", children: [
          /* @__PURE__ */ jsx("small", { className: "text-muted", children: t("workspace.search.order") }),
          /* @__PURE__ */ jsxs(Dropdown$1, { children: [
            /* @__PURE__ */ jsx(Dropdown$1.Trigger, { size: "sm", label: getSortOrderLabel(), variant: "ghost" }),
            /* @__PURE__ */ jsxs(Dropdown$1.Menu, { children: [
              /* @__PURE__ */ jsx(Dropdown$1.Item, { icon: /* @__PURE__ */ jsx(SortTime, {}), onClick: () => setSortOrder(["modified", "desc"]), children: t("sort.order.modify.desc") }),
              /* @__PURE__ */ jsx(Dropdown$1.Item, { icon: /* @__PURE__ */ jsx(SortAscendingLetters, {}), onClick: () => setSortOrder(["name", "asc"]), children: t("sort.order.alpha.asc") }),
              /* @__PURE__ */ jsx(Dropdown$1.Item, { icon: /* @__PURE__ */ jsx(SortDescendingLetters, {}), onClick: () => setSortOrder(["name", "desc"]), children: t("sort.order.alpha.desc") })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsx(Grid.Col, { sm: "4", md: "8", xl: "12", className: "p-8 gap-8", children: documents ? documents.length !== 0 ? /* @__PURE__ */ jsx("div", { className: "grid grid-workspace", children: documents.map((doc) => {
        const isSelected = selectedDocuments.includes(doc);
        return /* @__PURE__ */ jsx(FileCard$1, { doc, isSelected, onClick: () => handleSelectDoc(doc) }, doc._id);
      }) }) : /* @__PURE__ */ jsx(EmptyScreen, { imageSrc: "/assets/themes/edifice-bootstrap/images/emptyscreen/illu-trash.svg", text: t("workspace.empty.docSpace"), title: t("explorer.emptyScreen.trash.title") }) : /* @__PURE__ */ jsx(LoadingScreen$1, {}) })
    ] }) })
  ] });
}, Component = Workspace$1, Workspace = () => {
  const {
    type,
    setResultCounter,
    setResult,
    multiple,
    visibility
  } = useMediaLibraryContext();
  function getDocumentRoleFilter() {
    switch (type) {
      case "image":
        return "img";
      case "audio":
        return "audio";
      case "video":
        return "video";
      default:
        return null;
    }
  }
  function handleSelect(result) {
    setResultCounter(result.length), result.length ? setResult(result) : setResult();
  }
  return /* @__PURE__ */ jsx(Component, { roles: getDocumentRoleFilter(), onSelect: handleSelect, multiple, className: "border rounded overflow-y-auto", defaultFolder: visibility, showPublicFolder: visibility === "public" });
}, InnerTabs = {
  Audio,
  Video,
  Upload,
  ExternalLink,
  Workspace,
  InternalLink,
  Iframe,
  VideoEmbedder
}, orderedTabs = [
  "audio-capture",
  "video-capture",
  "internal-link",
  // Link to a shared resource (previously known as "internal linker")
  "external-link",
  // Link to an external website (previously known as "external linker")
  "iframe",
  // Framed website
  "upload",
  // Filesystem browser + drag'n'drop of files
  "workspace",
  // Media browser
  "video-embedder"
  // Link to a hosted video
], mediaLibraryTypes = {
  none: null,
  audio: {
    title: "bbm.audio.modal.title",
    defaultTab: "audio-capture"
  },
  video: {
    title: "bbm.video.modal.title",
    defaultTab: "video-capture"
  },
  image: {
    title: "bbm.image.modal.title",
    defaultTab: "workspace"
  },
  attachment: {
    title: "bbm.attachment.modal.title",
    defaultTab: "workspace"
  },
  hyperlink: {
    title: "bbm.link.modal.title",
    defaultTab: "linker"
  },
  embedder: {
    title: "bbm.embed.modal.title",
    defaultTab: "iframe"
  }
}, MediaLibrary = /* @__PURE__ */ forwardRef(({
  appCode,
  visibility,
  multiple,
  onSuccess,
  onCancel,
  onTabChange
}, ref) => {
  var _a;
  const linkTabProps = useRef(), refModal = useRef(null);
  useImperativeHandle(ref, () => ({
    show,
    hide,
    showLink,
    type,
    ...refModal.current
  })), useHttpErrorToast$1({
    isDismissible: !0,
    duration: 1 / 0
  });
  const {
    t
  } = useTranslation(), workspaceCreateWorkflow = useHasWorkflow("org.entcore.workspace.controllers.WorkspaceController|addDocument"), videoCaptureWorkflow = useHasWorkflow("com.opendigitaleducation.video.controllers.VideoController|capture"), [type, setType] = useState(null), availableTabs = {
    workspace: {
      id: "workspace",
      icon: /* @__PURE__ */ jsx(Folder, {}),
      label: t("bbm.workspace"),
      content: /* @__PURE__ */ jsx(InnerTabs.Workspace, {}),
      availableFor: ["audio", "video", "image", "attachment"],
      isEnable: null
    },
    upload: {
      id: "upload",
      icon: /* @__PURE__ */ jsx(Smartphone, {}),
      label: t("bbm.device"),
      content: /* @__PURE__ */ jsx(InnerTabs.Upload, {}),
      availableFor: ["audio", "video", "image", "attachment"],
      isEnable: () => !!workspaceCreateWorkflow
    },
    "video-capture": {
      id: "video-capture",
      icon: /* @__PURE__ */ jsx(RecordVideo, {}),
      label: t("bbm.video"),
      content: /* @__PURE__ */ jsx(InnerTabs.Video, {}),
      availableFor: ["video"],
      isEnable: () => !!videoCaptureWorkflow
    },
    "audio-capture": {
      id: "audio-capture",
      icon: /* @__PURE__ */ jsx(Mic, {}),
      label: t("bbm.audio"),
      content: /* @__PURE__ */ jsx(InnerTabs.Audio, {}),
      availableFor: ["audio"],
      isEnable: () => !!workspaceCreateWorkflow
    },
    "external-link": {
      id: "external-link",
      icon: /* @__PURE__ */ jsx(Globe, {}),
      label: t("bbm.linker.ext"),
      content: /* @__PURE__ */ jsx(InnerTabs.ExternalLink, { ...linkTabProps.current }),
      availableFor: ["hyperlink"],
      isEnable: null
    },
    "internal-link": {
      id: "internal-link",
      icon: /* @__PURE__ */ jsx(Applications, {}),
      label: t("bbm.linker.int"),
      content: /* @__PURE__ */ jsx(InnerTabs.InternalLink, { ...linkTabProps.current }),
      availableFor: ["hyperlink"],
      isEnable: null
    },
    iframe: {
      id: "iframe",
      icon: /* @__PURE__ */ jsx(Code, {}),
      label: t("bbm.embed"),
      content: /* @__PURE__ */ jsx(InnerTabs.Iframe, {}),
      availableFor: ["embedder"],
      isEnable: null
    },
    "video-embedder": {
      id: "iframe",
      icon: /* @__PURE__ */ jsx(Code, {}),
      label: t("bbm.embed"),
      content: /* @__PURE__ */ jsx(InnerTabs.VideoEmbedder, {}),
      availableFor: ["video"],
      isEnable: null
    }
  }, tabs = useMemo(
    () => orderedTabs.map((key) => availableTabs[key]).filter((tab) => {
      var _a2;
      return ((_a2 = tab.isEnable) == null ? void 0 : _a2.call(tab)) !== !1 && (tab.availableFor.length === 0 || tab.availableFor.includes(type));
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [type]
  ), [defaultTabId, setDefaultTabId] = useState(), defaultTabIdx = useMemo(() => {
    const index = tabs.findIndex((t2) => t2.id === defaultTabId);
    return 0 > index || index >= tabs.length ? 0 : index;
  }, [tabs, defaultTabId]), [resultCounter, setResultCounter] = useState(), [result, setResult] = useState(), [deletionsOnCancel, setDeletionsOnCancel] = useState([]), [onSuccessAction, setPreSuccess] = useState();
  function setVisibleTab(tab) {
    throw tabs.findIndex((t2) => t2.id === tab) < 0 ? "tab.not.visible" : "not.implemented.yet";
  }
  function switchType(type2) {
    linkTabProps.current = void 0, setDefaultTabId(void 0), setType(type2);
  }
  const show = (type2) => {
    setType(type2);
  }, hide = () => {
    setType(null);
  }, showLink = (props) => {
    linkTabProps.current = props, !("resourceId" in props || "appPrefix" in props) && setDefaultTabId("external-link"), setType("hyperlink");
  };
  useEffect(() => {
    var _a2, _b;
    const typeKey = type || "none";
    !defaultTabId && typeof ((_a2 = mediaLibraryTypes[typeKey]) == null ? void 0 : _a2.defaultTab) == "string" && setDefaultTabId((_b = mediaLibraryTypes[typeKey]) == null ? void 0 : _b.defaultTab);
  }, [defaultTabId, type]);
  const modalHeader = t(((_a = mediaLibraryTypes[type ?? "none"]) == null ? void 0 : _a.title) ?? "bbm"), resetState = () => {
    linkTabProps.current = void 0, setResult(void 0), setResultCounter(void 0), setDefaultTabId(void 0), setPreSuccess(void 0), setDeletionsOnCancel([]);
  }, handleTabChange = (tab) => {
    onTabChange == null || onTabChange(tab, deletionsOnCancel), resetState();
  }, handleOnSuccess = useCallback(() => {
    const triggerSuccess = async (result2) => {
      result2 instanceof Array && ["protected", "public"].findIndex((v) => v === visibility) >= 0 && (result2 = await odeServices.workspace().transferDocuments(result2, appCode ?? "media-library", visibility)), onSuccess(result2);
    };
    onSuccessAction ? onSuccessAction().then((result2) => {
      triggerSuccess(result2);
    }) : result && triggerSuccess(result), resetState();
  }, [onSuccessAction, result, onSuccess, visibility, appCode]), handleOnCancel = () => {
    onCancel(deletionsOnCancel), resetState();
  };
  return type && /* @__PURE__ */ jsx(MediaLibraryContext.Provider, { value: {
    appCode,
    visibility,
    multiple,
    type,
    setResultCounter,
    setResult,
    setCancellable: (uploads) => setDeletionsOnCancel([...uploads]),
    setVisibleTab,
    switchType,
    setPreSuccess
  }, children: /* @__PURE__ */ jsxs(Modal$1, { id: "media-library", isOpen: type !== null, onModalClose: handleOnCancel, size: "lg", viewport: !0, scrollable: !0, children: [
    /* @__PURE__ */ jsx(Modal$1.Header, { onModalClose: handleOnCancel, children: modalHeader }),
    /* @__PURE__ */ jsx(Tabs, { items: tabs, defaultId: tabs[defaultTabIdx].id, onChange: handleTabChange, children: (currentItem) => /* @__PURE__ */ jsxs(Fragment, { children: [
      tabs.length > 1 && /* @__PURE__ */ jsx(Tabs.List, { className: "mt-16" }),
      /* @__PURE__ */ jsx(Modal$1.Body, { className: "d-flex", children: /* @__PURE__ */ jsx(Tabs.Panel, { currentItem, children: currentItem == null ? void 0 : currentItem.content }) })
    ] }) }),
    /* @__PURE__ */ jsxs(Modal$1.Footer, { children: [
      /* @__PURE__ */ jsx(Button, { type: "button", color: "tertiary", variant: "ghost", onClick: handleOnCancel, children: t("cancel") }),
      /* @__PURE__ */ jsx(Button, { type: "button", color: "primary", variant: "filled", disabled: typeof result > "u", onClick: handleOnSuccess, children: resultCounter && resultCounter > 1 ? t("addMultiple", {
        number: resultCounter
      }) : t("add") })
    ] })
  ] }) });
}), MediaLibrary$1 = MediaLibrary;
function PublishModal({
  isOpen,
  resourceId,
  onSuccess,
  onCancel
}) {
  const {
    appCode: application,
    currentApp
  } = useOdeClient(), {
    ref: mediaLibraryRef,
    libraryMedia,
    ...mediaLibraryHandlers
  } = useMediaLibrary$1(), {
    t
  } = useTranslation(), resource = useResource$1(application, resourceId), {
    control,
    cover,
    formState: {
      isDirty,
      isValid,
      isSubmitting
    },
    handleDeleteImage,
    handleSubmit,
    handleUploadImage,
    handlePublish,
    register,
    selectActivities,
    selectedActivities,
    selectedSubjectAreas,
    selectSubjects
  } = usePublishModal({
    resource,
    onSuccess
  }), defaultSelectAgeMinOption = "bpr.form.publication.age.min", defaultSelectAgeMaxOption = "bpr.form.publication.age.max";
  return resource ? /* @__PURE__ */ createPortal(/* @__PURE__ */ jsxs(Modal$1, { isOpen, onModalClose: onCancel, id: "libraryModal", size: "lg", children: [
    /* @__PURE__ */ jsx(Modal$1.Header, { onModalClose: onCancel, children: t("bpr.publish") }),
    /* @__PURE__ */ jsx(Modal$1.Subtitle, { children: t("bpr.form.tip") }),
    /* @__PURE__ */ jsxs(Modal$1.Body, { children: [
      /* @__PURE__ */ jsx(Heading, { headingStyle: "h4", level: "h3", className: "mb-16", children: t("bpr.form.publication.heading.general") }),
      /* @__PURE__ */ jsxs("form", { id: "libraryModalForm", onSubmit: handleSubmit(handlePublish), children: [
        /* @__PURE__ */ jsxs("div", { className: "d-block d-md-flex mb-24 gap-24", children: [
          /* @__PURE__ */ jsxs("div", { style: {
            maxWidth: "160px"
          }, children: [
            /* @__PURE__ */ jsx("div", { className: "form-label", children: t("bpr.form.publication.cover.title") }),
            /* @__PURE__ */ jsx(ImagePickerWorkspace$1, { app: currentApp, src: resource == null ? void 0 : resource.thumbnail, addButtonLabel: t("bpr.form.publication.cover.upload.add"), deleteButtonLabel: t("bpr.form.publication.cover.upload.remove"), onUploadImage: handleUploadImage, onDeleteImage: handleDeleteImage, className: "align-self-center", libraryMedia, mediaLibraryRef }),
            !cover && /* @__PURE__ */ jsx("p", { className: "form-text is-invalid", children: /* @__PURE__ */ jsx("em", { children: t("bpr.form.publication.cover.upload.required.image") }) })
          ] }),
          /* @__PURE__ */ jsxs("div", { className: "flex-fill", children: [
            /* @__PURE__ */ jsxs(FormControl$1, { id: "title", className: "mb-16", isRequired: !0, children: [
              /* @__PURE__ */ jsx(Label$1, { children: t("bpr.form.publication.title") }),
              /* @__PURE__ */ jsx(Input$1, { type: "text", defaultValue: resource == null ? void 0 : resource.name, ...register("title", {
                required: !0
              }), placeholder: t("bpr.form.publication.title.placeholder"), size: "md", "aria-required": !0 })
            ] }),
            /* @__PURE__ */ jsxs(FormControl$1, { id: "description", isRequired: !0, children: [
              /* @__PURE__ */ jsx(Label$1, { children: t("bpr.form.publication.description") }),
              /* @__PURE__ */ jsx(TextArea$1, { ...register("description", {
                required: !0
              }), placeholder: t("bpr.form.publication.description.placeholder"), size: "md" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsx("hr", {}),
        /* @__PURE__ */ jsx(Heading, { headingStyle: "h4", level: "h3", className: "mb-16", children: t("bpr.form.publication.heading.infos") }),
        /* @__PURE__ */ jsxs("div", { className: "d-flex flex-column flex-md-row gap-16 row mb-24", children: [
          /* @__PURE__ */ jsx(ActivitiesDropdown, { control, selectedActivities, selectActivities }),
          /* @__PURE__ */ jsx(SubjectsDropdown, { control, selectedSubjectAreas, selectSubjects }),
          /* @__PURE__ */ jsx(LangSelect, { control })
        ] }),
        /* @__PURE__ */ jsxs("div", { className: "mb-24", children: [
          /* @__PURE__ */ jsx("label", { htmlFor: "", className: "form-label", children: t("bpr.form.publication.age") }),
          /* @__PURE__ */ jsxs("div", { className: "d-flex gap-8", children: [
            /* @__PURE__ */ jsx("div", { className: "col col-md-2 d-flex", children: /* @__PURE__ */ jsx(AgeSelect, { control, name: "ageMin", placeholderOption: defaultSelectAgeMinOption, validate: (value, formValues) => parseInt(value) <= parseInt(formValues.ageMax) }) }),
            /* @__PURE__ */ jsx("div", { className: "col col-md-2 d-flex", children: /* @__PURE__ */ jsx(AgeSelect, { control, name: "ageMax", placeholderOption: defaultSelectAgeMaxOption, validate: (value, formValues) => parseInt(value) >= parseInt(formValues.ageMin) }) })
          ] })
        ] }),
        /* @__PURE__ */ jsx("div", { className: "mb-24", children: /* @__PURE__ */ jsxs(FormControl$1, { id: "keywords", isOptional: !0, children: [
          /* @__PURE__ */ jsx(Label$1, { children: t("bpr.form.publication.keywords") }),
          /* @__PURE__ */ jsx(Input$1, { type: "text", ...register("keyWords"), size: "md", placeholder: t("bpr.form.publication.keywords.placeholder") })
        ] }) }),
        /* @__PURE__ */ jsx("hr", {}),
        /* @__PURE__ */ jsx(Heading, { headingStyle: "h4", level: "h3", className: "mb-16", children: t("bpr.form.publication.licence.text") }),
        /* @__PURE__ */ jsx(PublishModalFooter, {})
      ] })
    ] }),
    /* @__PURE__ */ jsxs(Modal$1.Footer, { children: [
      /* @__PURE__ */ jsx(Button, { color: "tertiary", onClick: onCancel, type: "button", variant: "ghost", children: t("cancel") }),
      /* @__PURE__ */ jsx(Button, { form: "libraryModalForm", type: "submit", color: "primary", variant: "filled", isLoading: isSubmitting, disabled: !cover || isSubmitting || !isDirty || !isValid, children: t("bpr.form.submit") })
    ] }),
    /* @__PURE__ */ jsx(MediaLibrary$1, { appCode: application, ref: mediaLibraryRef, multiple: !1, visibility: "protected", ...mediaLibraryHandlers })
  ] }), document.getElementById("portal")) : /* @__PURE__ */ jsx(LoadingScreen$1, {});
}
const TextareaCounter = ({
  content,
  maxLength
}) => /* @__PURE__ */ jsx("p", { className: "small text-gray-700 p-2 text-end", children: content ? `${content.length} / ${maxLength}` : "" }), useThumb = ({
  isUpdating,
  selectedResource
}) => {
  const [thumbnail, setThumbnail] = useState(isUpdating && (selectedResource == null ? void 0 : selectedResource.thumbnail) || "");
  return useEffect(() => {
    setThumbnail((selectedResource == null ? void 0 : selectedResource.thumbnail) || "");
  }, [selectedResource]), {
    thumbnail,
    handleDeleteImage: () => setThumbnail(""),
    handleUploadImage: (file) => setThumbnail(file)
  };
}, DEFAULT_INPUT_MAX_LENGTH = 60, DEFAULT_TEXTAREA_MAX_LENGTH = 400, ResourceModal = ({
  isOpen,
  onCancel,
  onSuccess,
  children,
  inputMaxLength = DEFAULT_INPUT_MAX_LENGTH,
  textareaMaxLength = DEFAULT_TEXTAREA_MAX_LENGTH,
  ...props
}) => {
  const {
    appCode: application,
    currentApp
  } = useOdeClient(), {
    t
  } = useTranslation(), {
    mode
  } = props, toast2 = useToast(), formId = useId(), isCreating = mode === "create", isUpdating = mode === "update", resource = useResource$1(application, isUpdating ? props.resourceId : ""), {
    watch,
    register,
    handleSubmit,
    setValue,
    formState: {
      isSubmitting,
      isValid
    }
  } = useForm({
    mode: "onChange",
    defaultValues: {
      description: isUpdating ? resource == null ? void 0 : resource.description : "",
      enablePublic: isUpdating ? resource == null ? void 0 : resource.public : !1,
      title: isUpdating ? resource == null ? void 0 : resource.name : "",
      formSlug: isUpdating ? resource == null ? void 0 : resource.slug : ""
    }
  }), {
    ref: mediaLibraryRef,
    libraryMedia,
    ...mediaLibraryHandlers
  } = useMediaLibrary$1(), {
    appCode
  } = useOdeClient(), {
    thumbnail,
    handleDeleteImage,
    handleUploadImage
  } = useThumb({
    isUpdating,
    selectedResource: isUpdating ? resource : void 0
  }), watchedDescription = watch("description"), onSubmit = async function(formData) {
    var _a, _b;
    try {
      const data = {
        description: formData.description || "",
        name: formData.title,
        public: formData.enablePublic,
        slug: formData.enablePublic && formData.formSlug || "",
        thumbnail
      };
      if (isCreating) {
        const createParams = {
          ...data,
          folder: props.currentFolder === void 0 || // Fix #WB2-1296: when searching, currentFolder is undefined
          ((_a = props.currentFolder) == null ? void 0 : _a.id) === "default" ? void 0 : parseInt(((_b = props.currentFolder) == null ? void 0 : _b.id) || ""),
          application
        };
        props.createResource ? await props.createResource.mutateAsync(createParams) : await odeServices.resource(application).create(createParams);
      } else {
        const updateParams = {
          ...data,
          entId: resource.assetId,
          trashed: resource.trashed
        };
        props.updateResource ? await props.updateResource.mutateAsync(updateParams) : await odeServices.resource(application).update(updateParams);
      }
      toast2.success(/* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("strong", { children: t(isCreating ? "explorer.resource.created" : "explorer.resource.updated") }),
        /* @__PURE__ */ jsxs("p", { children: [
          t("title"),
          " : ",
          formData.title
        ] }),
        /* @__PURE__ */ jsxs("p", { children: [
          t("description"),
          " : ",
          formData.description
        ] }),
        application === "blog" && /* @__PURE__ */ jsxs("p", { children: [
          "Public:",
          formData.enablePublic ? t("explorer.enable.public.yes") : t("explorer.enable.public.no")
        ] })
      ] })), onSuccess();
    } catch (e2) {
      console.error(e2);
    }
  };
  return isUpdating && !resource ? /* @__PURE__ */ jsx(LoadingScreen$1, {}) : /* @__PURE__ */ createPortal(/* @__PURE__ */ jsxs(Modal$1, { id: `${mode}-resource`, size: "lg", isOpen, onModalClose: onCancel, children: [
    /* @__PURE__ */ jsx(Modal$1.Header, { onModalClose: onCancel, children: t(`explorer.resource.editModal.header.${isCreating ? "create" : "edit"}`) }),
    /* @__PURE__ */ jsxs(Modal$1.Body, { children: [
      /* @__PURE__ */ jsx(Heading, { headingStyle: "h4", level: "h3", className: "mb-16", children: t("explorer.resource.editModal.heading.general") }),
      /* @__PURE__ */ jsxs("form", { id: formId, onSubmit: handleSubmit(onSubmit), children: [
        /* @__PURE__ */ jsxs("div", { className: "d-block d-md-flex gap-16 mb-24", children: [
          /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(ImagePickerWorkspace$1, { app: currentApp, src: isUpdating && (resource == null ? void 0 : resource.thumbnail) || "", addButtonLabel: t("explorer.imagepicker.button.add"), deleteButtonLabel: t("explorer.imagepicker.button.delete"), onUploadImage: handleUploadImage, onDeleteImage: handleDeleteImage, className: "align-self-center mt-8", libraryMedia, mediaLibraryRef }) }),
          /* @__PURE__ */ jsxs("div", { className: "col", children: [
            /* @__PURE__ */ jsxs(FormControl$1, { id: "title", className: "mb-16", isRequired: !0, children: [
              /* @__PURE__ */ jsx(Label$1, { children: t("title") }),
              /* @__PURE__ */ jsx(Input$1, { type: "text", defaultValue: isUpdating ? resource == null ? void 0 : resource.name : "", ...register("title", {
                required: !0,
                maxLength: inputMaxLength,
                pattern: {
                  value: /[^ ]/,
                  message: "invalid title"
                }
              }), placeholder: t("explorer.resource.editModal.title.placeholder"), size: "md", "aria-required": !0, maxLength: inputMaxLength })
            ] }),
            /* @__PURE__ */ jsxs(FormControl$1, { id: "description", isOptional: !0, children: [
              /* @__PURE__ */ jsx(Label$1, { children: t("description") }),
              /* @__PURE__ */ jsx(TextArea$1, { defaultValue: (resource == null ? void 0 : resource.description) || "", ...register("description", {
                required: !1,
                maxLength: textareaMaxLength
              }), placeholder: t("explorer.resource.editModal.description.placeholder"), size: "md", maxLength: textareaMaxLength }),
              watchedDescription && /* @__PURE__ */ jsx(TextareaCounter, { content: watchedDescription, maxLength: textareaMaxLength })
            ] })
          ] })
        ] }),
        typeof children == "function" ? children(resource, isUpdating, watch, setValue, register) : children
      ] })
    ] }),
    /* @__PURE__ */ jsxs(Modal$1.Footer, { children: [
      /* @__PURE__ */ jsx(Button, { color: "tertiary", onClick: onCancel, type: "button", variant: "ghost", children: t("explorer.cancel") }),
      /* @__PURE__ */ jsx(Button, { form: formId, type: "submit", color: "primary", isLoading: isSubmitting, variant: "filled", disabled: !isValid || isSubmitting, children: t(isCreating ? "explorer.create" : "save") })
    ] }),
    /* @__PURE__ */ jsx(MediaLibrary$1, { appCode, ref: mediaLibraryRef, multiple: !1, visibility: "protected", ...mediaLibraryHandlers })
  ] }), document.getElementById("portal"));
}, ResourceModal$1 = ResourceModal, useUpdateMutation = ({
  application,
  options
}) => useMutation({
  mutationFn: async (params) => await odeServices.resource(application).update(params),
  ...options
}), useUpdateMutation$1 = useUpdateMutation, useSlug = ({
  watch,
  setValue,
  selectedResource
}) => {
  const [slug, setSlug] = useState(""), [isPublic, setIsPublic] = useState((selectedResource == null ? void 0 : selectedResource.public) || !1), uniqueId = useId(), resourceName = watch("title"), {
    t
  } = useTranslation(), toast2 = useToast();
  useEffect(() => {
    if (isPublic) {
      let slug2 = "";
      selectedResource ? slug2 = selectedResource.slug ? selectedResource.slug : `${hash({
        foo: `${resourceName}${uniqueId}`
      })}-${slugify(resourceName)}` : slug2 = `${hash({
        foo: `${resourceName}${uniqueId}`
      })}-${slugify(resourceName)}`, setValue("formSlug", slug2), setSlug(slug2);
    }
  }, [isPublic, resourceName]);
  function onPublicChange(value) {
    setIsPublic(value);
  }
  function onCopyToClipBoard(pathname) {
    navigator.clipboard.writeText(`${window.location.origin}${pathname || window.location.pathname}/pub/${slug}`), toast2.success(t("explorer.copy.clipboard"));
  }
  return {
    slug,
    uniqueId,
    isPublic,
    resourceName,
    onPublicChange,
    onCopyToClipBoard
  };
}, BlogPublic = ({
  appCode,
  isUpdating,
  resource,
  watch,
  register,
  setValue
}) => {
  const {
    t
  } = useTranslation(), {
    slug,
    isPublic,
    resourceName,
    onPublicChange,
    onCopyToClipBoard
  } = useSlug({
    watch,
    setValue,
    selectedResource: isUpdating ? resource : void 0
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(Heading, { headingStyle: "h4", level: "h3", className: "mb-16", children: [
      t("explorer.resource.editModal.heading.access"),
      appCode
    ] }),
    /* @__PURE__ */ jsx(Alert$1, { type: "info", children: t("explorer.resource.editModal.access.alert") }),
    /* @__PURE__ */ jsxs(FormControl$1, { id: "flexSwitchCheckDefault", className: "form-switch d-flex gap-8 mt-16 mb-8", children: [
      /* @__PURE__ */ jsx(FormControl$1.Input, { type: "checkbox", role: "switch", defaultChecked: isUpdating ? resource.public : !1, ...register("enablePublic", {
        disabled: !resourceName,
        onChange: (event) => {
          const checked = event.target.checked;
          onPublicChange(checked);
        }
      }), className: "form-check-input mt-0", size: "md" }),
      /* @__PURE__ */ jsx(FormControl$1.Label, { className: "form-check-label mb-0", children: t("explorer.resource.editModal.access.flexSwitchCheckDefault.label") })
    ] }),
    isPublic && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(FormControl$1, { id: "formSlug", children: /* @__PURE__ */ jsx(Input$1, { type: "text", hidden: !0, defaultValue: isUpdating ? slug : "", ...register("formSlug"), size: "sm" }) }, slug),
      /* @__PURE__ */ jsxs("div", { className: "d-flex flex-wrap align-items-center gap-4", children: [
        /* @__PURE__ */ jsxs("p", { className: "text-break", children: [
          window.location.origin,
          "/blog/pub/",
          slug
        ] }),
        /* @__PURE__ */ jsx(Button, { color: "primary", disabled: !isPublic, onClick: () => onCopyToClipBoard("/blog"), type: "button", leftIcon: /* @__PURE__ */ jsx(Copy, {}), variant: "ghost", className: "text-nowrap", children: t("explorer.resource.editModal.access.url.button") })
      ] })
    ] })
  ] });
}, BlogPublic$1 = BlogPublic, ShareBookmark = ({
  bookmark,
  refBookmark,
  onBookmarkChange,
  onSave
}) => {
  const {
    t
  } = useTranslation();
  return /* @__PURE__ */ jsx("div", { className: "mt-16", children: /* @__PURE__ */ jsxs(FormControl$1, { id: "bookmarkName", className: "d-flex flex-wrap align-items-center gap-16", children: [
    /* @__PURE__ */ jsx("div", { className: "flex-fill", children: /* @__PURE__ */ jsx(FormControl$1.Input, { ref: refBookmark, onChange: onBookmarkChange, placeholder: t("explorer.modal.share.sharebookmark.placeholder"), size: "sm", type: "text" }, bookmark.id) }),
    /* @__PURE__ */ jsx(Button, { type: "button", color: "primary", variant: "ghost", disabled: bookmark.name.length === 0, leftIcon: /* @__PURE__ */ jsx(Save, {}), onClick: onSave, className: "text-nowrap", children: t("explorer.modal.share.sharebookmark.save") })
  ] }) });
}, hasRight = (shareRight, shareAction) => shareRight.actions.filter((a) => shareAction.id === a.id).length > 0, showShareRightLine = (shareRight, showBookmarkMembers) => shareRight.isBookmarkMember && showBookmarkMembers || !shareRight.isBookmarkMember, ShareBookmarkLine = ({
  shareRights,
  showBookmark,
  toggleBookmark,
  shareRightActions,
  toggleRight,
  onDeleteRow
}) => {
  const {
    t
  } = useTranslation();
  return shareRights == null ? void 0 : shareRights.rights.map((shareRight) => {
    const selectedAvatar = {
      user: /* @__PURE__ */ jsx(Avatar, { alt: t("explorer.modal.share.avatar.shared.alt"), size: "xs", src: shareRight.avatarUrl, variant: "circle" }),
      group: /* @__PURE__ */ jsx("div", { className: "avatar-xs bg-primary-200 justify-content-center d-flex rounded-circle", children: /* @__PURE__ */ jsx(Users, { width: 16 }) }),
      sharebookmark: /* @__PURE__ */ jsx(Bookmark, {})
    }[shareRight.type] || null, isTypeBookmark = shareRight.type === "sharebookmark", isTypeUser = shareRight.type === "user";
    return showShareRightLine(shareRight, showBookmark) && /* @__PURE__ */ jsxs("tr", { className: shareRight.isBookmarkMember ? "bg-light" : "", children: [
      /* @__PURE__ */ jsx("td", { children: selectedAvatar }),
      /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsxs("div", { className: "d-flex", children: [
        isTypeBookmark && /* @__PURE__ */ jsx(Button, { color: "tertiary", rightIcon: /* @__PURE__ */ jsx(RafterDown, { title: t("show"), className: "w-16 min-w-0", style: {
          transition: "rotate 0.2s ease-out",
          rotate: showBookmark ? "-180deg" : "0deg"
        } }), type: "button", variant: "ghost", className: "fw-normal ps-0", onClick: toggleBookmark, children: shareRight.displayName }),
        !isTypeBookmark && shareRight.displayName,
        isTypeUser && ` (${t(shareRight.profile || "")})`
      ] }) }),
      shareRightActions.map((shareRightAction) => /* @__PURE__ */ jsx("td", { style: {
        width: "80px"
      }, className: "text-center text-white", children: /* @__PURE__ */ jsx(Checkbox$1, { checked: hasRight(shareRight, shareRightAction), onChange: () => toggleRight(shareRight, shareRightAction.id) }) }, shareRightAction.displayName)),
      /* @__PURE__ */ jsx("td", { children: !shareRight.isBookmarkMember && /* @__PURE__ */ jsx(IconButton$1, { "aria-label": t("close"), color: "tertiary", icon: /* @__PURE__ */ jsx(Close, {}), type: "button", variant: "ghost", title: t("close"), onClick: () => onDeleteRow(shareRight) }) })
    ] }, shareRight.id);
  });
}, initialState$1 = {
  searchInputValue: "",
  searchResults: [],
  searchAPIResults: [],
  isSearching: !1
};
function reducer$1(state, action) {
  switch (action.type) {
    case "onChange":
      return {
        ...state,
        searchInputValue: action.payload
      };
    case "isSearching":
      return {
        ...state,
        isSearching: action.payload
      };
    case "addResult":
      return {
        ...state,
        searchResults: action.payload
      };
    case "addApiResult":
      return {
        ...state,
        searchAPIResults: action.payload
      };
    case "updateSearchResult":
      return {
        ...state,
        searchResults: action.payload
      };
    case "emptyResult":
      return {
        ...state,
        searchResults: action.payload
      };
    default:
      throw new Error("Unhandled action type");
  }
}
const defaultActions = [{
  id: "read",
  displayName: "read"
}, {
  id: "comment",
  displayName: "comment"
}], useSearch = ({
  resourceId,
  resourceCreatorId,
  shareRights,
  shareDispatch
}) => {
  const [state, dispatch] = useReducer(reducer$1, initialState$1), debouncedSearchInputValue = useDebounce(state.searchInputValue, 500), {
    isAdml
  } = useIsAdml(), {
    appCode
  } = useOdeClient(), {
    t
  } = useTranslation();
  useEffect(() => {
    search(debouncedSearchInputValue);
  }, [debouncedSearchInputValue]);
  const handleSearchInputChange = (event) => {
    const value = event.target.value;
    dispatch({
      type: "onChange",
      payload: value
    });
  }, search = async (debouncedSearchInputValue2) => {
    if (resourceId) {
      if (dispatch({
        type: "isSearching",
        payload: !0
      }), !isAdml && debouncedSearchInputValue2.length >= 1 || isAdml && debouncedSearchInputValue2.length >= 3) {
        const resSearchShareSubjects = await odeServices.share().searchShareSubjects(appCode, resourceId, debouncedSearchInputValue2);
        dispatch({
          type: "addApiResult",
          payload: resSearchShareSubjects
        });
        const adaptedResults = resSearchShareSubjects.filter((right) => !shareRights.rights.find((shareRight) => shareRight.id === right.id)).filter((right) => !(right.type === "user" && right.id === resourceCreatorId)).map((searchResult) => {
          let label = searchResult.displayName;
          return searchResult.type === "user" && searchResult.profile ? label = `${label} (${t(searchResult.profile)})` : searchResult.type === "group" && searchResult.structureName && (label = `${label} (${searchResult.structureName})`), {
            value: searchResult.id,
            label,
            icon: searchResult.type === "sharebookmark" ? /* @__PURE__ */ jsx(Bookmark, {}) : null
          };
        });
        dispatch({
          type: "addResult",
          payload: adaptedResults
        });
      } else
        dispatch({
          type: "emptyResult",
          payload: []
        }), Promise.resolve();
      dispatch({
        type: "isSearching",
        payload: !1
      });
    }
  };
  return {
    state,
    showSearchAdmlHint: () => isAdml && state.searchInputValue.length < 3,
    showSearchLoading: () => state.isSearching,
    showSearchNoResults: () => !state.isSearching && !isAdml && debouncedSearchInputValue.length > 0 && state.searchResults.length === 0 || !state.isSearching && isAdml && debouncedSearchInputValue.length > 3 && state.searchResults.length === 0,
    getSearchMinLength: () => isAdml ? 3 : 1,
    handleSearchInputChange,
    handleSearchResultsChange: async (model) => {
      const shareSubject = state.searchAPIResults.find((searchAPIResult) => searchAPIResult.id === model[0]);
      if (shareSubject) {
        let rightsToAdd = [];
        if (shareSubject.type === "sharebookmark") {
          const bookmarkRes = await odeServices.directory().getBookMarkById(shareSubject.id);
          rightsToAdd.push({
            ...bookmarkRes,
            type: "sharebookmark",
            avatarUrl: "",
            directoryUrl: "",
            actions: defaultActions
          }), bookmarkRes == null || bookmarkRes.users.filter((user) => !shareRights.rights.find((right) => right.id === user.id)).forEach((user) => {
            rightsToAdd.push({
              ...user,
              type: "user",
              avatarUrl: "",
              directoryUrl: "",
              actions: defaultActions,
              isBookmarkMember: !0
            });
          }), bookmarkRes.groups.filter((group) => !shareRights.rights.find((right) => right.id === group.id)).forEach((group) => {
            rightsToAdd.push({
              ...group,
              type: "group",
              avatarUrl: "",
              directoryUrl: "",
              actions: defaultActions,
              isBookmarkMember: !0
            });
          });
        } else
          rightsToAdd = [{
            ...shareSubject,
            actions: [{
              id: "read",
              displayName: "read"
            }, {
              id: "comment",
              displayName: "comment"
            }]
          }];
        shareDispatch({
          type: "updateShareRights",
          payload: {
            ...shareRights,
            rights: [...shareRights.rights, ...rightsToAdd]
          }
        }), dispatch({
          type: "updateSearchResult",
          payload: state.searchResults.filter((result) => result.value !== model[0])
        });
      }
    }
  };
}, initialState = {
  isSharing: !1,
  shareRights: {
    rights: [],
    visibleBookmarks: [],
    visibleGroups: [],
    visibleUsers: []
  },
  shareRightActions: []
};
function reducer(state, action) {
  switch (action.type) {
    case "init":
      return {
        ...state,
        ...action.payload
      };
    case "deleteRow":
      return {
        ...state,
        shareRights: action.payload
      };
    case "updateShareRights":
      return {
        ...state,
        shareRights: action.payload
      };
    case "toggleRight":
      return {
        ...state,
        shareRights: action.payload
      };
    case "isSharing":
      return {
        ...state,
        isSharing: action.payload
      };
    default:
      throw new Error("Unhandled action type");
  }
}
function useShare({
  resourceId,
  resourceRights,
  resourceCreatorId,
  shareResource,
  setIsLoading,
  onSuccess
}) {
  const {
    appCode
  } = useOdeClient(), {
    user,
    avatar
  } = useUser(), toast2 = useToast(), {
    t
  } = useTranslation(), [state, dispatch] = useReducer(reducer, initialState);
  useEffect(() => {
    resourceId && (async () => {
      try {
        const [shareRightActions, shareRights] = await Promise.all([odeServices.share().getActionsForApp(appCode), odeServices.share().getRightsForResource(appCode, resourceId)]);
        dispatch({
          type: "init",
          payload: {
            shareRightActions,
            shareRights
          }
        });
      } catch (error) {
        console.error(error);
      }
      setIsLoading(!1);
    })();
  }, [resourceId]);
  const toggleRight = (shareRight, actionName) => {
    var _a, _b;
    const {
      rights,
      ...props
    } = state.shareRights, newShareRights = [...rights], index = newShareRights.findIndex((x) => x.id === shareRight.id), actionObject = state.shareRightActions.filter((shareRightAction) => shareRightAction.id === actionName)[0];
    if (newShareRights[index].actions.findIndex((action) => action.id === actionName) > -1) {
      let updatedActions = newShareRights[index].actions.filter((action) => action.id !== actionName);
      const requiredActions = state.shareRightActions.filter((shareRightAction) => {
        var _a2;
        return (_a2 = shareRightAction.requires) == null ? void 0 : _a2.includes(actionName);
      });
      updatedActions = updatedActions.filter((action) => !requiredActions.find((requiredAction) => requiredAction.id === action.id)), newShareRights[index] = {
        ...newShareRights[index],
        actions: updatedActions
      };
    } else {
      const requiredActions = state.shareRightActions.filter((shareRightAction) => {
        var _a2;
        return ((_a2 = actionObject.requires) == null ? void 0 : _a2.includes(shareRightAction.id)) && !newShareRights[index].actions.find((action) => action.id === shareRightAction.id);
      });
      newShareRights[index] = {
        ...newShareRights[index],
        actions: [...newShareRights[index].actions, actionObject, ...requiredActions]
      };
    }
    shareRight.type === "sharebookmark" && ((_a = newShareRights[index].users) == null || _a.forEach((user2) => {
      const userIndex = newShareRights.findIndex((item) => item.id === user2.id);
      newShareRights[userIndex] = {
        ...newShareRights[userIndex],
        actions: newShareRights[index].actions
      };
    }), (_b = newShareRights[index].groups) == null || _b.forEach((user2) => {
      const userIndex = newShareRights.findIndex((item) => item.id === user2.id);
      newShareRights[userIndex] = {
        ...newShareRights[userIndex],
        actions: newShareRights[index].actions
      };
    })), dispatch({
      type: "toggleRight",
      payload: {
        rights: newShareRights,
        ...props
      }
    });
  }, notifySuccess = (value) => {
    Object.keys(value)[0] === "error" ? (toast2.error(t("explorer.shared.status.error")), console.error("Failed to save share", value)) : toast2.success(t("explorer.shared.status.saved"));
  };
  return {
    state,
    dispatch,
    currentIsAuthor: () => resourceCreatorId === (user == null ? void 0 : user.userId),
    myAvatar: avatar,
    handleDeleteRow: (shareRight) => {
      dispatch({
        type: "deleteRow",
        payload: {
          ...state.shareRights,
          rights: state.shareRights.rights.filter((right) => {
            var _a, _b;
            return right.id !== shareRight.id && !((_a = shareRight.users) != null && _a.find((user2) => user2.id === right.id)) && !((_b = shareRight.groups) != null && _b.find((group) => group.id === right.id));
          })
        }
      });
    },
    handleShare: async () => {
      dispatch({
        type: "isSharing",
        payload: !0
      });
      try {
        const myRights = resourceRights.filter((right) => user && right.includes(`user:${user.userId}`)).map((right) => right.split(":")[2]).filter((right) => !!right), shares = [...state.shareRights.rights];
        if (myRights.length > 0) {
          const actions = myRights.map((right) => ({
            displayName: right,
            id: right
          }));
          shares.push({
            actions,
            avatarUrl: "",
            directoryUrl: "",
            displayName: user.username,
            id: user.userId,
            type: "user"
          });
        }
        if (shareResource) {
          const result = await shareResource.mutateAsync({
            resourceId,
            rights: shares
          });
          notifySuccess(result);
        } else {
          const result = await odeServices.share().saveRights(appCode, resourceId, shares);
          notifySuccess(result);
        }
        onSuccess();
      } catch (error) {
        typeof error == "string" && toast2.error(t("explorer.shared.status.error")), console.error("Failed to save share", error);
      } finally {
        dispatch({
          type: "isSharing",
          payload: !1
        });
      }
    },
    toggleRight
  };
}
const useShareBookmark = ({
  shareRights,
  shareDispatch
}) => {
  const toast2 = useToast(), {
    t
  } = useTranslation(), refBookmark = useRef(null), [bookmark, setBookmark] = useState({
    name: "",
    id: useId()
  }), [showBookmark, setShowBookmark] = useToggle(!1), [showBookmarkInput, toggleBookmarkInput] = useState(!1), toggleBookmark = () => {
    setShowBookmark();
  }, handleBookmarkChange = () => {
    setBookmark((prev) => {
      var _a;
      return {
        ...prev,
        name: ((_a = refBookmark.current) == null ? void 0 : _a.value) || ""
      };
    });
  }, saveBookmark = async (name) => {
    try {
      const res = await odeServices.directory().saveBookmarks(name, {
        users: shareRights.rights.filter((right) => right.type === "user").map((u) => u.id),
        groups: shareRights.rights.filter((right) => right.type === "group").map((u) => u.id),
        bookmarks: shareRights.rights.filter((right) => right.type === "sharebookmark").map((u) => u.id)
      });
      toast2.success(t("explorer.bookmarked.status.saved")), shareDispatch({
        type: "updateShareRights",
        payload: {
          ...shareRights,
          visibleBookmarks: [...shareRights.visibleBookmarks, {
            displayName: name,
            id: res.id
          }]
        }
      }), setBookmark((prev) => ({
        ...prev,
        bookmarkId: prev.id + (/* @__PURE__ */ new Date()).getTime().toString()
      })), toggleBookmarkInput(!1);
    } catch (e2) {
      console.error("Failed to save bookmark", e2), toast2.error(t("explorer.bookmarked.status.error"));
    }
  };
  return {
    refBookmark,
    showBookmark,
    showBookmarkInput,
    bookmark,
    handleBookmarkChange,
    setBookmark,
    handleOnSave: () => {
      var _a;
      const inputValue = ((_a = refBookmark.current) == null ? void 0 : _a.value) || "";
      saveBookmark(inputValue);
    },
    toggleBookmark,
    toggleBookmarkInput
  };
};
function ShareResourceModal({
  isOpen,
  shareOptions,
  shareResource,
  children,
  onSuccess,
  onCancel
}) {
  const {
    resourceId,
    resourceCreatorId,
    resourceRights
  } = shareOptions, [isLoading, setIsLoading] = useState(!0), {
    state: {
      isSharing,
      shareRights,
      shareRightActions
    },
    dispatch: shareDispatch,
    myAvatar,
    currentIsAuthor,
    handleShare,
    toggleRight,
    handleDeleteRow
  } = useShare({
    resourceId,
    resourceCreatorId,
    resourceRights,
    shareResource,
    setIsLoading,
    onSuccess
  }), {
    state: {
      searchResults,
      searchInputValue
    },
    showSearchAdmlHint,
    showSearchLoading,
    showSearchNoResults,
    getSearchMinLength,
    handleSearchInputChange,
    handleSearchResultsChange
  } = useSearch({
    resourceId,
    resourceCreatorId,
    shareRights,
    shareDispatch
  }), {
    refBookmark,
    showBookmark,
    handleBookmarkChange,
    toggleBookmark,
    bookmark,
    handleOnSave,
    showBookmarkInput,
    toggleBookmarkInput
  } = useShareBookmark({
    shareRights,
    shareDispatch
  }), {
    t
  } = useTranslation(), searchPlaceholder = showSearchAdmlHint() ? t("explorer.search.adml.hint") : t("explorer.modal.share.search.placeholder");
  return /* @__PURE__ */ createPortal(/* @__PURE__ */ jsxs(Modal$1, { id: "share_modal", size: "lg", isOpen, onModalClose: onCancel, children: [
    /* @__PURE__ */ jsx(Modal$1.Header, { onModalClose: onCancel, children: t("share.title") }),
    /* @__PURE__ */ jsxs(Modal$1.Body, { children: [
      /* @__PURE__ */ jsx(Heading, { headingStyle: "h4", level: "h3", className: "mb-16", children: t("explorer.modal.share.usersWithAccess") }),
      /* @__PURE__ */ jsx("div", { className: "table-responsive", children: isLoading ? /* @__PURE__ */ jsx(LoadingScreen$1, {}) : /* @__PURE__ */ jsxs("table", { className: "table border align-middle mb-0", children: [
        /* @__PURE__ */ jsx("thead", { className: "bg-secondary", children: /* @__PURE__ */ jsxs("tr", { children: [
          /* @__PURE__ */ jsx("th", { scope: "col", className: "w-32", children: /* @__PURE__ */ jsx(VisuallyHidden$1, { children: t("explorer.modal.share.avatar.shared.alt") }) }),
          /* @__PURE__ */ jsx("th", { scope: "col", children: /* @__PURE__ */ jsx(VisuallyHidden$1, { children: t("explorer.modal.share.search.placeholder") }) }),
          shareRightActions.map((shareRightAction) => /* @__PURE__ */ jsx("th", { scope: "col", className: "text-center text-white", children: t(shareRightAction.displayName) }, shareRightAction.displayName)),
          /* @__PURE__ */ jsx("th", { scope: "col", children: /* @__PURE__ */ jsx(VisuallyHidden$1, { children: t("close") }) })
        ] }) }),
        /* @__PURE__ */ jsxs("tbody", { children: [
          currentIsAuthor() && /* @__PURE__ */ jsxs("tr", { children: [
            /* @__PURE__ */ jsx("th", { scope: "row", children: /* @__PURE__ */ jsx(Avatar, { alt: t("explorer.modal.share.avatar.me.alt"), size: "xs", src: myAvatar, variant: "circle" }) }),
            /* @__PURE__ */ jsx("td", { children: t("share.me") }),
            shareRightActions.map((shareRightAction) => /* @__PURE__ */ jsx("td", { style: {
              width: "80px"
            }, className: "text-center text-white", children: /* @__PURE__ */ jsx(Checkbox$1, { checked: !0, disabled: !0 }) }, shareRightAction.displayName)),
            /* @__PURE__ */ jsx("td", {})
          ] }),
          /* @__PURE__ */ jsx(ShareBookmarkLine, { showBookmark, shareRightActions, shareRights, onDeleteRow: handleDeleteRow, toggleRight, toggleBookmark })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxs("div", { className: "mt-16", children: [
        /* @__PURE__ */ jsx(Button, { color: "tertiary", leftIcon: /* @__PURE__ */ jsx(Bookmark, {}), rightIcon: /* @__PURE__ */ jsx(RafterDown, { title: t("show"), className: "w-16 min-w-0", style: {
          transition: "rotate 0.2s ease-out",
          rotate: showBookmarkInput ? "-180deg" : "0deg"
        } }), type: "button", variant: "ghost", className: "fw-normal", onClick: () => toggleBookmarkInput(!showBookmarkInput), children: t("share.save.sharebookmark") }),
        showBookmarkInput && /* @__PURE__ */ jsx(ShareBookmark, { refBookmark, bookmark, onBookmarkChange: handleBookmarkChange, onSave: handleOnSave })
      ] }),
      /* @__PURE__ */ jsx("hr", {}),
      /* @__PURE__ */ jsxs(Heading, { headingStyle: "h4", level: "h3", className: "mb-16 d-flex align-items-center", children: [
        /* @__PURE__ */ jsx("div", { className: "me-8", children: t("explorer.modal.share.search") }),
        /* @__PURE__ */ jsx(Tooltip$1, { message: "Vos favoris de partage s’affichent en priorité dans votre liste lorsque vous recherchez un groupe ou une personne, vous pouvez les retrouver dans l’annuaire.", placement: "top", children: /* @__PURE__ */ jsx(InfoCircle, { className: "c-pointer", height: "18" }) })
      ] }),
      /* @__PURE__ */ jsx("div", { className: "row", children: /* @__PURE__ */ jsx("div", { className: "col-10", children: /* @__PURE__ */ jsx(Combobox$1, { value: searchInputValue, placeholder: searchPlaceholder, isLoading: showSearchLoading(), noResult: showSearchNoResults(), options: searchResults, searchMinLength: getSearchMinLength(), onSearchInputChange: handleSearchInputChange, onSearchResultsChange: handleSearchResultsChange }) }) }),
      children
    ] }),
    /* @__PURE__ */ jsxs(Modal$1.Footer, { children: [
      /* @__PURE__ */ jsx(Button, { type: "button", color: "tertiary", variant: "ghost", onClick: onCancel, children: t("explorer.cancel") }),
      /* @__PURE__ */ jsx(Button, { type: "button", color: "primary", variant: "filled", isLoading: isSharing, onClick: handleShare, disabled: isSharing, children: t("share") })
    ] })
  ] }), document.getElementById("portal"));
}
function ShareBlog({
  resourceId,
  updateResource
}) {
  const {
    appCode
  } = useOdeClient(), {
    t
  } = useTranslation(appCode), resource = useResource$1("blog", resourceId), publishType = resource && resource["publish-type"], [radioPublicationValue, setRadioPublicationValue] = useState(publishType ?? "RESTRAINT");
  useEffect(() => {
    publishType && setRadioPublicationValue(publishType);
  }, [publishType]);
  const handleRadioPublicationChange = async (event) => {
    const value = event.target.value, params = {
      description: resource.description || "",
      entId: resource.assetId,
      name: resource.name,
      public: !!resource.public,
      slug: resource.slug || "",
      thumbnail: resource.thumbnail,
      trashed: resource.trashed,
      "publish-type": value
    };
    updateResource ? await updateResource.mutateAsync(params) : await odeServices.resource("blog").update(params), setRadioPublicationValue(value);
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("hr", {}),
    /* @__PURE__ */ jsx(Heading, { headingStyle: "h4", level: "h3", className: "mb-16", children: t("explorer.publication.steps") }),
    /* @__PURE__ */ jsx(Radio$1, { label: t("explorer.immediat.publication"), id: "publication-now", name: "publication", value: "IMMEDIATE", model: radioPublicationValue, checked: radioPublicationValue === "IMMEDIATE", onChange: handleRadioPublicationChange }),
    /* @__PURE__ */ jsx(Radio$1, { label: t("explorer.validate.publication"), id: "publication-validate", name: "publication", value: "RESTRAINT", checked: radioPublicationValue === "RESTRAINT", model: radioPublicationValue, onChange: handleRadioPublicationChange })
  ] });
}
const useShareMutation = ({
  application,
  options
}) => useMutation({
  mutationFn: async ({
    resourceId,
    rights
  }) => await odeServices.share().saveRights(application, resourceId, rights),
  ...options
}), useShareMutation$1 = useShareMutation;
function usePreferences(name) {
  return {
    getPreference: async () => await odeServices.conf().getPreference(name),
    savePreference: async (value) => await odeServices.conf().savePreference(name, JSON.stringify(value))
  };
}
function useCookiesConsent() {
  const [showCookiesConsent, setShowCookiesConsent] = useState(!1), {
    getPreference,
    savePreference
  } = usePreferences("rgpdCookies");
  return useEffect(() => {
    (async () => {
      const res = await getPreference();
      setShowCookiesConsent(res === null ? !0 : res.showInfoTip);
    })();
  }, []), {
    showCookiesConsent,
    handleConsultCookies: () => {
      document.location.href = "/userbook/mon-compte", savePreference({
        showInfoTip: !1
      }), setShowCookiesConsent(!1);
    },
    handleCloseCookiesConsent: () => {
      savePreference({
        showInfoTip: !1
      }), setShowCookiesConsent(!1);
    }
  };
}
function Help({
  isHelpOpen,
  setIsHelpOpen,
  parsedHeadline,
  parsedContent,
  error
}) {
  const {
    t
  } = useTranslation(), handleHelpOpen = () => {
    setIsHelpOpen(!1);
  };
  return isHelpOpen ? /* @__PURE__ */ createPortal(/* @__PURE__ */ jsxs(Modal$1, { id: "help-modal", isOpen: isHelpOpen, onModalClose: handleHelpOpen, scrollable: !0, size: "lg", children: [
    /* @__PURE__ */ jsx(Modal$1.Header, { onModalClose: handleHelpOpen, children: t("navbar.help") }),
    /* @__PURE__ */ jsx(Modal$1.Subtitle, { children: error ? t("help.notfound.title") : parsedHeadline }),
    /* @__PURE__ */ jsx(Modal$1.Body, { className: error ? "d-flex" : null, children: error ? t("help.notfound.text") : parsedContent })
  ] }), document.getElementById("portal")) : null;
}
function useHelp() {
  var _a, _b, _c, _d, _e;
  const {
    appCode
  } = useOdeClient(), {
    theme
  } = useOdeTheme(), [html, setHtml] = useState(""), [visibility, setVisibility] = useState(!0), [isModalOpen, setIsModalOpen] = useState(!1), [error, setError] = useState(!1), helpPath = theme != null && theme.is1d ? "/help-1d" : "/help-2d";
  useEffect(() => {
    (async () => {
      let helpURL = "";
      helpURL = helpPath + "/application/" + appCode + "/", !appCode && window.location.pathname !== "/adapter" ? helpURL = helpPath + "/application/portal/" : window.location.pathname === "/adapter" ? helpURL = helpPath + "/application/" + window.location.search.split("eliot=")[1].split("&")[0] + "/" : window.location.pathname.includes("/directory/class-admin") ? helpURL = helpPath + "/application/parametrage-de-la-classe/" : (window.location.pathname.includes("/userbook/mon-compte") || window.location.pathname.includes("/timeline/preferencesView") || window.location.pathname.includes("/timeline/historyView")) && (helpURL = helpPath + "/application/userbook/");
      try {
        const res = await fetch(helpURL), html2 = await res.text();
        if (res.status === 404) {
          setError(!0);
          return;
        }
        setHtml(html2), setError(!1);
      } catch (error2) {
        setError(!0), console.error(error2);
      }
    })();
  }, [appCode, helpPath]);
  const parsedHTML = parse(html, {
    replace: (domNode) => {
      const typedDomNode = domNode;
      if (typedDomNode.attribs && typedDomNode.attribs.id === "TOC")
        return /* @__PURE__ */ jsxs("nav", { id: "TOC", children: [
          /* @__PURE__ */ jsx(Button, { onClick: () => {
            setVisibility(!visibility);
          }, children: /* @__PURE__ */ jsx(BurgerMenu, {}) }),
          domToReact(typedDomNode.children, {
            replace: (domNode2) => {
              const typedDomNode2 = domNode2;
              if (typedDomNode2.attribs && typedDomNode2.name === "ul")
                return /* @__PURE__ */ jsx("ul", { id: "TOC-list", style: {
                  display: visibility ? "block" : "none"
                }, children: domToReact(typedDomNode2.children, {
                  replace: (domNode3) => {
                    const typedDomNode3 = domNode3;
                    if (typedDomNode3.attribs && typedDomNode3.name === "a")
                      return /* @__PURE__ */ jsx("a", { ...attributesToProps(typedDomNode3.attribs), children: /* @__PURE__ */ jsx("span", { onClick: () => {
                        setVisibility(!1);
                      }, children: domToReact(typedDomNode3.children) }) });
                  }
                }) });
            }
          })
        ] });
      if (typedDomNode.attribs && typedDomNode.attribs.class === "section level2") {
        const props = attributesToProps(domNode.attribs);
        return /* @__PURE__ */ jsx("div", { ...props, className: "section level2", style: {
          display: typedDomNode.attribs.id !== "présentation" ? "none" : "block"
        }, children: domToReact(typedDomNode.children, {
          replace: (domNode2) => {
            const typedDomNode2 = domNode2;
            if (typedDomNode2.attribs && typedDomNode2.name === "img") {
              const attribs = domNode2.attribs.src;
              return /* @__PURE__ */ jsx("img", { ...attributesToProps(typedDomNode2.attribs), src: `${helpPath}/${attribs}`, alt: "" });
            }
          }
        }) });
      }
    }
  }), parsedContent = (_c = (_b = (_a = parsedHTML == null ? void 0 : parsedHTML.props) == null ? void 0 : _a.children.find((child) => child.type === "body")) == null ? void 0 : _b.props) == null ? void 0 : _c.children, parsedHeadline = (_e = (_d = parsedContent == null ? void 0 : parsedContent.find((child) => child.type === "p")) == null ? void 0 : _d.props) == null ? void 0 : _e.children;
  return {
    html,
    visibility,
    isModalOpen,
    setIsModalOpen,
    parsedContent,
    parsedHeadline,
    error
  };
}
const NavItem = /* @__PURE__ */ forwardRef(({
  children,
  className,
  ...restProps
}, ref) => {
  const classes = clsx("nav-item", className);
  return /* @__PURE__ */ jsx("li", { ref, className: classes, ...restProps, children });
}), SearchEngine = () => {
  const [searchRef, isSearchHovered] = useHover(), inputRef = useRef(null), popoverSearchId = useId(), {
    t
  } = useTranslation();
  function redirectToSearch() {
    if (inputRef.current) {
      const value = inputRef.current.value;
      window.location.href = `/searchengine#/${value}`;
    }
  }
  return /* @__PURE__ */ jsxs(NavItem, { id: popoverSearchId, ref: searchRef, className: "position-relative", "aria-haspopup": "true", "aria-expanded": isSearchHovered, children: [
    /* @__PURE__ */ jsxs("a", { href: "/searchengine", className: "nav-link dropdown-item", children: [
      /* @__PURE__ */ jsx(Search$1, { className: "icon search" }),
      /* @__PURE__ */ jsx("span", { className: "nav-text", children: t("navbar.search") })
    ] }),
    /* @__PURE__ */ jsx(Popover, { id: popoverSearchId, isVisible: isSearchHovered, className: "d-none d-md-flex", children: /* @__PURE__ */ jsxs(FormControl$1, { id: "my-search-input", className: "search-text input-group py-8 px-12", children: [
      /* @__PURE__ */ jsx(FormControl$1.Input, { ref: inputRef, size: "sm", type: "text", name: "my-search-input", placeholder: "Rechercher" }),
      /* @__PURE__ */ jsx(SearchButton$1, { type: "submit", size: "sm", onClick: redirectToSearch, "aria-label": t("navbar.search") })
    ] }) })
  ] });
}, SearchEngine$1 = SearchEngine;
function Navbar({
  children,
  className,
  ...restProps
}) {
  const classes = clsx("navbar", className);
  return /* @__PURE__ */ jsx("nav", { className: classes, ...restProps, children });
}
function NavBarNav({
  children,
  className,
  ...restProps
}) {
  const classes = clsx("navbar-nav", className);
  return /* @__PURE__ */ jsx("ul", { className: classes, ...restProps, children });
}
function NavLink({
  link,
  className,
  children,
  translate,
  ...restProps
}) {
  const classes = clsx("nav-link", className);
  return /* @__PURE__ */ jsxs("a", { href: link, className: classes, ...restProps, children: [
    children,
    translate && /* @__PURE__ */ jsx(VisuallyHidden$1, { children: /* @__PURE__ */ jsx("span", { className: "nav-text", children: translate }) })
  ] });
}
const WidgetAppsFooter = () => {
  const {
    t
  } = useTranslation();
  return /* @__PURE__ */ jsx("div", { className: "widget-footer", children: /* @__PURE__ */ jsx("div", { className: "widget-footer-action", children: /* @__PURE__ */ jsx("a", { href: "/welcome", className: "link", children: t("plus") }) }) });
}, WidgetAppsBody = ({
  bookmarkedApps
}) => {
  const {
    t
  } = useTranslation();
  return /* @__PURE__ */ jsxs("div", { className: "widget-body d-flex flex-wrap", children: [
    !bookmarkedApps.length && /* @__PURE__ */ jsx("div", { className: "text-dark", children: t("navbar.myapps.more") }),
    bookmarkedApps.slice(0, 6).map((app, index) => /* @__PURE__ */ jsx("a", { href: app.address, className: "bookmarked-app", children: /* @__PURE__ */ jsx(AppIcon$1, { app, size: "32" }) }, index))
  ] });
}, Header$1 = ({
  is1d = !1,
  src = ""
}) => {
  const {
    t
  } = useTranslation(), {
    messages,
    msgLink,
    zimbraWorkflow
  } = useConversation$1(), {
    user,
    avatar
  } = useUser(), {
    currentLanguage,
    currentApp
  } = useOdeClient(), hasOldHelpEnableWorkflow = useHasWorkflow("org.entcore.portal.controllers.PortalController|oldHelpEnable") || !1, {
    isModalOpen: isHelpOpen,
    setIsModalOpen: setIsHelpOpen,
    parsedContent,
    parsedHeadline,
    error
  } = useHelp(), classes = clsx("header", {
    "no-2d": is1d,
    "no-1d": !is1d
  }), {
    title,
    bookmarkedApps,
    appsRef,
    isAppsHovered,
    popoverAppsId,
    userAvatar,
    userName,
    welcomeUser,
    communityWorkflow,
    conversationWorflow,
    searchWorkflow,
    isCollapsed,
    toggleCollapsedNav,
    handleLogout
  } = useHeader({
    user,
    avatar
  }), hasMessages = messages > 0, {
    theme
  } = useOdeTheme();
  return /* @__PURE__ */ jsx("header", { className: classes, children: is1d ? /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("div", { className: "container-fluid", children: /* @__PURE__ */ jsxs(Navbar, { children: [
      /* @__PURE__ */ jsx("a", { className: "navbar-title d-md-none text-truncate h4", href: currentApp ? currentApp.address : "/timeline/timeline", children: title }),
      /* @__PURE__ */ jsxs("div", { className: "d-none d-md-inline-flex gap-12 align-items-center", children: [
        /* @__PURE__ */ jsx(Avatar, { alt: userName, size: "sm", src: userAvatar, variant: "circle", width: "32", height: "32" }),
        /* @__PURE__ */ jsx("span", { className: "navbar-text", children: welcomeUser })
      ] }),
      /* @__PURE__ */ jsxs(NavBarNav, { className: "gap-8", "aria-hidden": "false", "aria-label": t("navbar.main.navigation"), children: [
        conversationWorflow && /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs("a", { href: "/conversation/conversation", className: "nav-link", children: [
          /* @__PURE__ */ jsx(OneMessaging, { className: "icon notification" }),
          hasMessages && /* @__PURE__ */ jsx(Badge, { variant: {
            type: "notification",
            level: "danger"
          }, className: "position-absolute", children: messages }),
          /* @__PURE__ */ jsx(VisuallyHidden$1, { children: t("navbar.messages") })
        ] }) }),
        /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsx(NavLink, { link: "/userbook/mon-compte", className: "dropdown-item", translate: t("navbar.myaccount"), children: /* @__PURE__ */ jsx(OneProfile, { className: "icon user" }) }) }),
        currentLanguage === "fr" && hasOldHelpEnableWorkflow ? /* @__PURE__ */ jsxs(NavItem, { children: [
          /* @__PURE__ */ jsxs("button", { className: "nav-link", onClick: () => {
            setIsHelpOpen(!0);
          }, children: [
            /* @__PURE__ */ jsx(OneAssistance, { className: "icon help" }),
            /* @__PURE__ */ jsx(VisuallyHidden$1, { children: t("navbar.help") })
          ] }),
          /* @__PURE__ */ jsx(Help, { isHelpOpen, setIsHelpOpen, parsedContent, parsedHeadline, error })
        ] }) : null,
        /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs("button", { className: "nav-link", onClick: handleLogout, children: [
          /* @__PURE__ */ jsx(Disconnect, { className: "icon logout" }),
          /* @__PURE__ */ jsx(VisuallyHidden$1, { children: t("navbar.disconnect") })
        ] }) }),
        /* @__PURE__ */ jsx(NavItem, { className: "d-md-none", children: /* @__PURE__ */ jsx("button", { className: "nav-link btn btn-naked", type: "button", "aria-controls": "navbarCollapsed", "aria-expanded": !isCollapsed, "aria-label": t("navbar.secondary.navigation"), onClick: toggleCollapsedNav, children: /* @__PURE__ */ jsx(RafterDown, { className: "icon rafter-down", width: "20", height: "20" }) }) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsx(Navbar, { className: "no-2d navbar-secondary navbar-expand-md", "aria-label": t("navbar.secondary.navigation"), children: /* @__PURE__ */ jsx("div", { className: "container-fluid", children: /* @__PURE__ */ jsxs("div", { className: `collapse navbar-collapse ${isCollapsed ? "" : "show"}`, id: "navbarCollapsed", children: [
      /* @__PURE__ */ jsx(Logo$1, { is1d: !0, src: `${src}/img/illustrations/logo.png`, translate: t("navbar.home") }),
      /* @__PURE__ */ jsxs(NavBarNav, { className: "gap-8", children: [
        /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs("a", { href: "/timeline/timeline", className: "button", children: [
          /* @__PURE__ */ jsx(NewRelease, { color: "#fff", className: "d-md-none" }),
          /* @__PURE__ */ jsx("span", { className: "d-inline-block", children: t("portal.header.navigation.whatsnew") })
        ] }) }),
        /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs("a", { href: "/userbook/annuaire", className: "button", children: [
          /* @__PURE__ */ jsx(Userbook, { color: "#fff", className: "d-md-none" }),
          /* @__PURE__ */ jsx("span", { className: "d-inline-block", children: t("portal.header.navigation.classMembers") })
        ] }) }),
        /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs("a", { href: "/welcome", className: "button", children: [
          /* @__PURE__ */ jsx(MyApps, { color: "#fff", className: "d-md-none" }),
          /* @__PURE__ */ jsx("span", { className: "d-inline-block", children: t("portal.header.navigation.myapps") })
        ] }) })
      ] })
    ] }) }) })
  ] }) : /* @__PURE__ */ jsx(Navbar, { className: "navbar-expand-md", children: /* @__PURE__ */ jsxs("div", { className: "container-fluid", children: [
    /* @__PURE__ */ jsx(Logo$1, { src: `${src}/img/illustrations/logo.png` }),
    /* @__PURE__ */ jsx("a", { href: currentApp ? currentApp.address : "/timeline/timeline", className: "navbar-title text-truncate d-md-none", children: title }),
    /* @__PURE__ */ jsxs("ul", { className: "navbar-nav", children: [
      /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsx(NavLink, { link: "/timeline/timeline", translate: t("navbar.home"), children: /* @__PURE__ */ jsx(Home, { color: "#fff" }) }) }),
      /* @__PURE__ */ jsxs(NavItem, { className: "position-relative", ref: appsRef, id: popoverAppsId, "aria-haspopup": "true", "aria-expanded": isAppsHovered, children: [
        /* @__PURE__ */ jsx(NavLink, { link: "/welcome", translate: t("navbar.applications"), children: /* @__PURE__ */ jsx(MyApps, { color: "#fff" }) }),
        /* @__PURE__ */ jsxs(Popover, { className: "top-100 widget", id: popoverAppsId, isVisible: isAppsHovered, children: [
          /* @__PURE__ */ jsx(PopoverBody, { children: /* @__PURE__ */ jsx(WidgetAppsBody, { bookmarkedApps }) }),
          /* @__PURE__ */ jsx(PopoverFooter, { className: "widget-footer border-top border-ghost", children: /* @__PURE__ */ jsx(WidgetAppsFooter, {}) })
        ] })
      ] }),
      conversationWorflow && /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs(NavLink, { className: "position-relative", link: "/conversation/conversation", translate: t("conversation"), children: [
        /* @__PURE__ */ jsx(NeoMessaging, { color: "#fff" }),
        hasMessages && /* @__PURE__ */ jsx(Badge, { variant: {
          type: "notification",
          level: "warning"
        }, className: "position-absolute", children: messages })
      ] }) }),
      zimbraWorkflow && /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs(NavLink, { className: "position-relative", link: msgLink, translate: t("conversation"), children: [
        /* @__PURE__ */ jsx(NeoMessaging, { color: "#fff" }),
        hasMessages && /* @__PURE__ */ jsx(Badge, { variant: {
          type: "notification",
          level: "warning"
        }, className: "position-absolute", children: messages })
      ] }) }),
      currentLanguage === "fr" && hasOldHelpEnableWorkflow ? /* @__PURE__ */ jsxs(NavItem, { children: [
        /* @__PURE__ */ jsxs("button", { className: "nav-link btn btn-naked", onClick: () => {
          setIsHelpOpen(!0);
        }, children: [
          /* @__PURE__ */ jsx(NeoAssistance, { color: "#fff" }),
          /* @__PURE__ */ jsx(VisuallyHidden$1, { children: t("support") })
        ] }),
        /* @__PURE__ */ jsx(Help, { isHelpOpen, setIsHelpOpen, parsedContent, parsedHeadline, error })
      ] }) : null,
      /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs("div", { className: "dropdown", children: [
        /* @__PURE__ */ jsx("button", { className: "nav-link btn btn-naked d-md-none", type: "button", "aria-controls": "dropdown-navbar", "aria-expanded": !isCollapsed, "aria-label": t("navbar.open.menu"), onClick: toggleCollapsedNav, children: /* @__PURE__ */ jsx(RafterDown, { className: "icon rafter-down", width: "20", height: "20", color: "#fff" }) }),
        /* @__PURE__ */ jsxs("ul", { className: `dropdown-menu dropdown-menu-end ${isCollapsed ? "" : "show"}`, id: "dropdown-navbar", children: [
          communityWorkflow && /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs("a", { href: "/community", className: "nav-link dropdown-item", children: [
            /* @__PURE__ */ jsx(Community, { className: "icon community" }),
            /* @__PURE__ */ jsx("span", { className: "nav-text", children: t("navbar.community") })
          ] }) }),
          searchWorkflow ? /* @__PURE__ */ jsx(SearchEngine$1, {}) : null,
          /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs("a", { href: "/userbook/mon-compte", className: "nav-link dropdown-item", children: [
            /* @__PURE__ */ jsx(Avatar, { alt: userName, size: "sm", src: userAvatar, variant: "circle", className: "bg-white", width: "32", height: "32" }),
            /* @__PURE__ */ jsx("span", { className: "nav-text", children: t("navbar.myaccount") })
          ] }) }),
          /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsx("hr", { className: "dropdown-divider" }) }),
          /* @__PURE__ */ jsx(NavItem, { children: /* @__PURE__ */ jsxs("a", { href: "/auth/logout?callback=" + ((theme == null ? void 0 : theme.logoutCallback) ?? "/"), className: "nav-link dropdown-item", children: [
            /* @__PURE__ */ jsx(Disconnect, { className: "icon logout" }),
            /* @__PURE__ */ jsx("span", { id: "logout-label", className: "nav-text", children: t("navbar.disconnect") })
          ] }) })
        ] })
      ] }) })
    ] })
  ] }) }) });
}, Header$2 = Header$1, Layout = ({
  children,
  headless = !1,
  ...restProps
}) => {
  const {
    theme
  } = useOdeTheme(), {
    t
  } = useTranslation(), {
    showCookiesConsent,
    handleConsultCookies,
    handleCloseCookiesConsent
  } = useCookiesConsent();
  useZendeskGuide(), useCantoo();
  const classes = clsx("d-flex flex-column bg-white", {
    "container-fluid": !headless,
    "rounded-4 border": (theme == null ? void 0 : theme.is1d) && !headless,
    "mt-24": (theme == null ? void 0 : theme.is1d) && !headless
  }), renderHeader = headless ? null : /* @__PURE__ */ jsx(Header$2, { is1d: theme == null ? void 0 : theme.is1d, src: theme == null ? void 0 : theme.basePath }), renderCookies = showCookiesConsent && /* @__PURE__ */ jsx(Alert$1, { type: "info", className: "m-12 rgpd", isConfirm: !0, position: "bottom-right", button: /* @__PURE__ */ jsx(Button, { color: "tertiary", variant: "ghost", onClick: handleConsultCookies, children: t("rgpd.cookies.banner.button.consult") }), onClose: handleCloseCookiesConsent, children: t("rgpd.cookies.banner.text1") }), renderToaster = /* @__PURE__ */ jsx(Toaster, { containerClassName: "toaster-container", toastOptions: {
    position: "top-right"
  } });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    renderHeader,
    /* @__PURE__ */ jsx("main", { className: classes, ...restProps, children }),
    renderToaster,
    renderCookies
  ] });
}, Layout$1 = Layout, Footer = ({
  children
}) => /* @__PURE__ */ jsx("div", { className: "widget-footer", children: /* @__PURE__ */ jsx("div", { className: "widget-footer-action", children: /* @__PURE__ */ jsx("a", { href: "/welcome", className: "link", children }) }) }), Header = ({
  children
}) => /* @__PURE__ */ jsxs("div", { className: "widget-header", children: [
  /* @__PURE__ */ jsx("div", { className: "subtitle", children }),
  /* @__PURE__ */ jsx("div", { className: "widget-options", children: /* @__PURE__ */ jsx("div", { className: "widget-handle", children: /* @__PURE__ */ jsx("i", { className: "fas fa-grip-vertical" }) }) })
] }), Body = ({
  children
}) => /* @__PURE__ */ jsx("div", { className: "widget-body p-12 d-flex flex-wrap", children });
function Widget({
  children
}) {
  return /* @__PURE__ */ jsx("div", { className: "widget", children });
}
Widget.Header = Header;
Widget.Body = Body;
Widget.Footer = Footer;
const BookmarkedApps = ({
  data
}) => data.length > 0 ? data.slice(0, 6).map((app, index) => /* @__PURE__ */ jsx("a", { href: app.address, className: "bookmarked-app", children: /* @__PURE__ */ jsx(AppIcon$1, { app, size: "32" }) }, index)) : /* @__PURE__ */ jsx("div", { className: "text-dark mx-auto", children: /* @__PURE__ */ jsx("a", { href: "/welcome", children: "Sélectionner vos applications favorites" }) }), BookmarkedApps$1 = BookmarkedApps;
export {
  AccessiblePalette,
  ActionBar$1 as ActionBar,
  Alert$1 as Alert,
  AppHeader$1 as AppHeader,
  AppIcon$1 as AppIcon,
  Attachment$1 as Attachment,
  AudioRecorder$1 as AudioRecorder,
  Avatar,
  Badge,
  BlogPublic$1 as BlogPublic,
  BookmarkedApps$1 as BookmarkedApps,
  Breadcrumb$1 as Breadcrumb,
  Button,
  Card$1 as Card,
  Checkbox$1 as Checkbox,
  ColorPicker$1 as ColorPicker,
  ColorPickerItem$1 as ColorPickerItem,
  Column,
  Combobox$1 as Combobox,
  DefaultPalette,
  DndTree$1 as DndTree,
  Dropdown$1 as Dropdown,
  Dropzone$1 as Dropzone,
  DropzoneContext,
  Embed$1 as Embed,
  EmptyScreen,
  ExternalLinker$1 as ExternalLinker,
  FileCard$1 as FileCard,
  FormControl$1 as FormControl,
  FormText$1 as FormText,
  Grid,
  Heading,
  IconButton$1 as IconButton,
  Image$1 as Image,
  ImageEditor$1 as ImageEditor,
  ImagePicker$1 as ImagePicker,
  Input$1 as Input,
  InternalLinker$1 as InternalLinker,
  Label$1 as Label,
  Layout$1 as Layout,
  List,
  Loading,
  LoadingScreen$1 as LoadingScreen,
  Logo$1 as Logo,
  MediaLibrary$1 as MediaLibrary,
  Menu,
  MockedDataProvider,
  Modal$1 as Modal,
  NOOP,
  O as OdeClientContext,
  e as OdeClientProvider,
  OnboardingModal$1 as OnboardingModal,
  Popover,
  PopoverBody,
  PopoverFooter,
  PopoverHeader,
  PublishModal,
  Radio$1 as Radio,
  ReactionChoice$1 as ReactionChoice,
  ReactionModal$1 as ReactionModal,
  ReactionSummary$1 as ReactionSummary,
  ResourceModal$1 as ResourceModal,
  SearchBar$1 as SearchBar,
  SearchButton$1 as SearchButton,
  Select$1 as Select,
  ShareBlog,
  ShareResourceModal as ShareModal,
  SortableTree$1 as SortableTree,
  StringUtils,
  Table$1 as Table,
  Tabs,
  TextArea$1 as TextArea,
  ThemeContext,
  ThemeProvider,
  Toolbar,
  Tooltip$1 as Tooltip,
  Tree$1 as Tree,
  TreeNode,
  TreeNodeFolderWrapper,
  TreeView$1 as TreeView,
  UploadCard$1 as UploadCard,
  VideoRecorder$1 as VideoRecorder,
  ViewsCounter$1 as ViewsCounter,
  ViewsModal$1 as ViewsModal,
  VisuallyHidden$1 as VisuallyHidden,
  Widget,
  Component as Workspace,
  addNode,
  addTimestampToImageUrl,
  arrayUnique,
  buildTree,
  checkUserRight,
  convertMsToMS,
  deleteNode,
  determineNewParentId,
  findItemIndexInTree,
  findNodeById$1 as findNodeById,
  findParentNode,
  findPathById$1 as findPathById,
  findTreeNode,
  flattenTree,
  generateUpdateData,
  getActiveAndOverNodes,
  getAncestors,
  getBestSupportedMimeType,
  getDragDepth,
  getIndicesToUpdate,
  getOrGenerateBlobId,
  getProjection,
  getThumbnail,
  hasChildren,
  isActionAvailable,
  libraryMaps,
  mergeRefs,
  modifyNode,
  moveNode,
  padTo2Digits,
  setRef,
  updateNode,
  updateParentIds,
  useAvatar,
  useBookmark,
  useBreakpoint,
  useBrowserInfo,
  useCantoo,
  useCheckable,
  useClickOutside,
  useConf,
  useConversation$1 as useConversation,
  useDate,
  useDebounce,
  f as useDirectory,
  useDropdown$1 as useDropdown,
  useDropzone$1 as useDropzone,
  useDropzoneContext,
  useHasWorkflow,
  useHeader,
  useHover,
  useHttpErrorToast$1 as useHttpErrorToast,
  h as useImage,
  useIsAdml,
  useKeyPress,
  useLibraryUrl$1 as useLibraryUrl,
  useMediaLibrary$1 as useMediaLibrary,
  useMockedData,
  useOdeClient,
  useOdeIcons,
  useOdeTheme,
  usePaths,
  useReactionIcons,
  useReactions,
  useResourceSearch,
  useScrollToTop,
  g as useSession,
  useShareMutation$1 as useShareMutation,
  useTitle,
  useToast,
  useToggle,
  useTrapFocus,
  useTrashedResource$1 as useTrashedResource,
  useTreeSortable,
  useTreeView,
  useUpdateMutation$1 as useUpdateMutation,
  useUpload$1 as useUpload,
  useUploadFiles$1 as useUploadFiles,
  useUser,
  useWorkspaceFile$1 as useWorkspaceFile,
  useWorkspaceSearch,
  useXitiTrackPageLoad,
  useZendeskGuide,
  wrapTreeNode
};
